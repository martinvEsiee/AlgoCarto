; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\sound_task.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\sound_task.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\sound_task.crf sound_task.c]
                          THUMB

                          AREA ||i.SoundTask||, CODE, READONLY, ALIGN=2

                  SoundTask PROC
;;;60     void
;;;61     SoundTask(void *pvParam)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
;;;63         static unsigned long ulState = SOUND_STATE_IDLE;
;;;64     
;;;65         //
;;;66         // Process the state machine
;;;67         //
;;;68         switch(ulState)
000002  4c11              LDR      r4,|L1.72|
000004  2500              MOVS     r5,#0
000006  6820              LDR      r0,[r4,#0]  ; ulState
000008  b120              CBZ      r0,|L1.20|
00000a  2801              CMP      r0,#1
00000c  d014              BEQ      |L1.56|
;;;69         {
;;;70             //
;;;71             // IDLE - not playing a sound
;;;72             //
;;;73             case SOUND_STATE_IDLE:
;;;74             {
;;;75                 //
;;;76                 // If there is a new clip ready to play, then start playing it.
;;;77                 //
;;;78                 if(pucNextPlaying)
;;;79                 {
;;;80                     //
;;;81                     // Set the current playing clip to match the new clip, and
;;;82                     // clear the "next" clip pointer.
;;;83                     //
;;;84                     pucNowPlaying = pucNextPlaying;
;;;85                     pucNextPlaying = 0;
;;;86     
;;;87                     //
;;;88                     // Open the new clip as a wave file
;;;89                     //
;;;90                     if(WaveOpen((unsigned long *)pucNowPlaying,
;;;91                                 &sSoundEffectHeader) == WAVE_OK)
;;;92                     {
;;;93                         //
;;;94                         // If the clip opened okay as a wave file, then start the
;;;95                         // clip playing and change our state to PLAYING
;;;96                         //
;;;97                         ulState = SOUND_STATE_PLAYING;
;;;98                         WavePlayStart(&sSoundEffectHeader);
;;;99                     }
;;;100    
;;;101                    //
;;;102                    // Otherwise the clip was not opened successfully in which
;;;103                    // case clear the current playing clip and remain in IDLE state
;;;104                    //
;;;105                    else
;;;106                    {
;;;107                        pucNowPlaying = 0;
;;;108                    }
;;;109                }
;;;110                break;
;;;111            }
;;;112    
;;;113            //
;;;114            // PLAYING - a clip is playing
;;;115            //
;;;116            case SOUND_STATE_PLAYING:
;;;117            {
;;;118                //
;;;119                // Call the function to continue wave playing.  This function must
;;;120                // be called periodically, and it will keep the wave driver playing
;;;121                // the audio clip until it is finished.
;;;122                //
;;;123                if(WavePlayContinue(&sSoundEffectHeader))
;;;124                {
;;;125                    //
;;;126                    // Clip is done playing, so clear the playing clip pointer and
;;;127                    // set the state back to IDLE.
;;;128                    //
;;;129                    pucNowPlaying = 0;
;;;130                    ulState = SOUND_STATE_IDLE;
;;;131                }
;;;132                break;
;;;133            }
;;;134    
;;;135            //
;;;136            // default state is an error.  Clear the current and next clip pointers
;;;137            // and set the state back to IDLE
;;;138            //
;;;139            default:
;;;140            {
;;;141                pucNowPlaying = 0;
;;;142                pucNextPlaying = 0;
00000e  6065              STR      r5,[r4,#4]  ; pucNowPlaying
;;;143                ulState = SOUND_STATE_IDLE;
;;;144                break;
000010  60a5              STR      r5,[r4,#8]  ; pucNextPlaying
000012  e017              B        |L1.68|
                  |L1.20|
000014  68a0              LDR      r0,[r4,#8]            ;78  ; pucNextPlaying
000016  2800              CMP      r0,#0                 ;78
000018  d006              BEQ      |L1.40|
00001a  e9c40501          STRD     r0,r5,[r4,#4]         ;90
00001e  490b              LDR      r1,|L1.76|
000020  f7fffffe          BL       WaveOpen
000024  b108              CBZ      r0,|L1.42|
000026  6065              STR      r5,[r4,#4]            ;107  ; pucNowPlaying
                  |L1.40|
;;;145            }
;;;146        }
;;;147    }
000028  bd70              POP      {r4-r6,pc}
                  |L1.42|
00002a  2001              MOVS     r0,#1                 ;97
00002c  6020              STR      r0,[r4,#0]            ;98  ; ulState
00002e  e8bd4070          POP      {r4-r6,lr}            ;98
000032  4806              LDR      r0,|L1.76|
000034  f7ffbffe          B.W      WavePlayStart
                  |L1.56|
000038  4804              LDR      r0,|L1.76|
00003a  f7fffffe          BL       WavePlayContinue
00003e  2800              CMP      r0,#0                 ;123
000040  d0f2              BEQ      |L1.40|
000042  6065              STR      r5,[r4,#4]            ;129  ; pucNowPlaying
                  |L1.68|
000044  6025              STR      r5,[r4,#0]            ;143  ; ulState
000046  bd70              POP      {r4-r6,pc}
;;;148    
                          ENDP

                  |L1.72|
                          DCD      ||.data||
                  |L1.76|
                          DCD      ||.bss||

                          AREA ||i.SoundTaskInit||, CODE, READONLY, ALIGN=1

                  SoundTaskInit PROC
;;;155    void
;;;156    SoundTaskInit(void *pvParam)
000000  f7ffbffe          B.W      SoundInit
;;;157    {
;;;158        SoundInit();
;;;159    }
;;;160    
                          ENDP


                          AREA ||i.SoundTaskPlay||, CODE, READONLY, ALIGN=2

                  SoundTaskPlay PROC
;;;166    void
;;;167    SoundTaskPlay(const unsigned char *pucSound)
000000  4901              LDR      r1,|L3.8|
;;;168    {
;;;169        //
;;;170        // Set the "next" pointer to point at the requested clip.
;;;171        //
;;;172        pucNextPlaying = pucSound;
000002  6088              STR      r0,[r1,#8]  ; pucNextPlaying
;;;173    }
000004  4770              BX       lr
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  sSoundEffectHeader
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  ulState
                          DCD      0x00000000
                  pucNowPlaying
                          DCD      0x00000000
                  pucNextPlaying
                          DCD      0x00000000
