; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\scheduler.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\scheduler.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\scheduler.crf ..\..\..\utils\scheduler.c]
                          THUMB

                          AREA ||i.SchedulerElapsedTicksCalc||, CODE, READONLY, ALIGN=1

                  SchedulerElapsedTicksCalc PROC
;;;292    unsigned long
;;;293    SchedulerElapsedTicksCalc(unsigned long ulTickStart, unsigned long ulTickEnd)
000000  4281              CMP      r1,r0
;;;294    {
;;;295        return((ulTickEnd > ulTickStart) ? (ulTickEnd - ulTickStart) :
000002  d901              BLS      |L1.8|
000004  1a08              SUBS     r0,r1,r0
;;;296               ((0xFFFFFFFF - ulTickStart) + ulTickEnd + 1));
;;;297    }
000006  4770              BX       lr
                  |L1.8|
000008  43c0              MVNS     r0,r0                 ;296
00000a  4408              ADD      r0,r0,r1              ;296
00000c  1c40              ADDS     r0,r0,#1              ;296
00000e  4770              BX       lr
;;;298    
                          ENDP


                          AREA ||i.SchedulerElapsedTicksGet||, CODE, READONLY, ALIGN=2

                  SchedulerElapsedTicksGet PROC
;;;265    unsigned long
;;;266    SchedulerElapsedTicksGet(unsigned long ulTickCount)
000000  4901              LDR      r1,|L2.8|
;;;267    {
;;;268        //
;;;269        // Determine the calculation based upon whether the global tick count has
;;;270        // wrapped since the passed ulTickCount.
;;;271        //
;;;272        return(SchedulerElapsedTicksCalc(ulTickCount, g_ulSchedulerTickCount));
000002  6809              LDR      r1,[r1,#0]  ; g_ulSchedulerTickCount
000004  f7ffbffe          B.W      SchedulerElapsedTicksCalc
;;;273    }
;;;274    
                          ENDP

                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.SchedulerInit||, CODE, READONLY, ALIGN=1

                  SchedulerInit PROC
;;;80     void
;;;81     SchedulerInit(unsigned long ulTicksPerSecond)
000000  b510              PUSH     {r4,lr}
;;;82     {
000002  4604              MOV      r4,r0
;;;83         ASSERT(ulTicksPerSecond);
;;;84     
;;;85         //
;;;86         // Configure SysTick for a periodic interrupt.
;;;87         //
;;;88         SysTickPeriodSet(SysCtlClockGet() / ulTicksPerSecond);
000004  f7fffffe          BL       SysCtlClockGet
000008  fbb0f0f4          UDIV     r0,r0,r4
00000c  f7fffffe          BL       SysTickPeriodSet
;;;89         SysTickEnable();
000010  f7fffffe          BL       SysTickEnable
;;;90         SysTickIntEnable();
000014  e8bd4010          POP      {r4,lr}
000018  f7ffbffe          B.W      SysTickIntEnable
;;;91     }
;;;92     
                          ENDP


                          AREA ||i.SchedulerRun||, CODE, READONLY, ALIGN=2

                  SchedulerRun PROC
;;;110    void
;;;111    SchedulerRun(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;112    {
;;;113        unsigned long ulLoop;
;;;114        tSchedulerTask *psTask;
;;;115    
;;;116        //
;;;117        // Loop through each task in the task table.
;;;118        //
;;;119        for(ulLoop = 0; ulLoop < g_ulSchedulerNumTasks; ulLoop++)
000004  2400              MOVS     r4,#0
;;;120        {
;;;121            //
;;;122            // Get a pointer to the task information.
;;;123            //
;;;124            psTask = &g_psSchedulerTable[ulLoop];
000006  4d0d              LDR      r5,|L4.60|
;;;125    
;;;126            //
;;;127            // Is this task active and, if so, is it time to call it's function?
;;;128            //
;;;129            if(psTask->bActive && (SchedulerElapsedTicksGet(psTask->ulLastCall) >=
;;;130               psTask->ulFrequencyTicks))
;;;131            {
;;;132                //
;;;133                // Remember the timestamp at which we make the function call.
;;;134                //
;;;135                psTask->ulLastCall = g_ulSchedulerTickCount;
000008  4e0d              LDR      r6,|L4.64|
00000a  4f0e              LDR      r7,|L4.68|
00000c  e011              B        |L4.50|
                  |L4.14|
00000e  eb040084          ADD      r0,r4,r4,LSL #2       ;124
000012  eb050280          ADD      r2,r5,r0,LSL #2       ;124
000016  7c10              LDRB     r0,[r2,#0x10]         ;129
000018  b150              CBZ      r0,|L4.48|
00001a  68d0              LDR      r0,[r2,#0xc]          ;129
00001c  f7fffffe          BL       SchedulerElapsedTicksGet
000020  6891              LDR      r1,[r2,#8]            ;129
000022  4288              CMP      r0,r1                 ;129
000024  d304              BCC      |L4.48|
000026  6830              LDR      r0,[r6,#0]  ; g_ulSchedulerTickCount
000028  60d0              STR      r0,[r2,#0xc]
00002a  e9d21000          LDRD     r1,r0,[r2,#0]
;;;136    
;;;137                //
;;;138                // Call the task function, passing the provided parameter.
;;;139                //
;;;140                psTask->pfnFunction(psTask->pvParam);
00002e  4788              BLX      r1
                  |L4.48|
000030  1c64              ADDS     r4,r4,#1              ;119
                  |L4.50|
000032  6838              LDR      r0,[r7,#0]            ;119  ; g_ulSchedulerNumTasks
000034  4284              CMP      r4,r0                 ;119
000036  d3ea              BCC      |L4.14|
;;;141            }
;;;142        }
;;;143    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;144    
                          ENDP

                  |L4.60|
                          DCD      g_psSchedulerTable
                  |L4.64|
                          DCD      ||.data||
                  |L4.68|
                          DCD      g_ulSchedulerNumTasks

                          AREA ||i.SchedulerSysTickIntHandler||, CODE, READONLY, ALIGN=2

                  SchedulerSysTickIntHandler PROC
;;;51     void
;;;52     SchedulerSysTickIntHandler(void)
000000  4802              LDR      r0,|L5.12|
;;;53     {
;;;54         g_ulSchedulerTickCount++;
000002  6801              LDR      r1,[r0,#0]  ; g_ulSchedulerTickCount
000004  1c49              ADDS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]  ; g_ulSchedulerTickCount
;;;55     }
000008  4770              BX       lr
;;;56     
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      ||.data||

                          AREA ||i.SchedulerTaskDisable||, CODE, READONLY, ALIGN=2

                  SchedulerTaskDisable PROC
;;;214    void
;;;215    SchedulerTaskDisable(unsigned long ulIndex)
000000  4905              LDR      r1,|L6.24|
;;;216    {
;;;217        //
;;;218        // Is the task index passed valid?
;;;219        //
;;;220        if(ulIndex < g_ulSchedulerNumTasks)
000002  6809              LDR      r1,[r1,#0]  ; g_ulSchedulerNumTasks
000004  4288              CMP      r0,r1
000006  d206              BCS      |L6.22|
;;;221        {
;;;222            //
;;;223            // Yes - mark the task as inactive.
;;;224            //
;;;225            g_psSchedulerTable[ulIndex].bActive = false;
000008  4a04              LDR      r2,|L6.28|
00000a  eb000080          ADD      r0,r0,r0,LSL #2
00000e  eb020080          ADD      r0,r2,r0,LSL #2
000012  2100              MOVS     r1,#0
000014  7401              STRB     r1,[r0,#0x10]
                  |L6.22|
;;;226        }
;;;227    }
000016  4770              BX       lr
;;;228    
                          ENDP

                  |L6.24|
                          DCD      g_ulSchedulerNumTasks
                  |L6.28|
                          DCD      g_psSchedulerTable

                          AREA ||i.SchedulerTaskEnable||, CODE, READONLY, ALIGN=2

                  SchedulerTaskEnable PROC
;;;164    void
;;;165    SchedulerTaskEnable(unsigned long ulIndex, tBoolean bRunNow)
000000  4a09              LDR      r2,|L7.40|
;;;166    {
;;;167        //
;;;168        // Is the task index passed valid?
;;;169        //
;;;170        if(ulIndex < g_ulSchedulerNumTasks)
000002  6812              LDR      r2,[r2,#0]  ; g_ulSchedulerNumTasks
000004  4290              CMP      r0,r2
000006  d20e              BCS      |L7.38|
;;;171        {
;;;172            //
;;;173            // Yes - mark the task as active.
;;;174            //
;;;175            g_psSchedulerTable[ulIndex].bActive = true;
000008  eb000380          ADD      r3,r0,r0,LSL #2
00000c  4807              LDR      r0,|L7.44|
00000e  2201              MOVS     r2,#1
000010  eb000083          ADD      r0,r0,r3,LSL #2
000014  7402              STRB     r2,[r0,#0x10]
;;;176    
;;;177            //
;;;178            // Set the last call time to ensure that the function is called either
;;;179            // next time the scheduler is run or after the desired number of ticks
;;;180            // depending upon the value of the bRunNow parameter.
;;;181            //
;;;182            if(bRunNow)
;;;183            {
;;;184                //
;;;185                // Cause the task to run on the next call to SchedulerRun().
;;;186                //
;;;187                g_psSchedulerTable[ulIndex].ulLastCall = (g_ulSchedulerTickCount -
000016  4a06              LDR      r2,|L7.48|
000018  b119              CBZ      r1,|L7.34|
00001a  6881              LDR      r1,[r0,#8]
00001c  6812              LDR      r2,[r2,#0]  ; g_ulSchedulerTickCount
00001e  1a51              SUBS     r1,r2,r1
000020  e000              B        |L7.36|
                  |L7.34|
;;;188                                g_psSchedulerTable[ulIndex].ulFrequencyTicks);
;;;189            }
;;;190            else
;;;191            {
;;;192                //
;;;193                // Cause the task to run after one full time period.
;;;194                //
;;;195                g_psSchedulerTable[ulIndex].ulLastCall = g_ulSchedulerTickCount;
000022  6811              LDR      r1,[r2,#0]  ; g_ulSchedulerTickCount
                  |L7.36|
000024  60c1              STR      r1,[r0,#0xc]
                  |L7.38|
;;;196            }
;;;197        }
;;;198    }
000026  4770              BX       lr
;;;199    
                          ENDP

                  |L7.40|
                          DCD      g_ulSchedulerNumTasks
                  |L7.44|
                          DCD      g_psSchedulerTable
                  |L7.48|
                          DCD      ||.data||

                          AREA ||i.SchedulerTickCountGet||, CODE, READONLY, ALIGN=2

                  SchedulerTickCountGet PROC
;;;240    unsigned long
;;;241    SchedulerTickCountGet(void)
000000  4801              LDR      r0,|L8.8|
;;;242    {
;;;243        return(g_ulSchedulerTickCount);
000002  6800              LDR      r0,[r0,#0]  ; g_ulSchedulerTickCount
;;;244    }
000004  4770              BX       lr
;;;245    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  g_ulSchedulerTickCount
                          DCD      0x00000000
