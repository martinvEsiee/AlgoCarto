; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\dac.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\dac.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\dac.crf ..\drivers\dac.c]
                          THUMB

                          AREA ||i.DACClassDDis||, CODE, READONLY, ALIGN=1

                  DACClassDDis PROC
;;;578    void
;;;579    DACClassDDis(void)
000000  2140              MOVS     r1,#0x40
;;;580    {
;;;581        DACWriteRegister(TI_CLASSD_BYPASS_SWITCH_CTL_R, 0x40);
000002  2049              MOVS     r0,#0x49
000004  f7ffbffe          B.W      DACWriteRegister
;;;582    }
;;;583    
                          ENDP


                          AREA ||i.DACClassDEn||, CODE, READONLY, ALIGN=1

                  DACClassDEn PROC
;;;563    void
;;;564    DACClassDEn(void)
000000  2148              MOVS     r1,#0x48
;;;565    {
;;;566        DACWriteRegister(TI_CLASSD_BYPASS_SWITCH_CTL_R, 0x48);
000002  2049              MOVS     r0,#0x49
000004  f7ffbffe          B.W      DACWriteRegister
;;;567    }
;;;568    
                          ENDP


                          AREA ||i.DACInit||, CODE, READONLY, ALIGN=2

                  DACInit PROC
;;;251    tBoolean
;;;252    DACInit(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;253    {
;;;254        tBoolean bRetcode;
;;;255        unsigned char ucTest;
;;;256    
;;;257        //
;;;258        // Enable the GPIO port containing the I2C pins and set the SDA pin as a
;;;259        // GPIO input for now and engage a weak pull-down.  If the daughter board
;;;260        // is present, the pull-up on the board should easily overwhelm
;;;261        // the pull-down and we should read the line state as high.
;;;262        //
;;;263        ROM_SysCtlPeripheralEnable(DAC_I2CSCL_GPIO_PERIPH);
000002  f04f7480          MOV      r4,#0x1000000
000006  6c60              LDR      r0,[r4,#0x44]
000008  6981              LDR      r1,[r0,#0x18]
00000a  484b              LDR      r0,|L3.312|
00000c  4788              BLX      r1
;;;264        ROM_GPIOPinTypeGPIOInput(DAC_I2CSCL_GPIO_PORT, DAC_I2CSDA_PIN);
00000e  6a20              LDR      r0,[r4,#0x20]
000010  4e4a              LDR      r6,|L3.316|
000012  2108              MOVS     r1,#8
000014  6b82              LDR      r2,[r0,#0x38]
000016  4630              MOV      r0,r6
000018  4790              BLX      r2
;;;265        ROM_GPIOPadConfigSet(DAC_I2CSCL_GPIO_PORT, DAC_I2CSDA_PIN,
00001a  6a20              LDR      r0,[r4,#0x20]
00001c  230c              MOVS     r3,#0xc
00001e  2201              MOVS     r2,#1
000020  6945              LDR      r5,[r0,#0x14]
000022  2108              MOVS     r1,#8
000024  4630              MOV      r0,r6
000026  47a8              BLX      r5
;;;266                             GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPD);
;;;267    
;;;268        //
;;;269        // Enable the I2C peripheral.
;;;270        //
;;;271        ROM_SysCtlPeripheralEnable(DAC_I2C_PERIPH);
000028  6c60              LDR      r0,[r4,#0x44]
00002a  6981              LDR      r1,[r0,#0x18]
00002c  f04f2010          MOV      r0,#0x10001000
000030  4788              BLX      r1
;;;272    
;;;273        //
;;;274        // Delay a while to ensure that we read a stable value from the SDA
;;;275        // GPIO pin.  If we read too quickly, the result is unpredictable.
;;;276        // This delay is around 2mS.
;;;277        //
;;;278        SysCtlDelay(ROM_SysCtlClockGet() / (3 * 500));
000032  6c60              LDR      r0,[r4,#0x44]
000034  6e00              LDR      r0,[r0,#0x60]
000036  4780              BLX      r0
000038  f24051dc          MOV      r1,#0x5dc
00003c  fbb0f0f1          UDIV     r0,r0,r1
000040  f7fffffe          BL       SysCtlDelay
;;;279    
;;;280        //
;;;281        // Configure the pin mux.
;;;282        //
;;;283        GPIOPinConfigure(GPIO_PB2_I2C0SCL);
000044  483e              LDR      r0,|L3.320|
000046  f7fffffe          BL       GPIOPinConfigure
;;;284        GPIOPinConfigure(GPIO_PB3_I2C0SDA);
00004a  483e              LDR      r0,|L3.324|
00004c  f7fffffe          BL       GPIOPinConfigure
;;;285    
;;;286        //
;;;287        // Configure the I2C SCL and SDA pins for I2C operation.
;;;288        //
;;;289        ROM_GPIOPinTypeI2C(DAC_I2CSCL_GPIO_PORT, DAC_I2CSCL_PIN | DAC_I2CSDA_PIN);
000050  6a20              LDR      r0,[r4,#0x20]
000052  210c              MOVS     r1,#0xc
000054  6c02              LDR      r2,[r0,#0x40]
000056  4630              MOV      r0,r6
000058  4790              BLX      r2
;;;290    
;;;291        //
;;;292        // Initialize the I2C master.
;;;293        //
;;;294        ROM_I2CMasterInitExpClk(DAC_I2C_MASTER_BASE, SysCtlClockGet(), 0);
00005a  f7fffffe          BL       SysCtlClockGet
00005e  4601              MOV      r1,r0
000060  69e0              LDR      r0,[r4,#0x1c]
000062  2200              MOVS     r2,#0
000064  6843              LDR      r3,[r0,#4]
000066  4838              LDR      r0,|L3.328|
000068  4798              BLX      r3
;;;295    
;;;296        //
;;;297        // Enable the I2C peripheral.
;;;298        //
;;;299        ROM_SysCtlPeripheralEnable(DAC_RESET_GPIO_PERIPH);
00006a  6c60              LDR      r0,[r4,#0x44]
00006c  6981              LDR      r1,[r0,#0x18]
00006e  4832              LDR      r0,|L3.312|
000070  1e40              SUBS     r0,r0,#1
000072  4788              BLX      r1
;;;300    
;;;301        //
;;;302        // Configure the PH2 as a GPIO output.
;;;303        //
;;;304        ROM_GPIOPinTypeGPIOOutput(DAC_RESET_GPIO_PORT, DAC_RESET_PIN);
000074  6a20              LDR      r0,[r4,#0x20]
000076  f04f2540          MOV      r5,#0x40004000
00007a  2180              MOVS     r1,#0x80
00007c  6bc2              LDR      r2,[r0,#0x3c]
00007e  4628              MOV      r0,r5
000080  4790              BLX      r2
;;;305    
;;;306        //
;;;307        // Reset the DAC
;;;308        //
;;;309        ROM_GPIOPinWrite(DAC_RESET_GPIO_PORT , DAC_RESET_PIN, 0);
000082  6a20              LDR      r0,[r4,#0x20]
000084  2200              MOVS     r2,#0
000086  2180              MOVS     r1,#0x80
000088  6803              LDR      r3,[r0,#0]
00008a  4628              MOV      r0,r5
00008c  4798              BLX      r3
;;;310        ROM_GPIOPinWrite(DAC_RESET_GPIO_PORT , DAC_RESET_PIN, DAC_RESET_PIN);
00008e  6a20              LDR      r0,[r4,#0x20]
000090  2280              MOVS     r2,#0x80
000092  4611              MOV      r1,r2
000094  6803              LDR      r3,[r0,#0]
000096  4628              MOV      r0,r5
000098  4798              BLX      r3
;;;311    
;;;312        //
;;;313        // Reset the DAC.  Check the return code on this call since we use it to
;;;314        // indicate whether or not the DAC is present.  If the register write
;;;315        // fails, we assume the I2S daughter board and DAC are not present and
;;;316        // return false.
;;;317        //
;;;318        bRetcode = DACWriteRegister(TI_SOFTWARE_RESET_R, 0x80);
00009a  2180              MOVS     r1,#0x80
00009c  2001              MOVS     r0,#1
00009e  f7fffffe          BL       DACWriteRegister
;;;319        if(!bRetcode)
0000a2  2800              CMP      r0,#0
0000a4  d046              BEQ      |L3.308|
;;;320        {
;;;321            return(bRetcode);
;;;322        }
;;;323    
;;;324        //
;;;325        // Codec Datapath Setup Register
;;;326        // ----------------------
;;;327        // D7     = 1  : Fsref = 44.1-kHz
;;;328        // D6     = 0  : ADC Dual rate mode is disabled
;;;329        // D5     = 0  : DAC Dual rate mode is disabled
;;;330        // D[4:3] = 11 : Left DAC datapath plays mono mix of left and right channel
;;;331        //               input data
;;;332        // D[1:1] = 00 : Right DAC datapath is off
;;;333        // D0     = 0  : reserved
;;;334        // ----------------------
;;;335        // D[7:0] =  10011010
;;;336        //
;;;337        DACWriteRegister(TI_CODEC_DATAPATH_R, 0x98);
0000a6  2198              MOVS     r1,#0x98
0000a8  2007              MOVS     r0,#7
0000aa  f7fffffe          BL       DACWriteRegister
;;;338    
;;;339        //
;;;340        // Audio Serial Data Interface Control Register A
;;;341        // ----------------------
;;;342        // D7     = 0  : BCLK is an input (slave mode)
;;;343        // D6     = 0  : WCLK (or GPIO1 if programmed as WCLK) is an input
;;;344        //               (slave mode)
;;;345        // D5     = 0  : Do not 3-state DOUT when valid data is not being sent
;;;346        // D4     = 0  : BCLK / WCLK (or GPIO1 if programmed as WCLK) will not
;;;347        //               continue to be transmitted when running in master mode if codec is powered down
;;;348        // D3     = 0  : Reserved.
;;;349        // D2     = 0  : Disable 3-D digital effect processing
;;;350        // D[1:0] = 00 : reserved
;;;351        // ----------------------
;;;352        // D[7:0] = 00000000
;;;353        //
;;;354        DACWriteRegister(TI_ASDI_CTL_A_R, 0x00);
0000ae  2100              MOVS     r1,#0
0000b0  2008              MOVS     r0,#8
0000b2  f7fffffe          BL       DACWriteRegister
;;;355    
;;;356        //
;;;357        // Audio Serial Data Interface Control Register B
;;;358        // ----------------------
;;;359        // D[7:6] = 00 : Serial data bus uses I2S mode
;;;360        // D[5:4] = 00 : Audio data word length = 16-bits
;;;361        // D3     = 0  : Continuous-transfer mode used to determine master mode
;;;362        //               bit clock rate
;;;363        // D2     = 0  : Don't Care
;;;364        // D1     = 0  : Don't Care
;;;365        // D0     = 0  : Re-Sync is done without soft-muting the channel. (ADC/DAC)
;;;366        // ----------------------
;;;367        // D[7:0] = 00000000
;;;368        //
;;;369        DACWriteRegister(TI_ASDI_CTL_B_R, 0x00);
0000b6  2100              MOVS     r1,#0
0000b8  2009              MOVS     r0,#9
0000ba  f7fffffe          BL       DACWriteRegister
;;;370    
;;;371        //
;;;372        // Audio Serial Data Interface Control Register C
;;;373        // ----------------------
;;;374        // D[7:0] = 00000000 : Data offset = 0 bit clocks
;;;375        // ----------------------
;;;376        // D[7:0] = 00000000
;;;377        //
;;;378        DACWriteRegister(TI_ASDI_CTL_C_R, 0x00);
0000be  2100              MOVS     r1,#0
0000c0  200a              MOVS     r0,#0xa
0000c2  f7fffffe          BL       DACWriteRegister
;;;379    
;;;380        //
;;;381        // DAC Power and Output Driver Control Register
;;;382        // ----------------------
;;;383        // D7     = 1  : Left DAC is powered up
;;;384        // D6     = 1  : Right DAC is powered up
;;;385        // D[5:4] = 00 : HPCOM configured as differential of HPLOUT
;;;386        // D[3:0] = 0  : reserved
;;;387        // ----------------------
;;;388        // D[7:0] = 11000000
;;;389        //
;;;390        DACWriteRegister(TI_DACPOD_CTL_R, 0xC0);
0000c6  21c0              MOVS     r1,#0xc0
0000c8  2025              MOVS     r0,#0x25
0000ca  f7fffffe          BL       DACWriteRegister
;;;391    
;;;392        //
;;;393        // Left DAC Digital Volume Control Register
;;;394        // ----------------------
;;;395        // D7     = 0  : The left DAC channel is not muted
;;;396        // D[6:0] = 0  :
;;;397        // ----------------------
;;;398        // D[7:0] =
;;;399        //
;;;400        DACWriteRegister(TI_LEFT_DAC_DIG_VOL_CTL_R, 0x00);
0000ce  2100              MOVS     r1,#0
0000d0  202b              MOVS     r0,#0x2b
0000d2  f7fffffe          BL       DACWriteRegister
;;;401    
;;;402        //
;;;403        // Right DAC Digital Volume Control Register
;;;404        // ----------------------
;;;405        // D7     = 0  : The right DAC channel is not muted
;;;406        // D[6:0] = 0  :
;;;407        // ----------------------
;;;408        // D[7:0] =
;;;409        //
;;;410        DACWriteRegister(TI_RIGHT_DAC_DIG_VOL_CTL_R, 0x00);
0000d6  2100              MOVS     r1,#0
0000d8  202c              MOVS     r0,#0x2c
0000da  f7fffffe          BL       DACWriteRegister
;;;411    
;;;412        //
;;;413        // DAC_L1 to LEFT_LOP Volume Control Register
;;;414        // ----------------------
;;;415        // D7     = 1  : DAC_L1 is routed to LEFT_LOP
;;;416        // D[6:0] = 0110010 (50)  : Gain
;;;417        // ----------------------
;;;418        // D[7:0] = 10110010
;;;419        //
;;;420        DACWriteRegister(TI_DAC_L1_LEFT_LOP_VOL_CTL_R, 0xA0);
0000de  21a0              MOVS     r1,#0xa0
0000e0  2052              MOVS     r0,#0x52
0000e2  f7fffffe          BL       DACWriteRegister
;;;421    
;;;422        //
;;;423        // LEFT_LOP Output Level Control Register
;;;424        // ----------------------
;;;425        // D[7:4] = 0110  : Output level control = 6 dB
;;;426        // D3     = 1     :    LEFT_LOP is not muted
;;;427        // D2     = 0     :    Reserved.
;;;428        // D1     = 0     :    All programmed gains to LEFT_LOP have been applied
;;;429        // D0     = 1     :    LEFT_LOP is fully powered up
;;;430        // ----------------------
;;;431        // D[7:0] = 00001001
;;;432        //
;;;433        DACWriteRegister(TI_LEFT_LOP_OUTPUT_LVL_CTL_R, 0xC9);
0000e6  21c9              MOVS     r1,#0xc9
0000e8  2056              MOVS     r0,#0x56
0000ea  f7fffffe          BL       DACWriteRegister
;;;434    
;;;435        //
;;;436        // From the TLV320AIC3107 datasheet:
;;;437        // The following initialization sequence must be written to the AIC3107
;;;438        // registers prior to enabling the class-D amplifier:
;;;439        // register data:
;;;440        // 1. 0x00 0x0D
;;;441        // 2. 0x0D 0x0D
;;;442        // 3. 0x08 0x5C
;;;443        // 4. 0x08 0x5D
;;;444        // 5. 0x08 0x5C
;;;445        // 6. 0x00 0x00
;;;446        //
;;;447        DACWriteRegister(0x00, 0x0D);
0000ee  210d              MOVS     r1,#0xd
0000f0  2000              MOVS     r0,#0
0000f2  f7fffffe          BL       DACWriteRegister
;;;448        DACWriteRegister(0x0D, 0x0D);
0000f6  210d              MOVS     r1,#0xd
0000f8  4608              MOV      r0,r1
0000fa  f7fffffe          BL       DACWriteRegister
;;;449        DACWriteRegister(0x08, 0x5C);
0000fe  215c              MOVS     r1,#0x5c
000100  2008              MOVS     r0,#8
000102  f7fffffe          BL       DACWriteRegister
;;;450        DACWriteRegister(0x08, 0x5D);
000106  215d              MOVS     r1,#0x5d
000108  2008              MOVS     r0,#8
00010a  f7fffffe          BL       DACWriteRegister
;;;451        DACWriteRegister(0x08, 0x5C);
00010e  215c              MOVS     r1,#0x5c
000110  2008              MOVS     r0,#8
000112  f7fffffe          BL       DACWriteRegister
;;;452        DACWriteRegister(0x00, 0x00);
000116  2100              MOVS     r1,#0
000118  4608              MOV      r0,r1
00011a  f7fffffe          BL       DACWriteRegister
;;;453    
;;;454        //
;;;455        // Class-D and Bypass Switch Control Register
;;;456        // ----------------------
;;;457        // D[7:6] = 01 : Left Class-D amplifier gain = 6.0 dB
;;;458        // D[5:4] = 00 : Right Class-D amplifier gain = 0.0 dB
;;;459        // D3     = 1  : enable left class-D channel
;;;460        // D2     = 0  : disable right class-D channel
;;;461        // D1     = 0  : disable bypass switch
;;;462        // D0     = 0  : disable bypass switch bootstrap clock
;;;463        // ----------------------
;;;464        // D[7:0] = 01001000
;;;465        //
;;;466        DACWriteRegister(TI_CLASSD_BYPASS_SWITCH_CTL_R, 0x40);
00011e  2140              MOVS     r1,#0x40
000120  2049              MOVS     r0,#0x49
000122  f7fffffe          BL       DACWriteRegister
;;;467    
;;;468        //
;;;469        //Read Module Power Status Register
;;;470        //
;;;471        bRetcode = DACReadRegister(TI_MODULE_PWR_STAT_R, &ucTest);
000126  4669              MOV      r1,sp
000128  205e              MOVS     r0,#0x5e
00012a  f7fffffe          BL       DACReadRegister
;;;472        if(!bRetcode)
00012e  2800              CMP      r0,#0
000130  d000              BEQ      |L3.308|
;;;473        {
;;;474            return(bRetcode);
;;;475        }
;;;476    
;;;477        return(true);
000132  2001              MOVS     r0,#1
                  |L3.308|
;;;478    }
000134  bdf8              POP      {r3-r7,pc}
;;;479    
                          ENDP

000136  0000              DCW      0x0000
                  |L3.312|
                          DCD      0x20000002
                  |L3.316|
                          DCD      0x40005000
                  |L3.320|
                          DCD      0x00010801
                  |L3.324|
                          DCD      0x00010c01
                  |L3.328|
                          DCD      0x40020000

                          AREA ||i.DACReadRegister||, CODE, READONLY, ALIGN=2

                  DACReadRegister PROC
;;;162    static tBoolean
;;;163    DACReadRegister(unsigned char ucRegister, unsigned char *pucData)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;164    {
;;;165        //
;;;166        // Set the slave address and "WRITE"
;;;167        //
;;;168        ROM_I2CMasterSlaveAddrSet(DAC_I2C_MASTER_BASE, TI_TLV320AIC3107_ADDR,
000004  f04f7580          MOV      r5,#0x1000000
000008  4607              MOV      r7,r0                 ;164
00000a  69e8              LDR      r0,[r5,#0x1c]
00000c  4c2b              LDR      r4,|L4.188|
00000e  460e              MOV      r6,r1                 ;164
000010  2200              MOVS     r2,#0
000012  6bc3              LDR      r3,[r0,#0x3c]
000014  2118              MOVS     r1,#0x18
000016  4620              MOV      r0,r4
000018  4798              BLX      r3
;;;169                                  false);
;;;170    
;;;171        //
;;;172        // Write the first byte to the controller (register)
;;;173        //
;;;174        ROM_I2CMasterDataPut(DAC_I2C_MASTER_BASE, ucRegister);
00001a  69e8              LDR      r0,[r5,#0x1c]
00001c  4639              MOV      r1,r7
00001e  6802              LDR      r2,[r0,#0]
000020  4620              MOV      r0,r4
000022  4790              BLX      r2
;;;175    
;;;176        //
;;;177        // Continue the transfer.
;;;178        //
;;;179        ROM_I2CMasterControl(DAC_I2C_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_START);
000024  69e8              LDR      r0,[r5,#0x1c]
000026  2103              MOVS     r1,#3
000028  6c82              LDR      r2,[r0,#0x48]
00002a  4620              MOV      r0,r4
00002c  4790              BLX      r2
                  |L4.46|
;;;180    
;;;181        //
;;;182        // Wait until the current byte has been transferred.
;;;183        //
;;;184        while(ROM_I2CMasterIntStatus(DAC_I2C_MASTER_BASE, false) == 0)
00002e  69e8              LDR      r0,[r5,#0x1c]
000030  2100              MOVS     r1,#0
000032  6ac2              LDR      r2,[r0,#0x2c]
000034  4620              MOV      r0,r4
000036  4790              BLX      r2
000038  2800              CMP      r0,#0
00003a  d0f8              BEQ      |L4.46|
;;;185        {
;;;186        }
;;;187    
;;;188        if(ROM_I2CMasterErr(DAC_I2C_MASTER_BASE) != I2C_MASTER_ERR_NONE)
00003c  69e8              LDR      r0,[r5,#0x1c]
00003e  6cc1              LDR      r1,[r0,#0x4c]
000040  4620              MOV      r0,r4
000042  4788              BLX      r1
000044  bb08              CBNZ     r0,|L4.138|
000046  e002              B        |L4.78|
                  |L4.72|
;;;189        {
;;;190            ROM_I2CMasterIntClear(DAC_I2C_MASTER_BASE);
;;;191            return(false);
;;;192        }
;;;193    
;;;194        //
;;;195        // Wait until the current byte has been transferred.
;;;196        //
;;;197        while(ROM_I2CMasterIntStatus(DAC_I2C_MASTER_BASE, false))
;;;198        {
;;;199            ROM_I2CMasterIntClear(DAC_I2C_MASTER_BASE);
000048  6b41              LDR      r1,[r0,#0x34]
00004a  4620              MOV      r0,r4
00004c  4788              BLX      r1
                  |L4.78|
00004e  69e8              LDR      r0,[r5,#0x1c]         ;197
000050  2100              MOVS     r1,#0                 ;197
000052  6ac2              LDR      r2,[r0,#0x2c]         ;197
000054  4620              MOV      r0,r4                 ;197
000056  4790              BLX      r2                    ;197
000058  2800              CMP      r0,#0                 ;197
00005a  69e8              LDR      r0,[r5,#0x1c]         ;197
00005c  d1f4              BNE      |L4.72|
;;;200        }
;;;201    
;;;202        //
;;;203        // Set the slave address and "READ"/true.
;;;204        //
;;;205        ROM_I2CMasterSlaveAddrSet(DAC_I2C_MASTER_BASE, TI_TLV320AIC3107_ADDR, true);
00005e  2201              MOVS     r2,#1
000060  6bc3              LDR      r3,[r0,#0x3c]
000062  2118              MOVS     r1,#0x18
000064  4620              MOV      r0,r4
000066  4798              BLX      r3
;;;206    
;;;207        //
;;;208        // Read Data Byte.
;;;209        //
;;;210        ROM_I2CMasterControl(DAC_I2C_MASTER_BASE, I2C_MASTER_CMD_SINGLE_RECEIVE);
000068  69e8              LDR      r0,[r5,#0x1c]
00006a  2107              MOVS     r1,#7
00006c  6c82              LDR      r2,[r0,#0x48]
00006e  4620              MOV      r0,r4
000070  4790              BLX      r2
                  |L4.114|
;;;211    
;;;212        //
;;;213        // Wait until the current byte has been transferred.
;;;214        //
;;;215        while(ROM_I2CMasterIntStatus(DAC_I2C_MASTER_BASE, false) == 0)
000072  69e8              LDR      r0,[r5,#0x1c]
000074  2100              MOVS     r1,#0
000076  6ac2              LDR      r2,[r0,#0x2c]
000078  4620              MOV      r0,r4
00007a  4790              BLX      r2
00007c  2800              CMP      r0,#0
00007e  d0f8              BEQ      |L4.114|
;;;216        {
;;;217        }
;;;218    
;;;219        if(ROM_I2CMasterErr(DAC_I2C_MASTER_BASE) != I2C_MASTER_ERR_NONE)
000080  69e8              LDR      r0,[r5,#0x1c]
000082  6cc1              LDR      r1,[r0,#0x4c]
000084  4620              MOV      r0,r4
000086  4788              BLX      r1
000088  b148              CBZ      r0,|L4.158|
                  |L4.138|
;;;220        {
;;;221            ROM_I2CMasterIntClear(DAC_I2C_MASTER_BASE);
00008a  69e8              LDR      r0,[r5,#0x1c]
00008c  6b41              LDR      r1,[r0,#0x34]
00008e  4620              MOV      r0,r4
000090  4788              BLX      r1
;;;222            return(false);
000092  2000              MOVS     r0,#0
                  |L4.148|
;;;223        }
;;;224    
;;;225        //
;;;226        // Wait until the current byte has been transferred.
;;;227        //
;;;228        while(ROM_I2CMasterIntStatus(DAC_I2C_MASTER_BASE, false))
;;;229        {
;;;230            ROM_I2CMasterIntClear(DAC_I2C_MASTER_BASE);
;;;231        }
;;;232    
;;;233        //
;;;234        // Read the value received.
;;;235        //
;;;236        *pucData  = ROM_I2CMasterDataGet(DAC_I2C_MASTER_BASE);
;;;237    
;;;238        return(true);
;;;239    }
000094  e8bd81f0          POP      {r4-r8,pc}
                  |L4.152|
000098  6b41              LDR      r1,[r0,#0x34]         ;230
00009a  4620              MOV      r0,r4                 ;230
00009c  4788              BLX      r1                    ;230
                  |L4.158|
00009e  69e8              LDR      r0,[r5,#0x1c]         ;228
0000a0  2100              MOVS     r1,#0                 ;228
0000a2  6ac2              LDR      r2,[r0,#0x2c]         ;228
0000a4  4620              MOV      r0,r4                 ;228
0000a6  4790              BLX      r2                    ;228
0000a8  2800              CMP      r0,#0                 ;228
0000aa  69e8              LDR      r0,[r5,#0x1c]         ;228
0000ac  d1f4              BNE      |L4.152|
0000ae  6d01              LDR      r1,[r0,#0x50]         ;236
0000b0  4620              MOV      r0,r4                 ;236
0000b2  4788              BLX      r1                    ;236
0000b4  7030              STRB     r0,[r6,#0]            ;236
0000b6  2001              MOVS     r0,#1                 ;238
0000b8  e7ec              B        |L4.148|
;;;240    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L4.188|
                          DCD      0x40020000

                          AREA ||i.DACVolumeGet||, CODE, READONLY, ALIGN=2

                  DACVolumeGet PROC
;;;548    unsigned long
;;;549    DACVolumeGet(void)
000000  4801              LDR      r0,|L5.8|
;;;550    {
;;;551        return(g_ucHPVolume);
000002  7800              LDRB     r0,[r0,#0]  ; g_ucHPVolume
;;;552    }
000004  4770              BX       lr
;;;553    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.DACVolumeSet||, CODE, READONLY, ALIGN=2

                  DACVolumeSet PROC
;;;493    void
;;;494    DACVolumeSet(unsigned long ulVolume)
000000  4a09              LDR      r2,|L6.40|
;;;495    {
;;;496        //
;;;497        // Make sure we have been passed a valid volume value.
;;;498        //
;;;499        ASSERT(ulVolume <= 100);
;;;500    
;;;501        //
;;;502        // Update our local copy of the volume.
;;;503        //
;;;504        g_ucHPVolume = (unsigned char)ulVolume;
000002  b2c1              UXTB     r1,r0
;;;505    
;;;506        //
;;;507        // Cap the volume at 100%
;;;508        //
;;;509        if(g_ucHPVolume >= 100)
;;;510        {
;;;511            g_ucHPVolume = 100;
000004  2364              MOVS     r3,#0x64
000006  7011              STRB     r1,[r2,#0]            ;504
000008  2964              CMP      r1,#0x64              ;509
00000a  d300              BCC      |L6.14|
00000c  7013              STRB     r3,[r2,#0]
                  |L6.14|
;;;512        }
;;;513    
;;;514        //
;;;515        // Invert the % value.  This is because the max volume is at 0x00 and
;;;516        // minimum volume is at 0x7F.
;;;517        //
;;;518        ulVolume = 100 - ulVolume;
00000e  f1c00064          RSB      r0,r0,#0x64
;;;519    
;;;520        //
;;;521        //Find what % of (0x7F) to set in the register.
;;;522        //
;;;523        ulVolume = (0x7F * ulVolume) / 100;
000012  ebc010c0          RSB      r0,r0,r0,LSL #7
000016  fbb0f0f3          UDIV     r0,r0,r3
;;;524    
;;;525        //
;;;526        // DAC_L1 to LEFT_LOP Volume Control Register
;;;527        // ----------------------
;;;528        // D7     = 1  : DAC_L1 is routed to LEFT_LOP
;;;529        // D[6:0] =    : Gain
;;;530        // ----------------------
;;;531        // D[7:0] = 1XXXXXXX
;;;532        //
;;;533        DACWriteRegister(TI_DAC_L1_LEFT_LOP_VOL_CTL_R,
00001a  b2c0              UXTB     r0,r0
00001c  f0400180          ORR      r1,r0,#0x80
000020  2052              MOVS     r0,#0x52
000022  f7ffbffe          B.W      DACWriteRegister
;;;534                         (0x80 | (unsigned char)ulVolume));
;;;535    }
;;;536    
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      ||.data||

                          AREA ||i.DACWriteRegister||, CODE, READONLY, ALIGN=2

                  DACWriteRegister PROC
;;;82     static tBoolean
;;;83     DACWriteRegister(unsigned char ucRegister, unsigned long ulData)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     {
;;;85         //
;;;86         // Set the slave address.
;;;87         //
;;;88         ROM_I2CMasterSlaveAddrSet(DAC_I2C_MASTER_BASE, TI_TLV320AIC3107_ADDR,
000004  f04f7480          MOV      r4,#0x1000000
000008  4607              MOV      r7,r0                 ;84
00000a  69e0              LDR      r0,[r4,#0x1c]
00000c  4d28              LDR      r5,|L7.176|
00000e  460e              MOV      r6,r1                 ;84
000010  2200              MOVS     r2,#0
000012  6bc3              LDR      r3,[r0,#0x3c]
000014  2118              MOVS     r1,#0x18
000016  4628              MOV      r0,r5
000018  4798              BLX      r3
;;;89                                   false);
;;;90     
;;;91         //
;;;92         // Write the first byte to the controller (register)
;;;93         //
;;;94         ROM_I2CMasterDataPut(DAC_I2C_MASTER_BASE, ucRegister);
00001a  69e0              LDR      r0,[r4,#0x1c]
00001c  4639              MOV      r1,r7
00001e  6802              LDR      r2,[r0,#0]
000020  4628              MOV      r0,r5
000022  4790              BLX      r2
;;;95     
;;;96         //
;;;97         // Continue the transfer.
;;;98         //
;;;99         ROM_I2CMasterControl(DAC_I2C_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_START);
000024  69e0              LDR      r0,[r4,#0x1c]
000026  2103              MOVS     r1,#3
000028  6c82              LDR      r2,[r0,#0x48]
00002a  4628              MOV      r0,r5
00002c  4790              BLX      r2
                  |L7.46|
;;;100    
;;;101        //
;;;102        // Wait until the current byte has been transferred.
;;;103        //
;;;104        while(ROM_I2CMasterIntStatus(DAC_I2C_MASTER_BASE, false) == 0)
00002e  69e0              LDR      r0,[r4,#0x1c]
000030  2100              MOVS     r1,#0
000032  6ac2              LDR      r2,[r0,#0x2c]
000034  4628              MOV      r0,r5
000036  4790              BLX      r2
000038  2800              CMP      r0,#0
00003a  d0f8              BEQ      |L7.46|
;;;105        {
;;;106        }
;;;107    
;;;108        if(ROM_I2CMasterErr(DAC_I2C_MASTER_BASE) != I2C_MASTER_ERR_NONE)
00003c  69e0              LDR      r0,[r4,#0x1c]
00003e  6cc1              LDR      r1,[r0,#0x4c]
000040  4628              MOV      r0,r5
000042  4788              BLX      r1
000044  b138              CBZ      r0,|L7.86|
;;;109        {
;;;110            ROM_I2CMasterIntClear(DAC_I2C_MASTER_BASE);
000046  69e0              LDR      r0,[r4,#0x1c]
000048  6b41              LDR      r1,[r0,#0x34]
00004a  4628              MOV      r0,r5
00004c  4788              BLX      r1
;;;111            return(false);
00004e  e01f              B        |L7.144|
                  |L7.80|
;;;112        }
;;;113    
;;;114        //
;;;115        // Wait until the current byte has been transferred.
;;;116        //
;;;117        while(ROM_I2CMasterIntStatus(DAC_I2C_MASTER_BASE, false))
;;;118        {
;;;119            ROM_I2CMasterIntClear(DAC_I2C_MASTER_BASE);
000050  6b41              LDR      r1,[r0,#0x34]
000052  4628              MOV      r0,r5
000054  4788              BLX      r1
                  |L7.86|
000056  69e0              LDR      r0,[r4,#0x1c]         ;117
000058  2100              MOVS     r1,#0                 ;117
00005a  6ac2              LDR      r2,[r0,#0x2c]         ;117
00005c  4628              MOV      r0,r5                 ;117
00005e  4790              BLX      r2                    ;117
000060  2800              CMP      r0,#0                 ;117
000062  69e0              LDR      r0,[r4,#0x1c]         ;117
000064  d1f4              BNE      |L7.80|
;;;120        }
;;;121    
;;;122        //
;;;123        // Write the data byte to the controller.
;;;124        //
;;;125        ROM_I2CMasterDataPut(DAC_I2C_MASTER_BASE, ulData);
000066  6802              LDR      r2,[r0,#0]
000068  b2f1              UXTB     r1,r6
00006a  4628              MOV      r0,r5
00006c  4790              BLX      r2
;;;126    
;;;127        //
;;;128        // End the transfer.
;;;129        //
;;;130        ROM_I2CMasterControl(DAC_I2C_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_FINISH);
00006e  69e0              LDR      r0,[r4,#0x1c]
000070  2105              MOVS     r1,#5
000072  6c82              LDR      r2,[r0,#0x48]
000074  4628              MOV      r0,r5
000076  4790              BLX      r2
                  |L7.120|
;;;131    
;;;132        //
;;;133        // Wait until the current byte has been transferred.
;;;134        //
;;;135        while(ROM_I2CMasterIntStatus(DAC_I2C_MASTER_BASE, false) == 0)
000078  69e0              LDR      r0,[r4,#0x1c]
00007a  2100              MOVS     r1,#0
00007c  6ac2              LDR      r2,[r0,#0x2c]
00007e  4628              MOV      r0,r5
000080  4790              BLX      r2
000082  2800              CMP      r0,#0
000084  d0f8              BEQ      |L7.120|
;;;136        {
;;;137        }
;;;138    
;;;139        if(ROM_I2CMasterErr(DAC_I2C_MASTER_BASE) != I2C_MASTER_ERR_NONE)
000086  69e0              LDR      r0,[r4,#0x1c]
000088  6cc1              LDR      r1,[r0,#0x4c]
00008a  4628              MOV      r0,r5
00008c  4788              BLX      r1
00008e  b130              CBZ      r0,|L7.158|
                  |L7.144|
;;;140        {
;;;141            return(false);
000090  2000              MOVS     r0,#0
                  |L7.146|
;;;142        }
;;;143    
;;;144        while(ROM_I2CMasterIntStatus(DAC_I2C_MASTER_BASE, false))
;;;145        {
;;;146            ROM_I2CMasterIntClear(DAC_I2C_MASTER_BASE);
;;;147        }
;;;148    
;;;149        return(true);
;;;150    }
000092  e8bd81f0          POP      {r4-r8,pc}
                  |L7.150|
000096  69e0              LDR      r0,[r4,#0x1c]         ;146
000098  6b41              LDR      r1,[r0,#0x34]         ;146
00009a  4628              MOV      r0,r5                 ;146
00009c  4788              BLX      r1                    ;146
                  |L7.158|
00009e  69e0              LDR      r0,[r4,#0x1c]         ;144
0000a0  2100              MOVS     r1,#0                 ;144
0000a2  6ac2              LDR      r2,[r0,#0x2c]         ;144
0000a4  4628              MOV      r0,r5                 ;144
0000a6  4790              BLX      r2                    ;144
0000a8  2800              CMP      r0,#0                 ;144
0000aa  d1f4              BNE      |L7.150|
0000ac  2001              MOVS     r0,#1                 ;149
0000ae  e7f0              B        |L7.146|
;;;151    
                          ENDP

                  |L7.176|
                          DCD      0x40020000

                          AREA ||.data||, DATA, ALIGN=0

                  g_ucHPVolume
000000  64                DCB      0x64
