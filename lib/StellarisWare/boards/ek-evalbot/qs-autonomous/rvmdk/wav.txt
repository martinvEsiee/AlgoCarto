; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\wav.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\wav.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\wav.crf ..\drivers\wav.c]
                          THUMB

                          AREA ||i.BufferCallback||, CODE, READONLY, ALIGN=2

                  BufferCallback PROC
;;;107    static void
;;;108    BufferCallback(void *pvBuffer, unsigned long ulEvent)
000000  07c9              LSLS     r1,r1,#31
;;;109    {
;;;110        //
;;;111        // Handle buffer-free event
;;;112        //
;;;113        if(ulEvent & BUFFER_EVENT_FREE)
000002  d00e              BEQ      |L1.34|
;;;114        {
;;;115            //
;;;116            // If pointing at the start of the buffer, then this is the first
;;;117            // half, so mark it as free.
;;;118            //
;;;119            if(pvBuffer == g_pucBuffer)
000004  4a07              LDR      r2,|L1.36|
;;;120            {
;;;121                g_ulFlags |= BUFFER_BOTTOM_EMPTY;
000006  4908              LDR      r1,|L1.40|
000008  4290              CMP      r0,r2                 ;119
;;;122            }
;;;123    
;;;124            //
;;;125            // Otherwise it must be the second half of the buffer that is free.
;;;126            //
;;;127            else
;;;128            {
;;;129                g_ulFlags |= BUFFER_TOP_EMPTY;
00000a  68c8              LDR      r0,[r1,#0xc]  ; g_ulFlags
00000c  d102              BNE      |L1.20|
00000e  f0400001          ORR      r0,r0,#1              ;121
000012  e001              B        |L1.24|
                  |L1.20|
000014  f0400002          ORR      r0,r0,#2
                  |L1.24|
000018  60c8              STR      r0,[r1,#0xc]  ; g_ulFlags
;;;130            }
;;;131    
;;;132            //
;;;133            // Update the byte count.
;;;134            //
;;;135            g_ulBytesPlayed += AUDIO_BUFFER_SIZE >> 1;
00001a  6908              LDR      r0,[r1,#0x10]  ; g_ulBytesPlayed
00001c  f5006000          ADD      r0,r0,#0x800
000020  6108              STR      r0,[r1,#0x10]  ; g_ulBytesPlayed
                  |L1.34|
;;;136        }
;;;137    }
000022  4770              BX       lr
;;;138    
                          ENDP

                  |L1.36|
                          DCD      ||.bss||
                  |L1.40|
                          DCD      ||.data||

                          AREA ||i.WaveGetTime||, CODE, READONLY, ALIGN=2

                  WaveGetTime PROC
;;;587    void
;;;588    WaveGetTime(tWaveHeader *pWaveHeader, char *pcTime, unsigned long ulSize)
000000  b53e              PUSH     {r1-r5,lr}
;;;589    {
000002  4615              MOV      r5,r2
000004  4603              MOV      r3,r0
;;;590        unsigned long ulSeconds;
;;;591        unsigned long ulMinutes;
;;;592    
;;;593        //
;;;594        // Calculate the integer number of minutes and seconds.
;;;595        //
;;;596        ulSeconds = g_ulBytesPlayed / pWaveHeader->ulAvgByteRate;
000006  4a0c              LDR      r2,|L2.56|
000008  4608              MOV      r0,r1                 ;589
00000a  6859              LDR      r1,[r3,#4]
00000c  6913              LDR      r3,[r2,#0x10]  ; g_ulBytesPlayed
00000e  fbb3f1f1          UDIV     r1,r3,r1
;;;597        ulMinutes = ulSeconds / 60;
000012  233c              MOVS     r3,#0x3c
000014  fbb1f3f3          UDIV     r3,r1,r3
;;;598        ulSeconds -= ulMinutes * 60;
000018  eba31403          SUB      r4,r3,r3,LSL #4
00001c  eb010184          ADD      r1,r1,r4,LSL #2
;;;599    
;;;600        //
;;;601        // If for some reason the seconds go over, clip to the right size.
;;;602        //
;;;603        if(ulSeconds > g_usSeconds)
000020  8854              LDRH     r4,[r2,#2]  ; g_usSeconds
000022  42a1              CMP      r1,r4
000024  d900              BLS      |L2.40|
000026  4621              MOV      r1,r4
                  |L2.40|
;;;604        {
;;;605            ulSeconds = g_usSeconds;
;;;606        }
;;;607    
;;;608        //
;;;609        // Print the time string in the format mm.ss/mm.ss
;;;610        //
;;;611        usnprintf((char *)pcTime, ulSize, "%d:%02d/%d:%02d", ulMinutes,
000028  8812              LDRH     r2,[r2,#0]  ; g_usMinutes
00002a  e88d0016          STM      sp,{r1,r2,r4}
00002e  a203              ADR      r2,|L2.60|
000030  4629              MOV      r1,r5
000032  f7fffffe          BL       usnprintf
;;;612                  ulSeconds, g_usMinutes, g_usSeconds);
;;;613    }
000036  bd3e              POP      {r1-r5,pc}
;;;614    
                          ENDP

                  |L2.56|
                          DCD      ||.data||
                  |L2.60|
00003c  25643a25          DCB      "%d:%02d/%d:%02d",0
000040  3032642f
000044  25643a25
000048  30326400

                          AREA ||i.WaveOpen||, CODE, READONLY, ALIGN=2

                  WaveOpen PROC
;;;188    tWaveReturnCode
;;;189    WaveOpen(unsigned long *pulAddress, tWaveHeader *pWaveHeader)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;190    {
;;;191        unsigned long *pulBuffer;
;;;192        unsigned short *pusBuffer;
;;;193        unsigned long ulChunkSize;
;;;194        unsigned long ulBytesPerSample;
;;;195    
;;;196        //
;;;197        // Get a pointer to the RIFF tag.
;;;198        //
;;;199        pulBuffer = (unsigned long *)pulAddress;
;;;200    
;;;201        //
;;;202        // Check for valid RIFF.
;;;203        //
;;;204        if((pulBuffer[0] != RIFF_CHUNK_ID_RIFF) || (pulBuffer[2] != RIFF_TAG_WAVE))
000004  4b2d              LDR      r3,|L3.188|
000006  6802              LDR      r2,[r0,#0]
000008  429a              CMP      r2,r3
00000a  d103              BNE      |L3.20|
00000c  4b2c              LDR      r3,|L3.192|
00000e  6882              LDR      r2,[r0,#8]
000010  429a              CMP      r2,r3
000012  d002              BEQ      |L3.26|
                  |L3.20|
;;;205        {
;;;206            return(WAVE_INVALID_RIFF);
000014  2001              MOVS     r0,#1
                  |L3.22|
;;;207        }
;;;208    
;;;209        //
;;;210        // Check for valid chunk.
;;;211        //
;;;212        if(pulBuffer[3] != RIFF_CHUNK_ID_FMT)
;;;213        {
;;;214            return(WAVE_INVALID_CHUNK);
;;;215        }
;;;216    
;;;217        //
;;;218        // Read the chunk size and verify it is okay.
;;;219        //
;;;220        ulChunkSize = pulBuffer[4];
;;;221        if(ulChunkSize > 16)
;;;222        {
;;;223            return(WAVE_INVALID_CHUNK);
;;;224        }
;;;225    
;;;226        //
;;;227        // Read the next chunk header.
;;;228        //
;;;229        pulBuffer = (unsigned long *)&pulAddress[5];
;;;230        pusBuffer = (unsigned short *)pulBuffer;
;;;231    
;;;232        //
;;;233        // Populate the caller-supplied header structure with the wav format
;;;234        // information.
;;;235        //
;;;236        pWaveHeader->usFormat = pusBuffer[0];
;;;237        pWaveHeader->usNumChannels =  pusBuffer[1];
;;;238        pWaveHeader->ulSampleRate = pulBuffer[1];
;;;239        pWaveHeader->ulAvgByteRate = pulBuffer[2];
;;;240        pWaveHeader->usBitsPerSample = pusBuffer[7];
;;;241    
;;;242        //
;;;243        // Reset the byte count.
;;;244        //
;;;245        g_ulBytesPlayed = 0;
;;;246    
;;;247        //
;;;248        // Calculate the Maximum buffer size based on format.  There can only be
;;;249        // 1024 samples per ping-pong buffer due to uDMA.
;;;250        //
;;;251        ulBytesPerSample = (pWaveHeader->usBitsPerSample *
;;;252                            pWaveHeader->usNumChannels) >> 3;
;;;253    
;;;254        //
;;;255        // Cap the maximum buffer size used to be the smaller of 1024 samples,
;;;256        // which is the limit of the uDMA controller, or the size of the
;;;257        // audio buffer.
;;;258        //
;;;259        if(((AUDIO_BUFFER_SIZE >> 1) / ulBytesPerSample) > 1024)
;;;260        {
;;;261            g_ulMaxBufferSize = 1024 * ulBytesPerSample;
;;;262        }
;;;263        else
;;;264        {
;;;265            g_ulMaxBufferSize = AUDIO_BUFFER_SIZE >> 1;
;;;266        }
;;;267    
;;;268        //
;;;269        // Only mono and stereo supported.
;;;270        //
;;;271        if(pWaveHeader->usNumChannels > 2)
;;;272        {
;;;273            return(WAVE_INVALID_FORMAT);
;;;274        }
;;;275    
;;;276        //
;;;277        // Read the next chunk header.
;;;278        //
;;;279        pulBuffer = (unsigned long *)&pulAddress[5] + (ulChunkSize / 4);
;;;280        if(pulBuffer[0] != RIFF_CHUNK_ID_DATA)
;;;281        {
;;;282            return(WAVE_INVALID_CHUNK);
;;;283        }
;;;284    
;;;285        //
;;;286        // Save the size of the data.
;;;287        //
;;;288        pWaveHeader->ulDataSize = pulBuffer[1];
;;;289    
;;;290        //
;;;291        // Calculate the duration of the clip
;;;292        //
;;;293        g_usSeconds = pWaveHeader->ulDataSize / pWaveHeader->ulAvgByteRate;
;;;294        g_usMinutes = g_usSeconds / 60;
;;;295        g_usSeconds -= g_usMinutes * 60;
;;;296    
;;;297        //
;;;298        // Set the data pointer to the start of the data
;;;299        //
;;;300        g_pucDataPtr = (unsigned char *)&pulBuffer[2];
;;;301    
;;;302        //
;;;303        // Set the number of data bytes in the file.
;;;304        //
;;;305        g_ulBytesRemaining = pWaveHeader->ulDataSize;
;;;306    
;;;307        //
;;;308        // Adjust the average bit rate for 8 bit mono files.
;;;309        //
;;;310        if((pWaveHeader->usNumChannels == 1) && (pWaveHeader->usBitsPerSample == 8))
;;;311        {
;;;312            pWaveHeader->ulAvgByteRate <<=1;
;;;313        }
;;;314    
;;;315        //
;;;316        // Set the format of the playback in the sound driver.
;;;317        //
;;;318        SoundSetFormat(pWaveHeader->ulSampleRate, pWaveHeader->usBitsPerSample,
;;;319                       pWaveHeader->usNumChannels);
;;;320    
;;;321        //
;;;322        // Made it to here ... return success.
;;;323        //
;;;324        return(WAVE_OK);
;;;325    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L3.26|
00001a  4b2a              LDR      r3,|L3.196|
00001c  68c2              LDR      r2,[r0,#0xc]          ;212
00001e  429a              CMP      r2,r3                 ;212
000020  d12c              BNE      |L3.124|
000022  6904              LDR      r4,[r0,#0x10]         ;221
000024  2c10              CMP      r4,#0x10              ;221
000026  d829              BHI      |L3.124|
000028  8a82              LDRH     r2,[r0,#0x14]         ;236
00002a  81ca              STRH     r2,[r1,#0xe]          ;236
00002c  8ac2              LDRH     r2,[r0,#0x16]         ;237
00002e  820a              STRH     r2,[r1,#0x10]         ;237
000030  6985              LDR      r5,[r0,#0x18]         ;238
000032  600d              STR      r5,[r1,#0]            ;239
000034  f8d0c01c          LDR      r12,[r0,#0x1c]        ;239
000038  f8c1c004          STR      r12,[r1,#4]           ;240
00003c  4e22              LDR      r6,|L3.200|
00003e  46a9              MOV      r9,r5                 ;238
000040  8c43              LDRH     r3,[r0,#0x22]         ;240
000042  818b              STRH     r3,[r1,#0xc]          ;240
000044  2500              MOVS     r5,#0                 ;245
000046  6135              STR      r5,[r6,#0x10]         ;251  ; g_ulBytesPlayed
000048  fb03f502          MUL      r5,r3,r2              ;251
00004c  10ed              ASRS     r5,r5,#3              ;251
00004e  f44f6700          MOV      r7,#0x800             ;259
000052  fbb7f8f5          UDIV     r8,r7,r5              ;259
000056  f5b86f80          CMP      r8,#0x400             ;259
00005a  d902              BLS      |L3.98|
00005c  02ad              LSLS     r5,r5,#10             ;261
00005e  60b5              STR      r5,[r6,#8]            ;261  ; g_ulMaxBufferSize
000060  e000              B        |L3.100|
                  |L3.98|
000062  60b7              STR      r7,[r6,#8]            ;265  ; g_ulMaxBufferSize
                  |L3.100|
000064  2a02              CMP      r2,#2                 ;271
000066  d901              BLS      |L3.108|
000068  2003              MOVS     r0,#3                 ;273
00006a  e7d4              B        |L3.22|
                  |L3.108|
00006c  f0240403          BIC      r4,r4,#3              ;279
000070  4420              ADD      r0,r0,r4              ;279
000072  4d16              LDR      r5,|L3.204|
000074  f8504f14          LDR      r4,[r0,#0x14]!        ;280
000078  42ac              CMP      r4,r5                 ;280
00007a  d001              BEQ      |L3.128|
                  |L3.124|
00007c  2002              MOVS     r0,#2                 ;282
00007e  e7ca              B        |L3.22|
                  |L3.128|
000080  6844              LDR      r4,[r0,#4]            ;288
000082  273c              MOVS     r7,#0x3c              ;294
000084  fbb4f5fc          UDIV     r5,r4,r12             ;293
000088  b2ad              UXTH     r5,r5                 ;293
00008a  fbb5f7f7          UDIV     r7,r5,r7              ;294
00008e  608c              STR      r4,[r1,#8]            ;294
000090  8037              STRH     r7,[r6,#0]            ;294
000092  eba71707          SUB      r7,r7,r7,LSL #4       ;295
000096  eb050587          ADD      r5,r5,r7,LSL #2       ;295
00009a  8075              STRH     r5,[r6,#2]            ;295
00009c  3008              ADDS     r0,r0,#8              ;300
00009e  6174              STR      r4,[r6,#0x14]         ;310  ; g_ulBytesRemaining
0000a0  6070              STR      r0,[r6,#4]            ;310  ; g_pucDataPtr
0000a2  2a01              CMP      r2,#1                 ;310
0000a4  d104              BNE      |L3.176|
0000a6  2b08              CMP      r3,#8                 ;310
0000a8  d102              BNE      |L3.176|
0000aa  ea4f004c          LSL      r0,r12,#1             ;312
0000ae  6048              STR      r0,[r1,#4]            ;312
                  |L3.176|
0000b0  4619              MOV      r1,r3                 ;312
0000b2  4648              MOV      r0,r9                 ;312
0000b4  f7fffffe          BL       SoundSetFormat
0000b8  2000              MOVS     r0,#0                 ;324
0000ba  e7ac              B        |L3.22|
;;;326    
                          ENDP

                  |L3.188|
                          DCD      0x46464952
                  |L3.192|
                          DCD      0x45564157
                  |L3.196|
                          DCD      0x20746d66
                  |L3.200|
                          DCD      ||.data||
                  |L3.204|
                          DCD      0x61746164

                          AREA ||i.WavePlayContinue||, CODE, READONLY, ALIGN=2

                  WavePlayContinue PROC
;;;472    tBoolean
;;;473    WavePlayContinue(tWaveHeader *pWaveHeader)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;474    {
;;;475        tBoolean bRetcode;
;;;476        unsigned long ulCount;
;;;477    
;;;478        //
;;;479        // Assume we're not finished until we learn otherwise.
;;;480        //
;;;481        bRetcode = false;
;;;482    
;;;483        //
;;;484        // Set a value that we can use to tell whether or not we processed any
;;;485        // new data.
;;;486        //
;;;487        ulCount = 0xFFFFFFFF;
;;;488    
;;;489        //
;;;490        // Must disable I2S interrupts during this time to prevent state problems.
;;;491        //
;;;492        ROM_IntDisable(INT_I2S0);
000004  f04f7580          MOV      r5,#0x1000000
000008  4681              MOV      r9,r0                 ;474
00000a  6ca8              LDR      r0,[r5,#0x48]
00000c  2700              MOVS     r7,#0                 ;481
00000e  1e7e              SUBS     r6,r7,#1              ;487
000010  68c1              LDR      r1,[r0,#0xc]
000012  2044              MOVS     r0,#0x44
000014  4788              BLX      r1
;;;493    
;;;494        //
;;;495        // If the refill flag gets cleared then fill the requested side of the
;;;496        // buffer.
;;;497        //
;;;498        if(g_ulFlags & BUFFER_BOTTOM_EMPTY)
000016  4c1d              LDR      r4,|L4.140|
000018  68e0              LDR      r0,[r4,#0xc]  ; g_ulFlags
00001a  07c0              LSLS     r0,r0,#31
00001c  d00d              BEQ      |L4.58|
;;;499        {
;;;500            //
;;;501            // Read out the next buffer worth of data.
;;;502            //
;;;503            ulCount = WaveRead(pWaveHeader, g_pucBuffer);
00001e  491c              LDR      r1,|L4.144|
000020  4648              MOV      r0,r9
000022  f7fffffe          BL       WaveRead
000026  4606              MOV      r6,r0
;;;504    
;;;505            //
;;;506            // Start the playback for a new buffer.
;;;507            //
;;;508            SoundBufferPlay(g_pucBuffer, ulCount, BufferCallback);
000028  4601              MOV      r1,r0
00002a  4a1a              LDR      r2,|L4.148|
00002c  4818              LDR      r0,|L4.144|
00002e  f7fffffe          BL       SoundBufferPlay
;;;509    
;;;510            //
;;;511            // Bottom half of the buffer is now not empty.
;;;512            //
;;;513            g_ulFlags &= ~BUFFER_BOTTOM_EMPTY;
000032  68e0              LDR      r0,[r4,#0xc]  ; g_ulFlags
000034  f0200001          BIC      r0,r0,#1
000038  60e0              STR      r0,[r4,#0xc]  ; g_ulFlags
                  |L4.58|
;;;514        }
;;;515    
;;;516        if(g_ulFlags & BUFFER_TOP_EMPTY)
00003a  68e0              LDR      r0,[r4,#0xc]  ; g_ulFlags
00003c  0780              LSLS     r0,r0,#30
00003e  d50e              BPL      |L4.94|
;;;517        {
;;;518            //
;;;519            // Read out the next buffer worth of data.
;;;520            //
;;;521            ulCount = WaveRead(pWaveHeader, &g_pucBuffer[AUDIO_BUFFER_SIZE >> 1]);
000040  4915              LDR      r1,|L4.152|
000042  4648              MOV      r0,r9
000044  4688              MOV      r8,r1
000046  f7fffffe          BL       WaveRead
00004a  4606              MOV      r6,r0
;;;522    
;;;523            //
;;;524            // Start the playback for a new buffer.
;;;525            //
;;;526            SoundBufferPlay(&g_pucBuffer[AUDIO_BUFFER_SIZE >> 1],
00004c  4601              MOV      r1,r0
00004e  4a11              LDR      r2,|L4.148|
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       SoundBufferPlay
;;;527                            ulCount, BufferCallback);
;;;528    
;;;529            //
;;;530            // Top half of the buffer is now not empty.
;;;531            //
;;;532            g_ulFlags &= ~BUFFER_TOP_EMPTY;
000056  68e0              LDR      r0,[r4,#0xc]  ; g_ulFlags
000058  f0200002          BIC      r0,r0,#2
00005c  60e0              STR      r0,[r4,#0xc]  ; g_ulFlags
                  |L4.94|
;;;533        }
;;;534    
;;;535        //
;;;536        // Audio playback is done once the count is below a full buffer.
;;;537        //
;;;538        if((ulCount < g_ulMaxBufferSize) || (g_ulBytesRemaining == 0))
00005e  68a0              LDR      r0,[r4,#8]  ; g_ulMaxBufferSize
000060  4286              CMP      r6,r0
000062  d301              BCC      |L4.104|
000064  6960              LDR      r0,[r4,#0x14]  ; g_ulBytesRemaining
000066  b948              CBNZ     r0,|L4.124|
                  |L4.104|
;;;539        {
;;;540            //
;;;541            // No longer playing audio.
;;;542            //
;;;543            g_ulFlags &= ~BUFFER_PLAYING;
000068  68e0              LDR      r0,[r4,#0xc]  ; g_ulFlags
00006a  f0200004          BIC      r0,r0,#4
00006e  60e0              STR      r0,[r4,#0xc]  ; g_ulFlags
                  |L4.112|
;;;544    
;;;545            //
;;;546            // Wait for the buffer to empty.
;;;547            //
;;;548            while(g_ulFlags != (BUFFER_TOP_EMPTY | BUFFER_BOTTOM_EMPTY))
000070  68e0              LDR      r0,[r4,#0xc]  ; g_ulFlags
000072  2803              CMP      r0,#3
000074  d1fc              BNE      |L4.112|
;;;549            {
;;;550            }
;;;551    
;;;552            //
;;;553            // Disable the Class D amp to save power.
;;;554            //
;;;555            SoundClassDDis();
000076  f7fffffe          BL       SoundClassDDis
;;;556            bRetcode = true;
00007a  2701              MOVS     r7,#1
                  |L4.124|
;;;557        }
;;;558    
;;;559        //
;;;560        // Reenable the I2S interrupt now that we're finished mucking with
;;;561        // state and flags.
;;;562        //
;;;563        ROM_IntEnable(INT_I2S0);
00007c  6ca8              LDR      r0,[r5,#0x48]
00007e  6801              LDR      r1,[r0,#0]
000080  2044              MOVS     r0,#0x44
000082  4788              BLX      r1
;;;564    
;;;565        return(bRetcode);
000084  4638              MOV      r0,r7
;;;566    }
000086  e8bd87f0          POP      {r4-r10,pc}
;;;567    
                          ENDP

00008a  0000              DCW      0x0000
                  |L4.140|
                          DCD      ||.data||
                  |L4.144|
                          DCD      ||.bss||
                  |L4.148|
                          DCD      BufferCallback
                  |L4.152|
                          DCD      ||.bss||+0x800

                          AREA ||i.WavePlayStart||, CODE, READONLY, ALIGN=2

                  WavePlayStart PROC
;;;437    void
;;;438    WavePlayStart(tWaveHeader *pWaveHeader)
000000  4804              LDR      r0,|L5.20|
;;;439    {
;;;440        //
;;;441        // Mark both buffers as empty.
;;;442        //
;;;443        g_ulFlags = BUFFER_BOTTOM_EMPTY | BUFFER_TOP_EMPTY;
000002  2103              MOVS     r1,#3
000004  60c1              STR      r1,[r0,#0xc]  ; g_ulFlags
;;;444    
;;;445        //
;;;446        // Indicate that the application is about to start playing.
;;;447        //
;;;448        g_ulFlags |= BUFFER_PLAYING;
000006  68c1              LDR      r1,[r0,#0xc]  ; g_ulFlags
000008  f0410104          ORR      r1,r1,#4
00000c  60c1              STR      r1,[r0,#0xc]  ; g_ulFlags
;;;449    
;;;450        //
;;;451        // Enable the Class D amp.  It's turned off when idle to save power.
;;;452        //
;;;453        SoundClassDEn();
00000e  f7ffbffe          B.W      SoundClassDEn
;;;454    }
;;;455    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      ||.data||

                          AREA ||i.WavePlaybackStatus||, CODE, READONLY, ALIGN=2

                  WavePlaybackStatus PROC
;;;626    tBoolean
;;;627    WavePlaybackStatus(void)
000000  4802              LDR      r0,|L6.12|
;;;628    {
;;;629        return((g_ulFlags & BUFFER_PLAYING) ? true : false);
000002  68c0              LDR      r0,[r0,#0xc]  ; g_ulFlags
000004  f3c00080          UBFX     r0,r0,#2,#1
;;;630    }
000008  4770              BX       lr
;;;631    
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      ||.data||

                          AREA ||i.WaveRead||, CODE, READONLY, ALIGN=2

                  WaveRead PROC
;;;365    static unsigned long
;;;366    WaveRead(tWaveHeader *pWaveHeader, unsigned char *pucBuffer)
000000  b5f0              PUSH     {r4-r7,lr}
;;;367    {
;;;368        int i;
;;;369        unsigned long ulBytesToRead;
;;;370    
;;;371        //
;;;372        // Either read a half buffer or just the bytes remaining if we are at the
;;;373        // end of the file.
;;;374        //
;;;375        if(g_ulBytesRemaining < g_ulMaxBufferSize)
000002  4e10              LDR      r6,|L7.68|
000004  4607              MOV      r7,r0                 ;367
000006  6975              LDR      r5,[r6,#0x14]  ; g_ulBytesRemaining
000008  68b0              LDR      r0,[r6,#8]  ; g_ulMaxBufferSize
00000a  4285              CMP      r5,r0
00000c  d200              BCS      |L7.16|
00000e  4628              MOV      r0,r5
                  |L7.16|
000010  4b0c              LDR      r3,|L7.68|
;;;376        {
;;;377            ulBytesToRead = g_ulBytesRemaining;
;;;378        }
;;;379        else
;;;380        {
;;;381            ulBytesToRead = g_ulMaxBufferSize;
;;;382        }
;;;383    
;;;384        //
;;;385        // Copy data from the playing audio clip to the caller-supplied buffer.
;;;386        // This buffer will be in SRAM which is required in case the data needs
;;;387        // 8-bit sign conversion, and also so that the buffer can be handled by
;;;388        // uDMA.
;;;389        //
;;;390        for(i = 0; i < ulBytesToRead; i++)
000012  2200              MOVS     r2,#0
;;;391        {
;;;392            pucBuffer[i] = g_pucDataPtr[i];
000014  685b              LDR      r3,[r3,#4]
000016  e002              B        |L7.30|
                  |L7.24|
000018  5c9c              LDRB     r4,[r3,r2]
00001a  548c              STRB     r4,[r1,r2]
00001c  1c52              ADDS     r2,r2,#1              ;390
                  |L7.30|
00001e  4282              CMP      r2,r0                 ;390
000020  d3fa              BCC      |L7.24|
;;;393        }
;;;394    
;;;395        //
;;;396        // Decrement the number of data bytes remaining to be read.
;;;397        //
;;;398        g_ulBytesRemaining -= ulBytesToRead;
000022  1a2a              SUBS     r2,r5,r0
;;;399    
;;;400        //
;;;401        // Update the global data pointer keeping track of the location in flash.
;;;402        //
;;;403        g_pucDataPtr += ulBytesToRead;
000024  6172              STR      r2,[r6,#0x14]  ; g_ulBytesRemaining
000026  181a              ADDS     r2,r3,r0
;;;404    
;;;405        //
;;;406        // Need to convert the audio from unsigned to signed if 8 bit
;;;407        // audio is used.
;;;408        //
;;;409        if(pWaveHeader->usBitsPerSample == 8)
000028  6072              STR      r2,[r6,#4]  ; g_pucDataPtr
00002a  89ba              LDRH     r2,[r7,#0xc]
00002c  2a08              CMP      r2,#8
00002e  d108              BNE      |L7.66|
000030  2200              MOVS     r2,#0
000032  e004              B        |L7.62|
                  |L7.52|
000034  780b              LDRB     r3,[r1,#0]
000036  3b80              SUBS     r3,r3,#0x80
000038  f8013b01          STRB     r3,[r1],#1
00003c  1c52              ADDS     r2,r2,#1
                  |L7.62|
00003e  4282              CMP      r2,r0
000040  d3f8              BCC      |L7.52|
                  |L7.66|
;;;410        {
;;;411            WaveConvert8Bit(pucBuffer, ulBytesToRead);
;;;412        }
;;;413    
;;;414        //
;;;415        // Return the number of bytes that were read from the audio clip into
;;;416        // the buffer.
;;;417        //
;;;418        return(ulBytesToRead);
;;;419    }
000042  bdf0              POP      {r4-r7,pc}
;;;420    
                          ENDP

                  |L7.68|
                          DCD      ||.data||

                          AREA ||i.WaveStop||, CODE, READONLY, ALIGN=2

                  WaveStop PROC
;;;340    void
;;;341    WaveStop(void)
000000  4802              LDR      r0,|L8.12|
;;;342    {
;;;343        //
;;;344        // Clear the flag that indicates audio is playing.
;;;345        //
;;;346        g_ulFlags &= ~BUFFER_PLAYING;
000002  68c1              LDR      r1,[r0,#0xc]  ; g_ulFlags
000004  f0210104          BIC      r1,r1,#4
000008  60c1              STR      r1,[r0,#0xc]  ; g_ulFlags
;;;347    }
00000a  4770              BX       lr
;;;348    
                          ENDP

                  |L8.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_pucBuffer
                          %        4096

                          AREA ||.data||, DATA, ALIGN=2

                  g_usMinutes
000000  0000              DCB      0x00,0x00
                  g_usSeconds
000002  0000              DCB      0x00,0x00
                  g_pucDataPtr
                          DCD      0x00000000
                  g_ulMaxBufferSize
                          DCD      0x00000000
                  g_ulFlags
                          DCD      0x00000000
                  g_ulBytesPlayed
                          DCD      0x00000000
                  g_ulBytesRemaining
                          DCD      0x00000000
