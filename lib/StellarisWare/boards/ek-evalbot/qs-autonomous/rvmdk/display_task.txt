; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\display_task.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\display_task.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\display_task.crf display_task.c]
                          THUMB

                          AREA ||i.DisplayTask||, CODE, READONLY, ALIGN=2

                  DisplayTask PROC
;;;294    void
;;;295    DisplayTask(void *pvParam)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;296    {
;;;297        static unsigned long ulState = 2; //TG il etait a 0
;;;298        static unsigned long ulLastTick = 0;
;;;299        static unsigned long ulTimeout = 0;
;;;300    
;;;301        //
;;;302        // Check to see if the timeout has expired and it is time to change the
;;;303        // display.
;;;304        //
;;;305        if(SchedulerElapsedTicksGet(ulLastTick) > ulTimeout)
000004  4c20              LDR      r4,|L1.136|
000006  68e0              LDR      r0,[r4,#0xc]  ; ulLastTick
000008  f7fffffe          BL       SchedulerElapsedTicksGet
00000c  6921              LDR      r1,[r4,#0x10]  ; ulTimeout
00000e  4288              CMP      r0,r1
000010  d91e              BLS      |L1.80|
;;;306        {
;;;307            //
;;;308            // Save the current tick value to use for comparison next time through
;;;309            //
;;;310            ulLastTick = SchedulerTickCountGet();
000012  f7fffffe          BL       SchedulerTickCountGet
;;;311    
;;;312            //
;;;313            // Switch based on the display task state
;;;314            //
;;;315            switch(ulState)
000016  60e0              STR      r0,[r4,#0xc]  ; ulLastTick
000018  68a0              LDR      r0,[r4,#8]  ; ulState
00001a  2600              MOVS     r6,#0
;;;316            {
;;;317                //
;;;318                // In this state, the scrolling TI logo is initialized, and the
;;;319                // state changed to next state.  A short timeout is used so that
;;;320                // the scrolling image will start next time through this task.
;;;321                //
;;;322                case 0:
;;;323                {
;;;324                    ScrollImage(g_pucTILogo, sizeof(g_pucTILogo) / 2);
;;;325                    ulTimeout = 1;
;;;326                    ulState = 1;
;;;327                    break;
;;;328                }
;;;329    
;;;330                //
;;;331                // In this state the TI logo is scrolled across the screen with
;;;332                // a scroll rate of this task period (each time this task is
;;;333                // called by the scheduler it advances the scroll by one pixel
;;;334                // column).
;;;335                //
;;;336                case 1:
;;;337                {
;;;338                    if(ScrollImage(g_pucTILogo, 0))
;;;339                    {
;;;340                        //
;;;341                        // If the scrolling is done, then advance the state and
;;;342                        // set the timeout for 1.3 seconds (next state will start
;;;343                        // in 1.3 seconds).
;;;344                        //
;;;345                        ulTimeout = 130;
00001c  2582              MOVS     r5,#0x82
;;;346                        ulState = 2;
;;;347                    }
;;;348                    break;
;;;349                }
;;;350    
;;;351                //
;;;352                // This state shows the text "STELLARIS" on the display for 5.3
;;;353                // seconds.
;;;354                //
;;;355                case 2:
;;;356                {
;;;357                    Display96x16x1StringDraw("FLORIAN", 21, 0);
;;;358                    ulTimeout = 530;
00001e  f2402712          MOV      r7,#0x212
000022  2806              CMP      r0,#6                 ;315
000024  d22d              BCS      |L1.130|
000026  e8dff000          TBB      [pc,r0]               ;315
00002a  030a              DCB      0x03,0x0a
00002c  151d222a          DCB      0x15,0x1d,0x22,0x2a
000030  2100              MOVS     r1,#0                 ;324
000032  4816              LDR      r0,|L1.140|
000034  f7fffffe          BL       ScrollImage
000038  2001              MOVS     r0,#1                 ;325
00003a  6120              STR      r0,[r4,#0x10]         ;327  ; ulTimeout
00003c  e007              B        |L1.78|
00003e  2100              MOVS     r1,#0                 ;338
000040  4812              LDR      r0,|L1.140|
000042  f7fffffe          BL       ScrollImage
000046  2800              CMP      r0,#0                 ;338
000048  d002              BEQ      |L1.80|
00004a  2002              MOVS     r0,#2                 ;346
00004c  6125              STR      r5,[r4,#0x10]         ;346  ; ulTimeout
                  |L1.78|
00004e  60a0              STR      r0,[r4,#8]            ;346  ; ulState
                  |L1.80|
;;;359                    ulState = 3;
;;;360                    break;
;;;361                }
;;;362    
;;;363                //
;;;364                // This state clears the screen for 1.3 seconds.
;;;365                //
;;;366                case 3:
;;;367                {
;;;368                    Display96x16x1Clear();
;;;369                    ulTimeout = 130;
;;;370                    ulState = 4;
;;;371                    break;
;;;372                }
;;;373    
;;;374                //
;;;375                // This state shows "EVALBOT" for 5.3 seconds.
;;;376                //
;;;377                case 4:
;;;378                {
;;;379                    Display96x16x1StringDraw("EVALBOT", 27, 0);
;;;380                    ulTimeout = 530;
;;;381                    ulState = 5;
;;;382                    break;
;;;383                }
;;;384    
;;;385                //
;;;386                // This state clears the screen for 1.3 seconds.
;;;387                //
;;;388                case 5:
;;;389                {
;;;390                    Display96x16x1Clear();
;;;391                    ulTimeout = 130;
;;;392                    ulState = 0;
;;;393                    break;
;;;394                }
;;;395    
;;;396                //
;;;397                // The default state should not occur, but if it does, then reset
;;;398                // back to the beginning state.
;;;399                //
;;;400                default:
;;;401                {
;;;402                    ulTimeout = 130;
;;;403                    ulState = 0;
;;;404                    break;
;;;405                }
;;;406            }
;;;407        }
;;;408    }
000050  e8bd81f0          POP      {r4-r8,pc}
000054  2200              MOVS     r2,#0                 ;357
000056  2115              MOVS     r1,#0x15              ;357
000058  a00d              ADR      r0,|L1.144|
00005a  f7fffffe          BL       Display96x16x1StringDraw
00005e  2003              MOVS     r0,#3                 ;359
000060  6127              STR      r7,[r4,#0x10]         ;360  ; ulTimeout
000062  e7f4              B        |L1.78|
000064  f7fffffe          BL       Display96x16x1Clear
000068  2004              MOVS     r0,#4                 ;370
00006a  6125              STR      r5,[r4,#0x10]         ;371  ; ulTimeout
00006c  e7ef              B        |L1.78|
00006e  2200              MOVS     r2,#0                 ;379
000070  211b              MOVS     r1,#0x1b              ;379
000072  a009              ADR      r0,|L1.152|
000074  f7fffffe          BL       Display96x16x1StringDraw
000078  2005              MOVS     r0,#5                 ;381
00007a  6127              STR      r7,[r4,#0x10]         ;382  ; ulTimeout
00007c  e7e7              B        |L1.78|
00007e  f7fffffe          BL       Display96x16x1Clear
                  |L1.130|
000082  60a6              STR      r6,[r4,#8]            ;403  ; ulState
000084  6125              STR      r5,[r4,#0x10]         ;403  ; ulTimeout
000086  e7e3              B        |L1.80|
;;;409    
                          ENDP

                  |L1.136|
                          DCD      ||.data||
                  |L1.140|
                          DCD      ||.constdata||
                  |L1.144|
000090  464c4f52          DCB      "FLORIAN",0
000094  49414e00
                  |L1.152|
000098  4556414c          DCB      "EVALBOT",0
00009c  424f5400

                          AREA ||i.DisplayTaskInit||, CODE, READONLY, ALIGN=1

                  DisplayTaskInit PROC
;;;416    void
;;;417    DisplayTaskInit(void *pvParam)
000000  b510              PUSH     {r4,lr}
;;;418    {
;;;419        //
;;;420        // Initialize the display driver and turn the display on.
;;;421        //
;;;422        Display96x16x1Init(false);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       Display96x16x1Init
;;;423        Display96x16x1DisplayOn();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      Display96x16x1DisplayOn
;;;424    }
                          ENDP


                          AREA ||i.ScrollImage||, CODE, READONLY, ALIGN=2

                  ScrollImage PROC
;;;182    static unsigned long
;;;183    ScrollImage(const unsigned char *pucImage, unsigned long ulImageWidth)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;184    {
;;;185        unsigned long ulLoop;
;;;186        static unsigned long ulIdx = 0;
;;;187        static unsigned long ulWidth;
;;;188    
;;;189        //
;;;190        // If an image width is specified, then initialize the scrolling image
;;;191        // display variables.
;;;192        //
;;;193        if(ulImageWidth)
;;;194        {
;;;195            ulWidth = ulImageWidth;
000004  f8df80b8          LDR      r8,|L3.192|
000008  2200              MOVS     r2,#0                 ;184
00000a  b111              CBZ      r1,|L3.18|
;;;196            ulIdx = 0;
00000c  e9c82100          STRD     r2,r1,[r8,#0]
000010  e047              B        |L3.162|
                  |L3.18|
;;;197        }
;;;198    
;;;199        //
;;;200        // Otherwise, the ulImageWidth parameter was 0, which means to advance
;;;201        // the image across the screen by one pixel.
;;;202        //
;;;203        else
;;;204        {
;;;205            //
;;;206            // Clear the local frame buffer.
;;;207            //
;;;208            for(ulLoop = 0; ulLoop < 192; ulLoop += 4)
;;;209            {
;;;210                *(unsigned long *)(g_pucFrame + ulLoop) = 0;
000012  4d2c              LDR      r5,|L3.196|
                  |L3.20|
000014  506a              STR      r2,[r5,r1]
000016  1d09              ADDS     r1,r1,#4              ;208
000018  29c0              CMP      r1,#0xc0              ;208
00001a  d3fb              BCC      |L3.20|
00001c  4928              LDR      r1,|L3.192|
00001e  f8d82000          LDR      r2,[r8,#0]            ;195  ; ulIdx
;;;211            }
;;;212    
;;;213            //
;;;214            // See if the image has reached the left side of the display.
;;;215            //
;;;216            if(ulIdx <= 96)
000022  684b              LDR      r3,[r1,#4]
000024  2a60              CMP      r2,#0x60
000026  d80e              BHI      |L3.70|
;;;217            {
;;;218                //
;;;219                // Copy the first N columns of the image to the right side of the
;;;220                // local frame buffer.
;;;221                //
;;;222                for(ulLoop = 0; ulLoop < ulIdx; ulLoop++)
000028  2100              MOVS     r1,#0
00002a  e009              B        |L3.64|
                  |L3.44|
;;;223                {
;;;224                    g_pucFrame[ulLoop + 96 - ulIdx] = pucImage[ulLoop];
00002c  1a8c              SUBS     r4,r1,r2
00002e  442c              ADD      r4,r4,r5
000030  5c46              LDRB     r6,[r0,r1]
000032  f8846060          STRB     r6,[r4,#0x60]
;;;225                    g_pucFrame[ulLoop + 96 - ulIdx + 96] =
000036  18ce              ADDS     r6,r1,r3
000038  1c49              ADDS     r1,r1,#1              ;222
00003a  5d86              LDRB     r6,[r0,r6]
00003c  f88460c0          STRB     r6,[r4,#0xc0]
                  |L3.64|
000040  4291              CMP      r1,r2                 ;222
000042  d3f3              BCC      |L3.44|
000044  e025              B        |L3.146|
                  |L3.70|
;;;226                        pucImage[ulLoop + ulWidth];
;;;227                }
;;;228            }
;;;229    
;;;230            //
;;;231            // See if the right side of the image has reached the right side of the
;;;232            // display.
;;;233            //
;;;234            else if(ulIdx < ulWidth)
000046  429a              CMP      r2,r3
;;;235            {
;;;236                //
;;;237                // Copy 96 columns from the middle of the image to the local frame
;;;238                // buffer.
;;;239                //
;;;240                for(ulLoop = 0; ulLoop < 96; ulLoop++)
;;;241                {
;;;242                    g_pucFrame[ulLoop] = pucImage[ulLoop + ulIdx - 96];
;;;243                    g_pucFrame[ulLoop + 96] =
;;;244                        pucImage[ulLoop + ulIdx - 96 + ulWidth];
;;;245                }
;;;246            }
;;;247    
;;;248            //
;;;249            // Otherwise, the right side of the image has already reached the right
;;;250            // side of the display.
;;;251            //
;;;252            else
;;;253            {
;;;254                //
;;;255                // Copy the right N columns of the image to the left side of the
;;;256                // local frame buffer.
;;;257                //
;;;258                for(ulLoop = 0; ulLoop < (ulWidth + 96 - ulIdx); ulLoop++)
000048  f04f0100          MOV      r1,#0
00004c  d20f              BCS      |L3.110|
                  |L3.78|
00004e  188c              ADDS     r4,r1,r2              ;242
000050  1826              ADDS     r6,r4,r0              ;242
000052  441c              ADD      r4,r4,r3              ;243
000054  f8166c60          LDRB     r6,[r6,#-0x60]        ;242
000058  546e              STRB     r6,[r5,r1]            ;242
00005a  4404              ADD      r4,r4,r0              ;243
00005c  186e              ADDS     r6,r5,r1              ;243
00005e  f8144c60          LDRB     r4,[r4,#-0x60]        ;243
000062  1c49              ADDS     r1,r1,#1              ;240
000064  f8864060          STRB     r4,[r6,#0x60]         ;243
000068  2960              CMP      r1,#0x60              ;240
00006a  d3f0              BCC      |L3.78|
00006c  e011              B        |L3.146|
                  |L3.110|
00006e  1a9f              SUBS     r7,r3,r2
000070  3760              ADDS     r7,r7,#0x60
000072  e00c              B        |L3.142|
                  |L3.116|
;;;259                {
;;;260                    g_pucFrame[ulLoop] = pucImage[ulLoop + ulIdx - 96];
000074  188c              ADDS     r4,r1,r2
000076  1826              ADDS     r6,r4,r0
;;;261                    g_pucFrame[ulLoop + 96] =
000078  441c              ADD      r4,r4,r3
00007a  f8166c60          LDRB     r6,[r6,#-0x60]        ;260
00007e  546e              STRB     r6,[r5,r1]            ;260
000080  4404              ADD      r4,r4,r0
000082  186e              ADDS     r6,r5,r1
000084  f8144c60          LDRB     r4,[r4,#-0x60]
000088  f8864060          STRB     r4,[r6,#0x60]
00008c  1c49              ADDS     r1,r1,#1              ;258
                  |L3.142|
00008e  428f              CMP      r7,r1                 ;258
000090  d8f0              BHI      |L3.116|
                  |L3.146|
;;;262                        pucImage[ulLoop + ulIdx - 96 + ulWidth];
;;;263                }
;;;264            }
;;;265    
;;;266            //
;;;267            // Display the local frame buffer on the display.
;;;268            //
;;;269            Display96x16x1ImageDraw(g_pucFrame, 0, 0, 96, 2);
000092  2002              MOVS     r0,#2
000094  2200              MOVS     r2,#0
000096  9000              STR      r0,[sp,#0]
000098  2360              MOVS     r3,#0x60
00009a  4611              MOV      r1,r2
00009c  4809              LDR      r0,|L3.196|
00009e  f7fffffe          BL       Display96x16x1ImageDraw
                  |L3.162|
;;;270        }
;;;271    
;;;272        //
;;;273        // Increment the scrolling column index.
;;;274        //
;;;275        ulIdx++;
0000a2  f8d80000          LDR      r0,[r8,#0]  ; ulIdx
0000a6  1c40              ADDS     r0,r0,#1
;;;276    
;;;277        //
;;;278        // Return 1 if the image is still scrolling, 0 if done
;;;279        //
;;;280        return((ulIdx > (ulWidth + 96)) ? 1 : 0);
0000a8  f8c80000          STR      r0,[r8,#0]  ; ulIdx
0000ac  f8d81004          LDR      r1,[r8,#4]  ; ulWidth
0000b0  3160              ADDS     r1,r1,#0x60
0000b2  4288              CMP      r0,r1
0000b4  d902              BLS      |L3.188|
0000b6  2001              MOVS     r0,#1
                  |L3.184|
;;;281    }
0000b8  e8bd83f8          POP      {r3-r9,pc}
                  |L3.188|
0000bc  2000              MOVS     r0,#0                 ;280
0000be  e7fb              B        |L3.184|
;;;282    //*****************************************************************************
                          ENDP

                  |L3.192|
                          DCD      ||.data||
                  |L3.196|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_pucFrame
                          %        192

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  g_pucTILogo
000000  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=2

                  ulIdx
                          DCD      0x00000000
                  ulWidth
                          DCD      0x00000000
                  ulState
                          DCD      0x00000002
                  ulLastTick
                          DCD      0x00000000
                  ulTimeout
                          DCD      0x00000000
