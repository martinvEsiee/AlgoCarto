; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\ustdlib.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\ustdlib.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\ustdlib.crf ..\..\..\utils\ustdlib.c]
                          THUMB

                          AREA ||i.ucmptime||, CODE, READONLY, ALIGN=1

                  ucmptime PROC
;;;950    static int
;;;951    ucmptime(tTime *pTime1, tTime *pTime2)
000000  b510              PUSH     {r4,lr}
;;;952    {
;;;953        //
;;;954        // Compare each field in descending signficance to determine if
;;;955        // greater than, less than, or equal.
;;;956        //
;;;957        if(pTime1->usYear > pTime2->usYear)
000002  8803              LDRH     r3,[r0,#0]
000004  880c              LDRH     r4,[r1,#0]
;;;958        {
;;;959            return(1);
;;;960        }
;;;961        else if(pTime1->usYear < pTime2->usYear)
;;;962        {
;;;963            return(-1);
000006  f04f32ff          MOV      r2,#0xffffffff
00000a  42a3              CMP      r3,r4                 ;957
00000c  d818              BHI      |L1.64|
00000e  d31b              BCC      |L1.72|
;;;964        }
;;;965        else if(pTime1->ucMon > pTime2->ucMon)
000010  7883              LDRB     r3,[r0,#2]
000012  788c              LDRB     r4,[r1,#2]
000014  42a3              CMP      r3,r4
000016  d813              BHI      |L1.64|
;;;966        {
;;;967            return(1);
;;;968        }
;;;969        else if(pTime1->ucMon < pTime2->ucMon)
000018  d316              BCC      |L1.72|
;;;970        {
;;;971            return(-1);
;;;972        }
;;;973        else if(pTime1->ucMday > pTime2->ucMday)
00001a  78c3              LDRB     r3,[r0,#3]
00001c  78cc              LDRB     r4,[r1,#3]
00001e  42a3              CMP      r3,r4
000020  d80e              BHI      |L1.64|
;;;974        {
;;;975            return(1);
;;;976        }
;;;977        else if(pTime1->ucMday < pTime2->ucMday)
000022  d311              BCC      |L1.72|
;;;978        {
;;;979            return(-1);
;;;980        }
;;;981        else if(pTime1->ucHour > pTime2->ucHour)
000024  7943              LDRB     r3,[r0,#5]
000026  794c              LDRB     r4,[r1,#5]
000028  42a3              CMP      r3,r4
00002a  d809              BHI      |L1.64|
;;;982        {
;;;983            return(1);
;;;984        }
;;;985        else if(pTime1->ucHour < pTime2->ucHour)
00002c  d30c              BCC      |L1.72|
;;;986        {
;;;987            return(-1);
;;;988        }
;;;989        else if(pTime1->ucMin > pTime2->ucMin)
00002e  7983              LDRB     r3,[r0,#6]
000030  798c              LDRB     r4,[r1,#6]
000032  42a3              CMP      r3,r4
000034  d804              BHI      |L1.64|
;;;990        {
;;;991            return(1);
;;;992        }
;;;993        else if(pTime1->ucMin < pTime2->ucMin)
000036  d307              BCC      |L1.72|
;;;994        {
;;;995            return(-1);
;;;996        }
;;;997        else if(pTime1->ucSec > pTime2->ucSec)
000038  79c3              LDRB     r3,[r0,#7]
00003a  79cc              LDRB     r4,[r1,#7]
00003c  42a3              CMP      r3,r4
00003e  d902              BLS      |L1.70|
                  |L1.64|
;;;998        {
;;;999            return(1);
000040  f04f0001          MOV      r0,#1
;;;1000       }
;;;1001       else if(pTime1->ucSec < pTime2->ucSec)
;;;1002       {
;;;1003           return(-1);
;;;1004       }
;;;1005       else
;;;1006       {
;;;1007           //
;;;1008           // Reaching this branch of the conditional means that all of the
;;;1009           // fields are equal, and thus the two times are equal.
;;;1010           //
;;;1011           return(0);
;;;1012       }
;;;1013   }
000044  bd10              POP      {r4,pc}
                  |L1.70|
000046  d201              BCS      |L1.76|
                  |L1.72|
000048  4610              MOV      r0,r2                 ;1003
00004a  bd10              POP      {r4,pc}
                  |L1.76|
00004c  f04f0000          MOV      r0,#0                 ;1011
000050  bd10              POP      {r4,pc}
;;;1014   
                          ENDP


                          AREA ||i.ulocaltime||, CODE, READONLY, ALIGN=2

                  ulocaltime PROC
;;;858    void
;;;859    ulocaltime(unsigned long ulTime, tTime *psTime)
000000  233c              MOVS     r3,#0x3c
;;;860    {
;;;861        unsigned long ulTemp, ulMonths;
;;;862    
;;;863        //
;;;864        // Extract the number of seconds, converting time to the number of minutes.
;;;865        //
;;;866        ulTemp = ulTime / 60;
000002  fbb0f2f3          UDIV     r2,r0,r3
000006  b530              PUSH     {r4,r5,lr}            ;860
;;;867        psTime->ucSec = ulTime - (ulTemp * 60);
000008  eba21402          SUB      r4,r2,r2,LSL #4
00000c  eb000084          ADD      r0,r0,r4,LSL #2
000010  71c8              STRB     r0,[r1,#7]
;;;868        ulTime = ulTemp;
;;;869    
;;;870        //
;;;871        // Extract the number of minutes, converting time to the number of hours.
;;;872        //
;;;873        ulTemp = ulTime / 60;
000012  fbb2f0f3          UDIV     r0,r2,r3
;;;874        psTime->ucMin = ulTime - (ulTemp * 60);
000016  eba01300          SUB      r3,r0,r0,LSL #4
00001a  eb020283          ADD      r2,r2,r3,LSL #2
00001e  718a              STRB     r2,[r1,#6]
;;;875        ulTime = ulTemp;
;;;876    
;;;877        //
;;;878        // Extract the number of hours, converting time to the number of days.
;;;879        //
;;;880        ulTemp = ulTime / 24;
000020  2218              MOVS     r2,#0x18
000022  fbb0f2f2          UDIV     r2,r0,r2
;;;881        psTime->ucHour = ulTime - (ulTemp * 24);
000026  eba20382          SUB      r3,r2,r2,LSL #2
00002a  eb0000c3          ADD      r0,r0,r3,LSL #3
00002e  7148              STRB     r0,[r1,#5]
;;;882        ulTime = ulTemp;
;;;883    
;;;884        //
;;;885        // Compute the day of the week.
;;;886        //
;;;887        psTime->ucWday = (ulTime + 4) % 7;
000030  1d13              ADDS     r3,r2,#4
000032  2007              MOVS     r0,#7
000034  fbb3f4f0          UDIV     r4,r3,r0
000038  fb003014          MLS      r0,r0,r4,r3
00003c  7108              STRB     r0,[r1,#4]
;;;888    
;;;889        //
;;;890        // Compute the number of leap years that have occurred since 1968, the
;;;891        // first leap year before 1970.  For the beginning of a leap year, cut the
;;;892        // month loop below at March so that the leap day is classified as February
;;;893        // 29 followed by March 1, instead of March 1 followed by another March 1.
;;;894        //
;;;895        ulTime += 366 + 365;
00003e  f20222db          ADD      r2,r2,#0x2db
;;;896        ulTemp = ulTime / ((4 * 365) + 1);
000042  f24050b5          MOV      r0,#0x5b5
000046  fbb2f0f0          UDIV     r0,r2,r0
;;;897        if((ulTime - (ulTemp * ((4 * 365) + 1))) > (31 + 28))
00004a  4b15              LDR      r3,|L2.160|
00004c  fb032300          MLA      r3,r3,r0,r2
000050  2b3b              CMP      r3,#0x3b
000052  d902              BLS      |L2.90|
;;;898        {
;;;899            ulTemp++;
000054  1c40              ADDS     r0,r0,#1
;;;900            ulMonths = 12;
000056  230c              MOVS     r3,#0xc
000058  e000              B        |L2.92|
                  |L2.90|
;;;901        }
;;;902        else
;;;903        {
;;;904            ulMonths = 2;
00005a  2302              MOVS     r3,#2
                  |L2.92|
;;;905        }
;;;906    
;;;907        //
;;;908        // Extract the year.
;;;909        //
;;;910        psTime->usYear = ((ulTime - ulTemp) / 365) + 1968;
00005c  1a14              SUBS     r4,r2,r0
00005e  f240156d          MOV      r5,#0x16d
000062  fbb4f4f5          UDIV     r4,r4,r5
000066  f50464f6          ADD      r4,r4,#0x7b0
00006a  b2a4              UXTH     r4,r4
00006c  800c              STRH     r4,[r1,#0]
;;;911        ulTime -= ((psTime->usYear - 1968) * 365) + ulTemp;
00006e  f5a464f6          SUB      r4,r4,#0x7b0
000072  fb040005          MLA      r0,r4,r5,r0
000076  1a12              SUBS     r2,r2,r0
;;;912    
;;;913        //
;;;914        // Extract the month.
;;;915        //
;;;916        for(ulTemp = 0; ulTemp < ulMonths; ulTemp++)
000078  2000              MOVS     r0,#0
;;;917        {
;;;918            if(g_psDaysToMonth[ulTemp] > ulTime)
00007a  4c0a              LDR      r4,|L2.164|
00007c  e004              B        |L2.136|
                  |L2.126|
00007e  f9345010          LDRSH    r5,[r4,r0,LSL #1]
000082  4295              CMP      r5,r2
000084  d802              BHI      |L2.140|
000086  1c40              ADDS     r0,r0,#1              ;916
                  |L2.136|
000088  4298              CMP      r0,r3                 ;916
00008a  d3f8              BCC      |L2.126|
                  |L2.140|
;;;919            {
;;;920                break;
;;;921            }
;;;922        }
;;;923        psTime->ucMon = ulTemp - 1;
00008c  1e43              SUBS     r3,r0,#1
;;;924    
;;;925        //
;;;926        // Extract the day of the month.
;;;927        //
;;;928        psTime->ucMday = ulTime - g_psDaysToMonth[ulTemp - 1] + 1;
00008e  eb040040          ADD      r0,r4,r0,LSL #1
000092  708b              STRB     r3,[r1,#2]            ;923
000094  f8300c02          LDRH     r0,[r0,#-2]
000098  1a10              SUBS     r0,r2,r0
00009a  1c40              ADDS     r0,r0,#1
00009c  70c8              STRB     r0,[r1,#3]
;;;929    }
00009e  bd30              POP      {r4,r5,pc}
;;;930    
                          ENDP

                  |L2.160|
                          DCD      0xfffffa4b
                  |L2.164|
                          DCD      ||.constdata||+0x4

                          AREA ||i.umktime||, CODE, READONLY, ALIGN=1

                  umktime PROC
;;;1030   unsigned long
;;;1031   umktime(tTime *psTime)
000000  b57c              PUSH     {r2-r6,lr}
;;;1032   {
;;;1033       tTime sTimeGuess;
;;;1034       unsigned long ulTimeGuess = 0x80000000;
000002  f04f4500          MOV      r5,#0x80000000
000006  4606              MOV      r6,r0                 ;1032
;;;1035       unsigned long ulAdjust = 0x40000000;
000008  086c              LSRS     r4,r5,#1
;;;1036       int iSign;
;;;1037   
;;;1038       //
;;;1039       // Seed the binary search with the first guess.
;;;1040       //
;;;1041       ulocaltime(ulTimeGuess, &sTimeGuess);
;;;1042       iSign = ucmptime(psTime, &sTimeGuess);
;;;1043   
;;;1044       //
;;;1045       // While the time is not yet found, execute a binary search.
;;;1046       //
;;;1047       while(iSign && ulAdjust)
00000a  e005              B        |L3.24|
                  |L3.12|
;;;1048       {
;;;1049           //
;;;1050           // Adjust the time guess up or down depending on the result of the
;;;1051           // last compare.
;;;1052           //
;;;1053           ulTimeGuess = (iSign > 0) ? (ulTimeGuess + ulAdjust) :
00000c  2800              CMP      r0,#0
00000e  dd01              BLE      |L3.20|
000010  4425              ADD      r5,r5,r4
000012  e000              B        |L3.22|
                  |L3.20|
;;;1054                                       (ulTimeGuess - ulAdjust);
000014  1b2d              SUBS     r5,r5,r4
                  |L3.22|
;;;1055           ulAdjust /= 2;
000016  0864              LSRS     r4,r4,#1
                  |L3.24|
000018  4669              MOV      r1,sp                 ;1041
00001a  4628              MOV      r0,r5                 ;1041
00001c  f7fffffe          BL       ulocaltime
000020  4669              MOV      r1,sp                 ;1042
000022  4630              MOV      r0,r6                 ;1042
000024  f7fffffe          BL       ucmptime
000028  b118              CBZ      r0,|L3.50|
00002a  2c00              CMP      r4,#0                 ;1047
00002c  d1ee              BNE      |L3.12|
;;;1056   
;;;1057           //
;;;1058           // Compare the new time guess against the time pointed at by the
;;;1059           // function parameters.
;;;1060           //
;;;1061           ulocaltime(ulTimeGuess, &sTimeGuess);
;;;1062           iSign = ucmptime(psTime, &sTimeGuess);
;;;1063       };
;;;1064   
;;;1065       //
;;;1066       // If the above loop was exited with iSign == 0, that means that the
;;;1067       // time in seconds was found, so return that value to the caller.
;;;1068       //
;;;1069       if(iSign == 0)
;;;1070       {
;;;1071           return(ulTimeGuess);
;;;1072       }
;;;1073   
;;;1074       //
;;;1075       // Otherwise the time could not be converted so return an error.
;;;1076       //
;;;1077       else
;;;1078       {
;;;1079           return((unsigned long)-1);
00002e  1e60              SUBS     r0,r4,#1
;;;1080       }
;;;1081   }
000030  bd7c              POP      {r2-r6,pc}
                  |L3.50|
000032  4628              MOV      r0,r5                 ;1071
000034  bd7c              POP      {r2-r6,pc}
;;;1082   
                          ENDP


                          AREA ||i.urand||, CODE, READONLY, ALIGN=2

                  urand PROC
;;;1588   int
;;;1589   urand(void)
000000  4903              LDR      r1,|L4.16|
;;;1590   {
;;;1591       //
;;;1592       // Generate a new pseudo-random number with a linear congruence random
;;;1593       // number generator.  This new random number becomes the seed for the next
;;;1594       // random number.
;;;1595       //
;;;1596       g_ulRandomSeed = (g_ulRandomSeed * 1664525) + 1013904223;
000002  4a04              LDR      r2,|L4.20|
000004  6808              LDR      r0,[r1,#0]  ; g_ulRandomSeed
000006  4350              MULS     r0,r2,r0
000008  4a03              LDR      r2,|L4.24|
00000a  4410              ADD      r0,r0,r2
00000c  6008              STR      r0,[r1,#0]  ; g_ulRandomSeed
;;;1597   
;;;1598       //
;;;1599       // Return the new random number.
;;;1600       //
;;;1601       return((int)g_ulRandomSeed);
;;;1602   }
00000e  4770              BX       lr
;;;1603   
                          ENDP

                  |L4.16|
                          DCD      ||.data||
                  |L4.20|
                          DCD      0x0019660d
                  |L4.24|
                          DCD      0x3c6ef35f

                          AREA ||i.usnprintf||, CODE, READONLY, ALIGN=1

                  usnprintf PROC
;;;805    int
;;;806    usnprintf(char *pcBuf, unsigned long ulSize, const char *pcString, ...)
000000  b40f              PUSH     {r0-r3}
;;;807    {
000002  b510              PUSH     {r4,lr}
;;;808        int iRet;
;;;809        va_list vaArgP;
;;;810    
;;;811        //
;;;812        // Start the varargs processing.
;;;813        //
;;;814        va_start(vaArgP, pcString);
000004  ab05              ADD      r3,sp,#0x14
;;;815    
;;;816        //
;;;817        // Call vsnprintf to perform the conversion.
;;;818        //
;;;819        iRet = uvsnprintf(pcBuf, ulSize, pcString, vaArgP);
000006  9a04              LDR      r2,[sp,#0x10]
000008  f7fffffe          BL       uvsnprintf
;;;820    
;;;821        //
;;;822        // End the varargs processing.
;;;823        //
;;;824        va_end(vaArgP);
;;;825    
;;;826        //
;;;827        // Return the conversion count.
;;;828        //
;;;829        return(iRet);
;;;830    }
00000c  bc10              POP      {r4}
00000e  f85dfb14          LDR      pc,[sp],#0x14
;;;831    
                          ENDP


                          AREA ||i.usprintf||, CODE, READONLY, ALIGN=1

                  usprintf PROC
;;;727    int
;;;728    usprintf(char *pcBuf, const char *pcString, ...)
000000  b40f              PUSH     {r0-r3}
;;;729    {
;;;730        va_list vaArgP;
;;;731        int iRet;
;;;732    
;;;733        //
;;;734        // Start the varargs processing.
;;;735        //
;;;736        va_start(vaArgP, pcString);
;;;737    
;;;738        //
;;;739        // Call vsnprintf to perform the conversion.  Use a large number for the
;;;740        // buffer size.
;;;741        //
;;;742        iRet = uvsnprintf(pcBuf, 0xffff, pcString, vaArgP);
000002  f64f71ff          MOV      r1,#0xffff
000006  b510              PUSH     {r4,lr}               ;729
000008  ab04              ADD      r3,sp,#0x10           ;736
00000a  9a03              LDR      r2,[sp,#0xc]
00000c  f7fffffe          BL       uvsnprintf
;;;743    
;;;744        //
;;;745        // End the varargs processing.
;;;746        //
;;;747        va_end(vaArgP);
;;;748    
;;;749        //
;;;750        // Return the conversion count.
;;;751        //
;;;752        return(iRet);
;;;753    }
000010  bc10              POP      {r4}
000012  f85dfb14          LDR      pc,[sp],#0x14
;;;754    
                          ENDP


                          AREA ||i.usrand||, CODE, READONLY, ALIGN=2

                  usrand PROC
;;;1572   void
;;;1573   usrand(unsigned long ulSeed)
000000  4901              LDR      r1,|L7.8|
;;;1574   {
;;;1575       g_ulRandomSeed = ulSeed;
000002  6008              STR      r0,[r1,#0]  ; g_ulRandomSeed
;;;1576   }
000004  4770              BX       lr
;;;1577   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.ustrcasecmp||, CODE, READONLY, ALIGN=1

                  ustrcasecmp PROC
;;;1458   int
;;;1459   ustrcasecmp(const char *pcStr1, const char *pcStr2)
000000  f04f32ff          MOV      r2,#0xffffffff
;;;1460   {
;;;1461       //
;;;1462       // Just let ustrnicmp() handle this.
;;;1463       //
;;;1464       return(ustrnicmp(pcStr1, pcStr2, -1));
000004  f7ffbffe          B.W      ustrnicmp
;;;1465   }
;;;1466   
                          ENDP


                          AREA ||i.ustrcmp||, CODE, READONLY, ALIGN=1

                  ustrcmp PROC
;;;1544   int
;;;1545   ustrcmp(const char *pcStr1, const char *pcStr2)
000000  f04f32ff          MOV      r2,#0xffffffff
;;;1546   {
;;;1547       //
;;;1548       // Pass this on to ustrncmp.
;;;1549       //
;;;1550       return(ustrncmp(pcStr1, pcStr2, -1));
000004  f7ffbffe          B.W      ustrncmp
;;;1551   }
;;;1552   
                          ENDP


                          AREA ||i.ustrlen||, CODE, READONLY, ALIGN=1

                  ustrlen PROC
;;;1291   int
;;;1292   ustrlen(const char * pcStr)
000000  4601              MOV      r1,r0
;;;1293   {
;;;1294       int iLen;
;;;1295   
;;;1296       ASSERT(pcStr);
;;;1297   
;;;1298       //
;;;1299       // Initialize the length.
;;;1300       //
;;;1301       iLen = 0;
000002  2000              MOVS     r0,#0
;;;1302   
;;;1303       //
;;;1304       // Step throug the string looking for a zero character (marking its end).
;;;1305       //
;;;1306       while(pcStr[iLen])
000004  e000              B        |L10.8|
                  |L10.6|
;;;1307       {
;;;1308           //
;;;1309           // Zero not found so move on to the next character.
;;;1310           //
;;;1311           iLen++;
000006  1c40              ADDS     r0,r0,#1
                  |L10.8|
000008  5c0a              LDRB     r2,[r1,r0]            ;1306
00000a  2a00              CMP      r2,#0                 ;1306
00000c  d1fb              BNE      |L10.6|
;;;1312       }
;;;1313   
;;;1314       return(iLen);
;;;1315   }
00000e  4770              BX       lr
;;;1316   
                          ENDP


                          AREA ||i.ustrncmp||, CODE, READONLY, ALIGN=1

                  ustrncmp PROC
;;;1485   int
;;;1486   ustrncmp(const char *pcStr1, const char *pcStr2, int iCount)
000000  b510              PUSH     {r4,lr}
;;;1487   {
;;;1488       while(iCount)
;;;1489       {
;;;1490           //
;;;1491           // If we reached a NULL in both strings, they must be equal so
;;;1492           // we end the comparison and return 0
;;;1493           //
;;;1494           if(!*pcStr1 && !*pcStr2)
;;;1495           {
;;;1496               return(0);
;;;1497           }
;;;1498   
;;;1499           //
;;;1500           // Compare the two characters and, if different, return the relevant
;;;1501           // return code.
;;;1502           //
;;;1503           if(*pcStr2 < *pcStr1)
;;;1504           {
;;;1505               return(1);
;;;1506           }
;;;1507           if(*pcStr1 < *pcStr2)
;;;1508           {
;;;1509               return(-1);
;;;1510           }
;;;1511   
;;;1512           //
;;;1513           // Move on to the next character.
;;;1514           //
;;;1515           pcStr1++;
;;;1516           pcStr2++;
;;;1517           iCount--;
000002  e010              B        |L11.38|
                  |L11.4|
000004  7803              LDRB     r3,[r0,#0]            ;1494
000006  b90b              CBNZ     r3,|L11.12|
000008  780c              LDRB     r4,[r1,#0]            ;1494
00000a  b174              CBZ      r4,|L11.42|
                  |L11.12|
00000c  780c              LDRB     r4,[r1,#0]            ;1503
00000e  429c              CMP      r4,r3                 ;1503
000010  d201              BCS      |L11.22|
000012  2001              MOVS     r0,#1                 ;1505
;;;1518       }
;;;1519   
;;;1520       //
;;;1521       // If we fall out, the strings must be equal for at least the first iCount
;;;1522       // characters so return 0 to indicate this.
;;;1523       //
;;;1524       return(0);
;;;1525   
;;;1526   }
000014  bd10              POP      {r4,pc}
                  |L11.22|
000016  42a3              CMP      r3,r4                 ;1507
000018  d202              BCS      |L11.32|
00001a  f04f30ff          MOV      r0,#0xffffffff        ;1509
00001e  bd10              POP      {r4,pc}
                  |L11.32|
000020  1c40              ADDS     r0,r0,#1              ;1515
000022  1c49              ADDS     r1,r1,#1              ;1516
000024  1e52              SUBS     r2,r2,#1              ;1517
                  |L11.38|
000026  2a00              CMP      r2,#0                 ;1488
000028  d1ec              BNE      |L11.4|
                  |L11.42|
00002a  2000              MOVS     r0,#0                 ;1524
00002c  bd10              POP      {r4,pc}
;;;1527   
                          ENDP


                          AREA ||i.ustrncpy||, CODE, READONLY, ALIGN=1

                  ustrncpy PROC
;;;65     char *
;;;66     ustrncpy (char *pcDst, const char *pcSrc, int iNum)
000000  b510              PUSH     {r4,lr}
;;;67     {
;;;68         int iCount;
;;;69     
;;;70         ASSERT(pcSrc);
;;;71         ASSERT(pcDst);
;;;72     
;;;73         //
;;;74         // Start at the beginning of the source string.
;;;75         //
;;;76         iCount = 0;
000002  2300              MOVS     r3,#0
;;;77     
;;;78         //
;;;79         // Copy the source string until we run out of source characters or
;;;80         // destination space.
;;;81         //
;;;82         while(iNum && pcSrc[iCount])
000004  e002              B        |L12.12|
                  |L12.6|
;;;83         {
;;;84             pcDst[iCount] = pcSrc[iCount];
000006  54c4              STRB     r4,[r0,r3]
;;;85             iCount++;
000008  1c5b              ADDS     r3,r3,#1
;;;86             iNum--;
00000a  1e52              SUBS     r2,r2,#1
                  |L12.12|
00000c  2a00              CMP      r2,#0                 ;82
00000e  d007              BEQ      |L12.32|
000010  5ccc              LDRB     r4,[r1,r3]            ;82
000012  2c00              CMP      r4,#0                 ;82
000014  d1f7              BNE      |L12.6|
000016  2100              MOVS     r1,#0                 ;76
                  |L12.24|
;;;87         }
;;;88     
;;;89         //
;;;90         // Pad the destination if we are not yet done.
;;;91         //
;;;92         while(iNum)
;;;93         {
;;;94             pcDst[iCount++] = (char)0;
000018  54c1              STRB     r1,[r0,r3]
00001a  1c5b              ADDS     r3,r3,#1
;;;95             iNum--;
00001c  1e52              SUBS     r2,r2,#1
00001e  d1fb              BNE      |L12.24|
                  |L12.32|
;;;96         }
;;;97     
;;;98         //
;;;99         // Pass the destination pointer back to the caller.
;;;100        //
;;;101        return(pcDst);
;;;102    }
000020  bd10              POP      {r4,pc}
;;;103    
                          ENDP


                          AREA ||i.ustrnicmp||, CODE, READONLY, ALIGN=1

                  ustrnicmp PROC
;;;1391   int
;;;1392   ustrnicmp(const char *pcStr1, const char *pcStr2, int iCount)
000000  b530              PUSH     {r4,r5,lr}
;;;1393   {
;;;1394       char cL1, cL2;
;;;1395   
;;;1396       while(iCount)
;;;1397       {
;;;1398           //
;;;1399           // If we reached a NULL in both strings, they must be equal so
;;;1400           // we end the comparison and return 0
;;;1401           //
;;;1402           if(!*pcStr1 && !*pcStr2)
;;;1403           {
;;;1404               return(0);
;;;1405           }
;;;1406   
;;;1407           //
;;;1408           // Lower case the characters at the current position before we compare.
;;;1409           //
;;;1410           cL1 = (((*pcStr1 >= 'A') && (*pcStr1 <= 'Z')) ?
;;;1411                               (*pcStr1 + ('a' - 'A')) : *pcStr1);
;;;1412           cL2 = (((*pcStr2 >= 'A') && (*pcStr2 <= 'Z')) ?
;;;1413                               (*pcStr2  + ('a' - 'A')) : *pcStr2);
;;;1414           //
;;;1415           // Compare the two characters and, if different, return the relevant
;;;1416           // return code.
;;;1417           //
;;;1418           if(cL2 < cL1)
;;;1419           {
;;;1420               return(1);
;;;1421           }
;;;1422           if(cL1 < cL2)
;;;1423           {
;;;1424               return(-1);
;;;1425           }
;;;1426   
;;;1427           //
;;;1428           // Move on to the next character.
;;;1429           //
;;;1430           pcStr1++;
;;;1431           pcStr2++;
;;;1432           iCount--;
000002  e01c              B        |L13.62|
                  |L13.4|
000004  7803              LDRB     r3,[r0,#0]            ;1402
000006  b90b              CBNZ     r3,|L13.12|
000008  780c              LDRB     r4,[r1,#0]            ;1402
00000a  b1d4              CBZ      r4,|L13.66|
                  |L13.12|
00000c  f1a30441          SUB      r4,r3,#0x41           ;1410
000010  2c19              CMP      r4,#0x19              ;1410
000012  d800              BHI      |L13.22|
000014  3320              ADDS     r3,r3,#0x20           ;1411
                  |L13.22|
000016  b2dc              UXTB     r4,r3                 ;1411
000018  780b              LDRB     r3,[r1,#0]            ;1412
00001a  f1a30541          SUB      r5,r3,#0x41           ;1412
00001e  2d19              CMP      r5,#0x19              ;1412
000020  d800              BHI      |L13.36|
000022  3320              ADDS     r3,r3,#0x20           ;1413
                  |L13.36|
000024  b2db              UXTB     r3,r3                 ;1413
000026  42a3              CMP      r3,r4                 ;1418
000028  d201              BCS      |L13.46|
00002a  2001              MOVS     r0,#1                 ;1420
;;;1433       }
;;;1434   
;;;1435       //
;;;1436       // If we fall out, the strings must be equal for at least the first iCount
;;;1437       // characters so return 0 to indicate this.
;;;1438       //
;;;1439       return(0);
;;;1440   }
00002c  bd30              POP      {r4,r5,pc}
                  |L13.46|
00002e  429c              CMP      r4,r3                 ;1422
000030  d202              BCS      |L13.56|
000032  f04f30ff          MOV      r0,#0xffffffff        ;1424
000036  bd30              POP      {r4,r5,pc}
                  |L13.56|
000038  1c40              ADDS     r0,r0,#1              ;1430
00003a  1c49              ADDS     r1,r1,#1              ;1431
00003c  1e52              SUBS     r2,r2,#1              ;1432
                  |L13.62|
00003e  2a00              CMP      r2,#0                 ;1396
000040  d1e0              BNE      |L13.4|
                  |L13.66|
000042  2000              MOVS     r0,#0                 ;1439
000044  bd30              POP      {r4,r5,pc}
;;;1441   
                          ENDP


                          AREA ||i.ustrstr||, CODE, READONLY, ALIGN=1

                  ustrstr PROC
;;;1334   char *
;;;1335   ustrstr(const char *pcHaystack, const char *pcNeedle)
000000  b570              PUSH     {r4-r6,lr}
;;;1336   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1337       unsigned long ulLength;
;;;1338   
;;;1339       //
;;;1340       // Get the length of the string to be found.
;;;1341       //
;;;1342       ulLength = ustrlen(pcNeedle);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       ustrlen
00000c  4605              MOV      r5,r0
;;;1343   
;;;1344       //
;;;1345       // Loop while we have not reached the end of the string.
;;;1346       //
;;;1347       while(*pcHaystack)
00000e  e006              B        |L14.30|
                  |L14.16|
;;;1348       {
;;;1349           //
;;;1350           // Check to see if the substring appears at this position.
;;;1351           //
;;;1352           if(ustrncmp(pcNeedle, pcHaystack, ulLength) == 0)
000010  462a              MOV      r2,r5
000012  4621              MOV      r1,r4
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       ustrncmp
00001a  b120              CBZ      r0,|L14.38|
;;;1353           {
;;;1354               //
;;;1355               // It does so return the pointer.
;;;1356               //
;;;1357               return((char *)pcHaystack);
;;;1358           }
;;;1359   
;;;1360           //
;;;1361           // Move to the next position in the string being searched.
;;;1362           //
;;;1363           pcHaystack++;
00001c  1c64              ADDS     r4,r4,#1
                  |L14.30|
00001e  7820              LDRB     r0,[r4,#0]            ;1347
000020  2800              CMP      r0,#0                 ;1347
000022  d1f5              BNE      |L14.16|
;;;1364       }
;;;1365   
;;;1366       //
;;;1367       // We reached the end of the string without finding the substring so
;;;1368       // return NULL.
;;;1369       //
;;;1370       return((char *)0);
;;;1371   }
000024  bd70              POP      {r4-r6,pc}
                  |L14.38|
000026  4620              MOV      r0,r4                 ;1357
000028  bd70              POP      {r4-r6,pc}
;;;1372   
                          ENDP


                          AREA ||i.ustrtoul||, CODE, READONLY, ALIGN=1

                  ustrtoul PROC
;;;1100   unsigned long
;;;1101   ustrtoul(const char *pcStr, const char **ppcStrRet, int iBase)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1102   {
;;;1103       unsigned long ulRet, ulDigit, ulNeg, ulValid;
;;;1104       const char *pcPtr;
;;;1105   
;;;1106       //
;;;1107       // Check the arguments.
;;;1108       //
;;;1109       ASSERT(pcStr);
;;;1110       ASSERT((iBase == 0) || ((iBase > 1) && (iBase <= 16)));
;;;1111   
;;;1112       //
;;;1113       // Initially, the result is zero.
;;;1114       //
;;;1115       ulRet = 0;
000002  2400              MOVS     r4,#0
000004  4606              MOV      r6,r0                 ;1102
;;;1116       ulNeg = 0;
000006  46a4              MOV      r12,r4
;;;1117       ulValid = 0;
000008  4627              MOV      r7,r4
;;;1118   
;;;1119       //
;;;1120       // Skip past any leading white space.
;;;1121       //
;;;1122       pcPtr = pcStr;
;;;1123       while((*pcPtr == ' ') || (*pcPtr == '\t'))
00000a  e000              B        |L15.14|
                  |L15.12|
;;;1124       {
;;;1125           pcPtr++;
00000c  1c40              ADDS     r0,r0,#1
                  |L15.14|
00000e  7803              LDRB     r3,[r0,#0]            ;1123
000010  2b20              CMP      r3,#0x20              ;1123
000012  d0fb              BEQ      |L15.12|
000014  2b09              CMP      r3,#9                 ;1123
000016  d0f9              BEQ      |L15.12|
;;;1126       }
;;;1127   
;;;1128       //
;;;1129       // Take a leading + or - from the value.
;;;1130       //
;;;1131       if(*pcPtr == '-')
000018  b2dd              UXTB     r5,r3
00001a  2d2d              CMP      r5,#0x2d
00001c  d002              BEQ      |L15.36|
;;;1132       {
;;;1133           ulNeg = 1;
;;;1134           pcPtr++;
;;;1135       }
;;;1136       else if(*pcPtr == '+')
00001e  2b2b              CMP      r3,#0x2b
000020  d002              BEQ      |L15.40|
000022  e002              B        |L15.42|
                  |L15.36|
000024  f04f0c01          MOV      r12,#1                ;1133
                  |L15.40|
;;;1137       {
;;;1138           pcPtr++;
000028  1c40              ADDS     r0,r0,#1
                  |L15.42|
;;;1139       }
;;;1140   
;;;1141       //
;;;1142       // See if the radix was not specified, or is 16, and the value starts with
;;;1143       // "0x" or "0X" (to indicate a hex value).
;;;1144       //
;;;1145       if(((iBase == 0) || (iBase == 16)) && (*pcPtr == '0') &&
00002a  b10a              CBZ      r2,|L15.48|
00002c  2a10              CMP      r2,#0x10
00002e  d10f              BNE      |L15.80|
                  |L15.48|
000030  7805              LDRB     r5,[r0,#0]
000032  2d30              CMP      r5,#0x30
000034  d104              BNE      |L15.64|
;;;1146          ((pcPtr[1] == 'x') || (pcPtr[1] == 'X')))
000036  7843              LDRB     r3,[r0,#1]
000038  2b78              CMP      r3,#0x78
00003a  d003              BEQ      |L15.68|
00003c  2b58              CMP      r3,#0x58
00003e  d001              BEQ      |L15.68|
                  |L15.64|
;;;1147       {
;;;1148           //
;;;1149           // Skip the leading "0x".
;;;1150           //
;;;1151           pcPtr += 2;
;;;1152   
;;;1153           //
;;;1154           // Set the radix to 16.
;;;1155           //
;;;1156           iBase = 16;
;;;1157       }
;;;1158   
;;;1159       //
;;;1160       // See if the radix was not specified.
;;;1161       //
;;;1162       if(iBase == 0)
000040  b11a              CBZ      r2,|L15.74|
000042  e005              B        |L15.80|
                  |L15.68|
000044  1c80              ADDS     r0,r0,#2              ;1151
000046  2210              MOVS     r2,#0x10              ;1156
000048  e002              B        |L15.80|
                  |L15.74|
;;;1163       {
;;;1164           //
;;;1165           // See if the value starts with "0".
;;;1166           //
;;;1167           if(*pcPtr == '0')
00004a  2d30              CMP      r5,#0x30
00004c  d007              BEQ      |L15.94|
;;;1168           {
;;;1169               //
;;;1170               // Values that start with "0" are assumed to be radix 8.
;;;1171               //
;;;1172               iBase = 8;
;;;1173           }
;;;1174           else
;;;1175           {
;;;1176               //
;;;1177               // Otherwise, the values are assumed to be radix 10.
;;;1178               //
;;;1179               iBase = 10;
00004e  220a              MOVS     r2,#0xa
                  |L15.80|
;;;1180           }
;;;1181       }
;;;1182   
;;;1183       //
;;;1184       // Loop while there are more valid digits to consume.
;;;1185       //
;;;1186       while(1)
;;;1187       {
;;;1188           //
;;;1189           // See if this character is a number.
;;;1190           //
;;;1191           if((*pcPtr >= '0') && (*pcPtr <= '9'))
000050  7803              LDRB     r3,[r0,#0]
000052  f1a30530          SUB      r5,r3,#0x30
000056  2d09              CMP      r5,#9
000058  d803              BHI      |L15.98|
00005a  462b              MOV      r3,r5
;;;1192           {
;;;1193               //
;;;1194               // Convert the character to its integer equivalent.
;;;1195               //
;;;1196               ulDigit = *pcPtr++ - '0';
00005c  e00c              B        |L15.120|
                  |L15.94|
00005e  2208              MOVS     r2,#8                 ;1172
000060  e7f6              B        |L15.80|
                  |L15.98|
;;;1197           }
;;;1198   
;;;1199           //
;;;1200           // Otherwise, see if this character is an upper case letter.
;;;1201           //
;;;1202           else if((*pcPtr >= 'A') && (*pcPtr <= 'Z'))
000062  f1a30541          SUB      r5,r3,#0x41
000066  2d19              CMP      r5,#0x19
000068  d801              BHI      |L15.110|
;;;1203           {
;;;1204               //
;;;1205               // Convert the character to its integer equivalent.
;;;1206               //
;;;1207               ulDigit = *pcPtr++ - 'A' + 10;
00006a  3b37              SUBS     r3,r3,#0x37
00006c  e004              B        |L15.120|
                  |L15.110|
;;;1208           }
;;;1209   
;;;1210           //
;;;1211           // Otherwise, see if this character is a lower case letter.
;;;1212           //
;;;1213           else if((*pcPtr >= 'a') && (*pcPtr <= 'z'))
00006e  f1a30561          SUB      r5,r3,#0x61
000072  2d19              CMP      r5,#0x19
000074  d804              BHI      |L15.128|
;;;1214           {
;;;1215               //
;;;1216               // Convert the character to its integer equivalent.
;;;1217               //
;;;1218               ulDigit = *pcPtr++ - 'a' + 10;
000076  3b57              SUBS     r3,r3,#0x57
                  |L15.120|
000078  1c40              ADDS     r0,r0,#1
;;;1219           }
;;;1220   
;;;1221           //
;;;1222           // Otherwise, this is not a valid character.
;;;1223           //
;;;1224           else
;;;1225           {
;;;1226               //
;;;1227               // Stop converting this value.
;;;1228               //
;;;1229               break;
;;;1230           }
;;;1231   
;;;1232           //
;;;1233           // See if this digit is valid for the chosen radix.
;;;1234           //
;;;1235           if(ulDigit >= iBase)
00007a  4293              CMP      r3,r2
00007c  d303              BCC      |L15.134|
;;;1236           {
;;;1237               //
;;;1238               // Since this was not a valid digit, move the pointer back to the
;;;1239               // character that therefore should not have been consumed.
;;;1240               //
;;;1241               pcPtr--;
00007e  1e40              SUBS     r0,r0,#1
                  |L15.128|
;;;1242   
;;;1243               //
;;;1244               // Stop converting this value.
;;;1245               //
;;;1246               break;
;;;1247           }
;;;1248   
;;;1249           //
;;;1250           // Add this digit to the converted value.
;;;1251           //
;;;1252           ulRet *= iBase;
;;;1253           ulRet += ulDigit;
;;;1254   
;;;1255           //
;;;1256           // Since a digit has been added, this is now a valid result.
;;;1257           //
;;;1258           ulValid = 1;
;;;1259       }
;;;1260   
;;;1261       //
;;;1262       // Set the return string pointer to the first character not consumed.
;;;1263       //
;;;1264       if(ppcStrRet)
000080  b139              CBZ      r1,|L15.146|
;;;1265       {
;;;1266           *ppcStrRet = ulValid ? pcPtr : pcStr;
000082  b92f              CBNZ     r7,|L15.144|
000084  e003              B        |L15.142|
                  |L15.134|
000086  fb043402          MLA      r4,r4,r2,r3           ;1253
00008a  2701              MOVS     r7,#1                 ;1258
00008c  e7e0              B        |L15.80|
                  |L15.142|
00008e  4630              MOV      r0,r6
                  |L15.144|
000090  6008              STR      r0,[r1,#0]
                  |L15.146|
;;;1267       }
;;;1268   
;;;1269       //
;;;1270       // Return the converted value.
;;;1271       //
;;;1272       return(ulNeg ? (0 - ulRet) : ulRet);
000092  f1bc0f00          CMP      r12,#0
000096  d001              BEQ      |L15.156|
000098  4260              RSBS     r0,r4,#0
;;;1273   }
00009a  bdf0              POP      {r4-r7,pc}
                  |L15.156|
00009c  4620              MOV      r0,r4                 ;1272
00009e  bdf0              POP      {r4-r7,pc}
;;;1274   
                          ENDP


                          AREA ||i.uvsnprintf||, CODE, READONLY, ALIGN=2

                  uvsnprintf PROC
;;;155    int
;;;156    uvsnprintf(char *pcBuf, unsigned long ulSize, const char *pcString,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;157               va_list vaArgP)
;;;158    {
000004  4605              MOV      r5,r0
000006  4690              MOV      r8,r2
000008  469a              MOV      r10,r3
00000a  000c              MOVS     r4,r1
;;;159        unsigned long ulIdx, ulValue, ulCount, ulBase, ulNeg;
;;;160        char *pcStr, cFill;
;;;161        int iConvertCount = 0;
00000c  f04f0600          MOV      r6,#0
;;;162    
;;;163        //
;;;164        // Check the arguments.
;;;165        //
;;;166        ASSERT(pcString != 0);
;;;167        ASSERT(pcBuf != 0);
;;;168        ASSERT(ulSize != 0);
;;;169    
;;;170        //
;;;171        // Adjust buffer size limit to allow one space for null termination.
;;;172        //
;;;173        if(ulSize)
000010  d000              BEQ      |L16.20|
;;;174        {
;;;175            ulSize--;
000012  1e4c              SUBS     r4,r1,#1
                  |L16.20|
000014  e10c              B        |L16.560|
                  |L16.22|
;;;176        }
;;;177    
;;;178        //
;;;179        // Initialize the count of characters converted.
;;;180        //
;;;181        iConvertCount = 0;
;;;182    
;;;183        //
;;;184        // Loop while there are more characters in the format string.
;;;185        //
;;;186        while(*pcString)
;;;187        {
;;;188            //
;;;189            // Find the first non-% character, or the end of the string.
;;;190            //
;;;191            for(ulIdx = 0; (pcString[ulIdx] != '%') && (pcString[ulIdx] != '\0');
000016  2700              MOVS     r7,#0
000018  e000              B        |L16.28|
                  |L16.26|
;;;192                ulIdx++)
00001a  1c7f              ADDS     r7,r7,#1
                  |L16.28|
00001c  f8180007          LDRB     r0,[r8,r7]            ;191
000020  2825              CMP      r0,#0x25              ;191
000022  d001              BEQ      |L16.40|
000024  2800              CMP      r0,#0                 ;191
000026  d1f8              BNE      |L16.26|
                  |L16.40|
;;;193            {
;;;194            }
;;;195    
;;;196            //
;;;197            // Write this portion of the string to the output buffer.  If there are
;;;198            // more characters to write than there is space in the buffer, then
;;;199            // only write as much as will fit in the buffer.
;;;200            //
;;;201            if(ulIdx > ulSize)
000028  42a7              CMP      r7,r4
00002a  d907              BLS      |L16.60|
;;;202            {
;;;203                ustrncpy(pcBuf, pcString, ulSize);
00002c  4622              MOV      r2,r4
00002e  4641              MOV      r1,r8
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       ustrncpy
;;;204                pcBuf += ulSize;
000036  4425              ADD      r5,r5,r4
;;;205                ulSize = 0;
000038  2400              MOVS     r4,#0
00003a  e006              B        |L16.74|
                  |L16.60|
;;;206            }
;;;207            else
;;;208            {
;;;209                ustrncpy(pcBuf, pcString, ulIdx);
00003c  463a              MOV      r2,r7
00003e  4641              MOV      r1,r8
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       ustrncpy
;;;210                pcBuf += ulIdx;
000046  443d              ADD      r5,r5,r7
;;;211                ulSize -= ulIdx;
000048  1be4              SUBS     r4,r4,r7
                  |L16.74|
;;;212            }
;;;213    
;;;214            //
;;;215            // Update the conversion count.  This will be the number of characters
;;;216            // that should have been written, even if there was not room in the
;;;217            // buffer.
;;;218            //
;;;219            iConvertCount += ulIdx;
;;;220    
;;;221            //
;;;222            // Skip the portion of the format string that was written.
;;;223            //
;;;224            pcString += ulIdx;
00004a  44b8              ADD      r8,r8,r7
00004c  443e              ADD      r6,r6,r7              ;219
;;;225    
;;;226            //
;;;227            // See if the next character is a %.
;;;228            //
;;;229            if(*pcString == '%')
00004e  f8980000          LDRB     r0,[r8,#0]
000052  2825              CMP      r0,#0x25
000054  d1de              BNE      |L16.20|
;;;230            {
;;;231                //
;;;232                // Skip the %.
;;;233                //
;;;234                pcString++;
000056  f1080801          ADD      r8,r8,#1
;;;235    
;;;236                //
;;;237                // Set the digit count to zero, and the fill character to space
;;;238                // (that is, to the defaults).
;;;239                //
;;;240                ulCount = 0;
00005a  2700              MOVS     r7,#0
;;;241                cFill = ' ';
00005c  f04f0b20          MOV      r11,#0x20
                  |L16.96|
;;;242    
;;;243                //
;;;244                // It may be necessary to get back here to process more characters.
;;;245                // Goto's aren't pretty, but effective.  I feel extremely dirty for
;;;246                // using not one but two of the beasts.
;;;247                //
;;;248    again:
;;;249    
;;;250                //
;;;251                // Determine how to handle the next character.
;;;252                //
;;;253                switch(*pcString++)
000060  f8180b01          LDRB     r0,[r8],#1
000064  2838              CMP      r0,#0x38
000066  d031              BEQ      |L16.204|
000068  dc14              BGT      |L16.148|
00006a  2833              CMP      r0,#0x33
00006c  d02e              BEQ      |L16.204|
00006e  dc08              BGT      |L16.130|
000070  2825              CMP      r0,#0x25
000072  d074              BEQ      |L16.350|
000074  2830              CMP      r0,#0x30
000076  d029              BEQ      |L16.204|
000078  2831              CMP      r0,#0x31
00007a  d027              BEQ      |L16.204|
00007c  2832              CMP      r0,#0x32
00007e  d11b              BNE      |L16.184|
000080  e024              B        |L16.204|
                  |L16.130|
000082  2834              CMP      r0,#0x34
000084  d022              BEQ      |L16.204|
000086  2835              CMP      r0,#0x35
000088  d020              BEQ      |L16.204|
00008a  2836              CMP      r0,#0x36
00008c  d01e              BEQ      |L16.204|
00008e  2837              CMP      r0,#0x37
000090  d112              BNE      |L16.184|
000092  e01b              B        |L16.204|
                  |L16.148|
000094  2870              CMP      r0,#0x70
000096  d06d              BEQ      |L16.372|
000098  dc08              BGT      |L16.172|
00009a  2839              CMP      r0,#0x39
00009c  d016              BEQ      |L16.204|
00009e  2858              CMP      r0,#0x58
0000a0  d068              BEQ      |L16.372|
0000a2  2863              CMP      r0,#0x63
0000a4  d01e              BEQ      |L16.228|
0000a6  2864              CMP      r0,#0x64
0000a8  d106              BNE      |L16.184|
0000aa  e021              B        |L16.240|
                  |L16.172|
0000ac  2873              CMP      r0,#0x73
0000ae  d02b              BEQ      |L16.264|
0000b0  2875              CMP      r0,#0x75
0000b2  d05b              BEQ      |L16.364|
0000b4  2878              CMP      r0,#0x78
0000b6  d05d              BEQ      |L16.372|
                  |L16.184|
;;;254                {
;;;255                    //
;;;256                    // Handle the digit characters.
;;;257                    //
;;;258                    case '0':
;;;259                    case '1':
;;;260                    case '2':
;;;261                    case '3':
;;;262                    case '4':
;;;263                    case '5':
;;;264                    case '6':
;;;265                    case '7':
;;;266                    case '8':
;;;267                    case '9':
;;;268                    {
;;;269                        //
;;;270                        // If this is a zero, and it is the first digit, then the
;;;271                        // fill character is a zero instead of a space.
;;;272                        //
;;;273                        if((pcString[-1] == '0') && (ulCount == 0))
;;;274                        {
;;;275                            cFill = '0';
;;;276                        }
;;;277    
;;;278                        //
;;;279                        // Update the digit count.
;;;280                        //
;;;281                        ulCount *= 10;
;;;282                        ulCount += pcString[-1] - '0';
;;;283    
;;;284                        //
;;;285                        // Get the next character.
;;;286                        //
;;;287                        goto again;
;;;288                    }
;;;289    
;;;290                    //
;;;291                    // Handle the %c command.
;;;292                    //
;;;293                    case 'c':
;;;294                    {
;;;295                        //
;;;296                        // Get the value from the varargs.
;;;297                        //
;;;298                        ulValue = va_arg(vaArgP, unsigned long);
;;;299    
;;;300                        //
;;;301                        // Copy the character to the output buffer, if there is
;;;302                        // room.  Update the buffer size remaining.
;;;303                        //
;;;304                        if(ulSize != 0)
;;;305                        {
;;;306                            *pcBuf++ = (char)ulValue;
;;;307                            ulSize--;
;;;308                        }
;;;309    
;;;310                        //
;;;311                        // Update the conversion count.
;;;312                        //
;;;313                        iConvertCount++;
;;;314    
;;;315                        //
;;;316                        // This command has been handled.
;;;317                        //
;;;318                        break;
;;;319                    }
;;;320    
;;;321                    //
;;;322                    // Handle the %d command.
;;;323                    //
;;;324                    case 'd':
;;;325                    {
;;;326                        //
;;;327                        // Get the value from the varargs.
;;;328                        //
;;;329                        ulValue = va_arg(vaArgP, unsigned long);
;;;330    
;;;331                        //
;;;332                        // If the value is negative, make it positive and indicate
;;;333                        // that a minus sign is needed.
;;;334                        //
;;;335                        if((long)ulValue < 0)
;;;336                        {
;;;337                            //
;;;338                            // Make the value positive.
;;;339                            //
;;;340                            ulValue = -(long)ulValue;
;;;341    
;;;342                            //
;;;343                            // Indicate that the value is negative.
;;;344                            //
;;;345                            ulNeg = 1;
;;;346                        }
;;;347                        else
;;;348                        {
;;;349                            //
;;;350                            // Indicate that the value is positive so that a
;;;351                            // negative sign isn't inserted.
;;;352                            //
;;;353                            ulNeg = 0;
;;;354                        }
;;;355    
;;;356                        //
;;;357                        // Set the base to 10.
;;;358                        //
;;;359                        ulBase = 10;
;;;360    
;;;361                        //
;;;362                        // Convert the value to ASCII.
;;;363                        //
;;;364                        goto convert;
;;;365                    }
;;;366    
;;;367                    //
;;;368                    // Handle the %s command.
;;;369                    //
;;;370                    case 's':
;;;371                    {
;;;372                        //
;;;373                        // Get the string pointer from the varargs.
;;;374                        //
;;;375                        pcStr = va_arg(vaArgP, char *);
;;;376    
;;;377                        //
;;;378                        // Determine the length of the string.
;;;379                        //
;;;380                        for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
;;;381                        {
;;;382                        }
;;;383    
;;;384                        //
;;;385                        // Update the convert count to include any padding that
;;;386                        // should be necessary (regardless of whether we have space
;;;387                        // to write it or not).
;;;388                        //
;;;389                        if(ulCount > ulIdx)
;;;390                        {
;;;391                            iConvertCount += (ulCount - ulIdx);
;;;392                        }
;;;393    
;;;394                        //
;;;395                        // Copy the string to the output buffer.  Only copy as much
;;;396                        // as will fit in the buffer.  Update the output buffer
;;;397                        // pointer and the space remaining.
;;;398                        //
;;;399                        if(ulIdx > ulSize)
;;;400                        {
;;;401                            ustrncpy(pcBuf, pcStr, ulSize);
;;;402                            pcBuf += ulSize;
;;;403                            ulSize = 0;
;;;404                        }
;;;405                        else
;;;406                        {
;;;407                            ustrncpy(pcBuf, pcStr, ulIdx);
;;;408                            pcBuf += ulIdx;
;;;409                            ulSize -= ulIdx;
;;;410    
;;;411                            //
;;;412                            // Write any required padding spaces assuming there is
;;;413                            // still space in the buffer.
;;;414                            //
;;;415                            if(ulCount > ulIdx)
;;;416                            {
;;;417                                ulCount -= ulIdx;
;;;418                                if(ulCount > ulSize)
;;;419                                {
;;;420                                    ulCount = ulSize;
;;;421                                }
;;;422                                ulSize =- ulCount;
;;;423    
;;;424                                while(ulCount--)
;;;425                                {
;;;426                                    *pcBuf++ = ' ';
;;;427                                }
;;;428                            }
;;;429                        }
;;;430    
;;;431                        //
;;;432                        // Update the conversion count.  This will be the number of
;;;433                        // characters that should have been written, even if there
;;;434                        // was not room in the buffer.
;;;435                        //
;;;436                        iConvertCount += ulIdx;
;;;437    
;;;438                        //
;;;439                        // This command has been handled.
;;;440                        //
;;;441                        break;
;;;442                    }
;;;443    
;;;444                    //
;;;445                    // Handle the %u command.
;;;446                    //
;;;447                    case 'u':
;;;448                    {
;;;449                        //
;;;450                        // Get the value from the varargs.
;;;451                        //
;;;452                        ulValue = va_arg(vaArgP, unsigned long);
;;;453    
;;;454                        //
;;;455                        // Set the base to 10.
;;;456                        //
;;;457                        ulBase = 10;
;;;458    
;;;459                        //
;;;460                        // Indicate that the value is positive so that a minus sign
;;;461                        // isn't inserted.
;;;462                        //
;;;463                        ulNeg = 0;
;;;464    
;;;465                        //
;;;466                        // Convert the value to ASCII.
;;;467                        //
;;;468                        goto convert;
;;;469                    }
;;;470    
;;;471                    //
;;;472                    // Handle the %x and %X commands.  Note that they are treated
;;;473                    // identically; that is, %X will use lower case letters for a-f
;;;474                    // instead of the upper case letters is should use.  We also
;;;475                    // alias %p to %x.
;;;476                    //
;;;477                    case 'x':
;;;478                    case 'X':
;;;479                    case 'p':
;;;480                    {
;;;481                        //
;;;482                        // Get the value from the varargs.
;;;483                        //
;;;484                        ulValue = va_arg(vaArgP, unsigned long);
;;;485    
;;;486                        //
;;;487                        // Set the base to 16.
;;;488                        //
;;;489                        ulBase = 16;
;;;490    
;;;491                        //
;;;492                        // Indicate that the value is positive so that a minus sign
;;;493                        // isn't inserted.
;;;494                        //
;;;495                        ulNeg = 0;
;;;496    
;;;497                        //
;;;498                        // Determine the number of digits in the string version of
;;;499                        // the value.
;;;500                        //
;;;501    convert:
;;;502                        for(ulIdx = 1;
;;;503                            (((ulIdx * ulBase) <= ulValue) &&
;;;504                             (((ulIdx * ulBase) / ulBase) == ulIdx));
;;;505                            ulIdx *= ulBase, ulCount--)
;;;506                        {
;;;507                        }
;;;508    
;;;509                        //
;;;510                        // If the value is negative, reduce the count of padding
;;;511                        // characters needed.
;;;512                        //
;;;513                        if(ulNeg)
;;;514                        {
;;;515                            ulCount--;
;;;516                        }
;;;517    
;;;518                        //
;;;519                        // If the value is negative and the value is padded with
;;;520                        // zeros, then place the minus sign before the padding.
;;;521                        //
;;;522                        if(ulNeg && (ulSize != 0) && (cFill == '0'))
;;;523                        {
;;;524                            //
;;;525                            // Place the minus sign in the output buffer.
;;;526                            //
;;;527                            *pcBuf++ = '-';
;;;528                            ulSize--;
;;;529    
;;;530                            //
;;;531                            // Update the conversion count.
;;;532                            //
;;;533                            iConvertCount++;
;;;534    
;;;535                            //
;;;536                            // The minus sign has been placed, so turn off the
;;;537                            // negative flag.
;;;538                            //
;;;539                            ulNeg = 0;
;;;540                        }
;;;541    
;;;542                        //
;;;543                        // See if there are more characters in the specified field
;;;544                        // width than there are in the conversion of this value.
;;;545                        //
;;;546                        if((ulCount > 1) && (ulCount < 65536))
;;;547                        {
;;;548                            //
;;;549                            // Loop through the required padding characters.
;;;550                            //
;;;551                            for(ulCount--; ulCount; ulCount--)
;;;552                            {
;;;553                                //
;;;554                                // Copy the character to the output buffer if there
;;;555                                // is room.
;;;556                                //
;;;557                                if(ulSize != 0)
;;;558                                {
;;;559                                    *pcBuf++ = cFill;
;;;560                                    ulSize--;
;;;561                                }
;;;562    
;;;563                                //
;;;564                                // Update the conversion count.
;;;565                                //
;;;566                                iConvertCount++;
;;;567                            }
;;;568                        }
;;;569    
;;;570                        //
;;;571                        // If the value is negative, then place the minus sign
;;;572                        // before the number.
;;;573                        //
;;;574                        if(ulNeg && (ulSize != 0))
;;;575                        {
;;;576                            //
;;;577                            // Place the minus sign in the output buffer.
;;;578                            //
;;;579                            *pcBuf++ = '-';
;;;580                            ulSize--;
;;;581    
;;;582                            //
;;;583                            // Update the conversion count.
;;;584                            //
;;;585                            iConvertCount++;
;;;586                        }
;;;587    
;;;588                        //
;;;589                        // Convert the value into a string.
;;;590                        //
;;;591                        for(; ulIdx; ulIdx /= ulBase)
;;;592                        {
;;;593                            //
;;;594                            // Copy the character to the output buffer if there is
;;;595                            // room.
;;;596                            //
;;;597                            if(ulSize != 0)
;;;598                            {
;;;599                                *pcBuf++ = g_pcHex[(ulValue / ulIdx) % ulBase];
;;;600                                ulSize--;
;;;601                            }
;;;602    
;;;603                            //
;;;604                            // Update the conversion count.
;;;605                            //
;;;606                            iConvertCount++;
;;;607                        }
;;;608    
;;;609                        //
;;;610                        // This command has been handled.
;;;611                        //
;;;612                        break;
;;;613                    }
;;;614    
;;;615                    //
;;;616                    // Handle the %% command.
;;;617                    //
;;;618                    case '%':
;;;619                    {
;;;620                        //
;;;621                        // Simply write a single %.
;;;622                        //
;;;623                        if(ulSize != 0)
;;;624                        {
;;;625                            *pcBuf++ = pcString[-1];
;;;626                            ulSize--;
;;;627                        }
;;;628    
;;;629                        //
;;;630                        // Update the conversion count.
;;;631                        //
;;;632                        iConvertCount++;
;;;633    
;;;634                        //
;;;635                        // This command has been handled.
;;;636                        //
;;;637                        break;
;;;638                    }
;;;639    
;;;640                    //
;;;641                    // Handle all other commands.
;;;642                    //
;;;643                    default:
;;;644                    {
;;;645                        //
;;;646                        // Indicate an error.
;;;647                        //
;;;648                        if(ulSize >= 5)
0000b8  2c05              CMP      r4,#5
0000ba  d37d              BCC      |L16.440|
;;;649                        {
;;;650                            ustrncpy(pcBuf, "ERROR", 5);
0000bc  2205              MOVS     r2,#5
0000be  a161              ADR      r1,|L16.580|
0000c0  4628              MOV      r0,r5
0000c2  f7fffffe          BL       ustrncpy
;;;651                            pcBuf += 5;
0000c6  1d6d              ADDS     r5,r5,#5
;;;652                            ulSize -= 5;
0000c8  1f64              SUBS     r4,r4,#5
0000ca  e0b0              B        |L16.558|
                  |L16.204|
0000cc  f8180c01          LDRB     r0,[r8,#-1]           ;273
0000d0  2830              CMP      r0,#0x30              ;273
0000d2  d101              BNE      |L16.216|
0000d4  b907              CBNZ     r7,|L16.216|
0000d6  4683              MOV      r11,r0                ;275
                  |L16.216|
0000d8  eb070187          ADD      r1,r7,r7,LSL #2       ;281
0000dc  0049              LSLS     r1,r1,#1              ;281
0000de  3930              SUBS     r1,r1,#0x30           ;282
0000e0  1847              ADDS     r7,r0,r1              ;282
0000e2  e7bd              B        |L16.96|
                  |L16.228|
0000e4  f85a1b04          LDR      r1,[r10],#4           ;298
0000e8  2c00              CMP      r4,#0                 ;304
0000ea  d066              BEQ      |L16.442|
0000ec  7029              STRB     r1,[r5,#0]            ;306
0000ee  e093              B        |L16.536|
                  |L16.240|
0000f0  f85a1b04          LDR      r1,[r10],#4           ;329
0000f4  2900              CMP      r1,#0                 ;335
0000f6  da02              BGE      |L16.254|
0000f8  4249              RSBS     r1,r1,#0              ;340
0000fa  2001              MOVS     r0,#1                 ;345
0000fc  e000              B        |L16.256|
                  |L16.254|
0000fe  2000              MOVS     r0,#0                 ;353
                  |L16.256|
000100  4684              MOV      r12,r0                ;353
000102  f04f090a          MOV      r9,#0xa               ;359
000106  e03b              B        |L16.384|
                  |L16.264|
000108  f85a1b04          LDR      r1,[r10],#4           ;375
00010c  2000              MOVS     r0,#0                 ;380
00010e  e001              B        |L16.276|
                  |L16.272|
000110  f1090001          ADD      r0,r9,#1              ;380
                  |L16.276|
000114  4681              MOV      r9,r0                 ;380
000116  f8110009          LDRB     r0,[r1,r9]            ;380
00011a  2800              CMP      r0,#0                 ;380
00011c  d1f8              BNE      |L16.272|
00011e  454f              CMP      r7,r9                 ;389
000120  d902              BLS      |L16.296|
000122  eba70009          SUB      r0,r7,r9              ;391
000126  4406              ADD      r6,r6,r0              ;391
                  |L16.296|
000128  4648              MOV      r0,r9                 ;399
00012a  45a1              CMP      r9,r4                 ;399
00012c  d906              BLS      |L16.316|
00012e  4622              MOV      r2,r4                 ;401
000130  4628              MOV      r0,r5                 ;401
000132  f7fffffe          BL       ustrncpy
000136  4425              ADD      r5,r5,r4              ;402
000138  2400              MOVS     r4,#0                 ;403
00013a  e015              B        |L16.360|
                  |L16.316|
00013c  4602              MOV      r2,r0                 ;407
00013e  4628              MOV      r0,r5                 ;407
000140  f7fffffe          BL       ustrncpy
000144  444d              ADD      r5,r5,r9              ;408
000146  eba40409          SUB      r4,r4,r9              ;409
00014a  454f              CMP      r7,r9                 ;415
00014c  d90c              BLS      |L16.360|
00014e  eba70009          SUB      r0,r7,r9              ;417
000152  42a0              CMP      r0,r4                 ;418
000154  d900              BLS      |L16.344|
000156  4620              MOV      r0,r4                 ;420
                  |L16.344|
000158  4244              RSBS     r4,r0,#0              ;422
00015a  2120              MOVS     r1,#0x20              ;241
00015c  e002              B        |L16.356|
                  |L16.350|
00015e  e057              B        |L16.528|
                  |L16.352|
000160  f8051b01          STRB     r1,[r5],#1            ;426
                  |L16.356|
000164  1e40              SUBS     r0,r0,#1              ;424
000166  d2fb              BCS      |L16.352|
                  |L16.360|
000168  444e              ADD      r6,r6,r9              ;436
00016a  e061              B        |L16.560|
                  |L16.364|
00016c  f85a1b04          LDR      r1,[r10],#4           ;452
000170  200a              MOVS     r0,#0xa               ;457
000172  e002              B        |L16.378|
                  |L16.372|
000174  f85a1b04          LDR      r1,[r10],#4           ;484
000178  2010              MOVS     r0,#0x10              ;489
                  |L16.378|
00017a  4681              MOV      r9,r0                 ;489
00017c  f04f0c00          MOV      r12,#0                ;495
                  |L16.384|
000180  2001              MOVS     r0,#1                 ;502
000182  e001              B        |L16.392|
                  |L16.388|
000184  4610              MOV      r0,r2                 ;502
000186  1e7f              SUBS     r7,r7,#1              ;505
                  |L16.392|
000188  fb00f209          MUL      r2,r0,r9              ;503
00018c  428a              CMP      r2,r1                 ;503
00018e  d803              BHI      |L16.408|
000190  fbb2f3f9          UDIV     r3,r2,r9              ;504
000194  4283              CMP      r3,r0                 ;504
000196  d0f5              BEQ      |L16.388|
                  |L16.408|
000198  f1bc0f00          CMP      r12,#0                ;513
00019c  d00b              BEQ      |L16.438|
00019e  1e7f              SUBS     r7,r7,#1              ;515
0001a0  b14c              CBZ      r4,|L16.438|
0001a2  f1bb0f30          CMP      r11,#0x30             ;522
0001a6  d106              BNE      |L16.438|
0001a8  222d              MOVS     r2,#0x2d              ;527
0001aa  1e64              SUBS     r4,r4,#1              ;528
0001ac  f8052b01          STRB     r2,[r5],#1            ;527
0001b0  1c76              ADDS     r6,r6,#1              ;533
0001b2  f04f0c00          MOV      r12,#0                ;539
                  |L16.438|
0001b6  e001              B        |L16.444|
                  |L16.440|
0001b8  e032              B        |L16.544|
                  |L16.442|
0001ba  e02f              B        |L16.540|
                  |L16.444|
0001bc  1eba              SUBS     r2,r7,#2              ;546
0001be  f64f73fe          MOV      r3,#0xfffe            ;546
0001c2  429a              CMP      r2,r3                 ;546
0001c4  d207              BCS      |L16.470|
                  |L16.454|
0001c6  1e7f              SUBS     r7,r7,#1              ;551
0001c8  d005              BEQ      |L16.470|
0001ca  b114              CBZ      r4,|L16.466|
0001cc  f805bb01          STRB     r11,[r5],#1           ;559
0001d0  1e64              SUBS     r4,r4,#1              ;560
                  |L16.466|
0001d2  1c76              ADDS     r6,r6,#1              ;566
0001d4  e7f7              B        |L16.454|
                  |L16.470|
0001d6  f1bc0f00          CMP      r12,#0                ;574
0001da  d005              BEQ      |L16.488|
0001dc  b124              CBZ      r4,|L16.488|
0001de  222d              MOVS     r2,#0x2d              ;579
0001e0  1e64              SUBS     r4,r4,#1              ;580
0001e2  f8052b01          STRB     r2,[r5],#1            ;579
0001e6  1c76              ADDS     r6,r6,#1              ;585
                  |L16.488|
0001e8  f8dfc060          LDR      r12,|L16.588|
                  |L16.492|
0001ec  b300              CBZ      r0,|L16.560|
0001ee  b15c              CBZ      r4,|L16.520|
0001f0  fbb1f3f0          UDIV     r3,r1,r0              ;599
0001f4  fbb3f7f9          UDIV     r7,r3,r9              ;599
0001f8  fb093217          MLS      r2,r9,r7,r3           ;599
0001fc  f8dc3000          LDR      r3,[r12,#0]           ;599  ; g_pcHex
000200  1e64              SUBS     r4,r4,#1              ;600
000202  5c9a              LDRB     r2,[r3,r2]            ;599
000204  f8052b01          STRB     r2,[r5],#1            ;599
                  |L16.520|
000208  fbb0f0f9          UDIV     r0,r0,r9              ;591
00020c  1c76              ADDS     r6,r6,#1              ;606
00020e  e7ed              B        |L16.492|
                  |L16.528|
000210  b124              CBZ      r4,|L16.540|
000212  f8180c01          LDRB     r0,[r8,#-1]           ;625
000216  7028              STRB     r0,[r5,#0]            ;625
                  |L16.536|
000218  1c6d              ADDS     r5,r5,#1              ;625
00021a  1e64              SUBS     r4,r4,#1              ;307
                  |L16.540|
00021c  1c76              ADDS     r6,r6,#1              ;632
00021e  e007              B        |L16.560|
                  |L16.544|
;;;653                        }
;;;654                        else
;;;655                        {
;;;656                            ustrncpy(pcBuf, "ERROR", ulSize);
000220  4622              MOV      r2,r4
000222  a108              ADR      r1,|L16.580|
000224  4628              MOV      r0,r5
000226  f7fffffe          BL       ustrncpy
;;;657                            pcBuf += ulSize;
00022a  4425              ADD      r5,r5,r4
;;;658                            ulSize = 0;
00022c  2400              MOVS     r4,#0
                  |L16.558|
;;;659                        }
;;;660    
;;;661                        //
;;;662                        // Update the conversion count.
;;;663                        //
;;;664                        iConvertCount += 5;
00022e  1d76              ADDS     r6,r6,#5
                  |L16.560|
000230  f8980000          LDRB     r0,[r8,#0]            ;186
000234  2800              CMP      r0,#0                 ;186
000236  f47faeee          BNE      |L16.22|
;;;665    
;;;666                        //
;;;667                        // This command has been handled.
;;;668                        //
;;;669                        break;
;;;670                    }
;;;671                }
;;;672            }
;;;673        }
;;;674    
;;;675        //
;;;676        // Null terminate the string in the buffer.
;;;677        //
;;;678        *pcBuf = 0;
00023a  7028              STRB     r0,[r5,#0]
;;;679    
;;;680        //
;;;681        // Return the number of characters in the full converted string.
;;;682        //
;;;683        return(iConvertCount);
00023c  4630              MOV      r0,r6
;;;684    }
00023e  e8bd8ff0          POP      {r4-r11,pc}
;;;685    
                          ENDP

000242  0000              DCW      0x0000
                  |L16.580|
000244  4552524f          DCB      "ERROR",0
000248  5200    
00024a  00                DCB      0
00024b  00                DCB      0
                  |L16.588|
                          DCD      ||.constdata||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_pcHex
                          DCD      ||.conststring||
                  g_psDaysToMonth
000004  0000001f          DCW      0x0000,0x001f
000008  003b005a          DCW      0x003b,0x005a
00000c  00780097          DCW      0x0078,0x0097
000010  00b500d4          DCW      0x00b5,0x00d4
000014  00f30111          DCW      0x00f3,0x0111
000018  0130014e          DCW      0x0130,0x014e

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=0

000000  30313233          DCB      "0123456789abcdef",0
000004  34353637
000008  38396162
00000c  63646566
000010  00      

                          AREA ||.data||, DATA, ALIGN=2

                  g_ulRandomSeed
                          DCD      0x00000001
