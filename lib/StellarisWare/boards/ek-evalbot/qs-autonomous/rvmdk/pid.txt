; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\pid.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\pid.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\pid.crf pid.c]
                          THUMB

                          AREA ||i.PIDGainDSet||, CODE, READONLY, ALIGN=1

                  PIDGainDSet PROC
;;;107    void
;;;108    PIDGainDSet(tPIDState *psState, long lDGain)
000000  6181              STR      r1,[r0,#0x18]
;;;109    {
;;;110        //
;;;111        // Save the D gain factor.
;;;112        //
;;;113        psState->lDGain = lDGain;
;;;114    }
000002  4770              BX       lr
;;;115    
                          ENDP


                          AREA ||i.PIDGainISet||, CODE, READONLY, ALIGN=1

                  PIDGainISet PROC
;;;75     void
;;;76     PIDGainISet(tPIDState *psState, long lIGain, long lIntegMax, long lIntegMin)
000000  6141              STR      r1,[r0,#0x14]
;;;77     {
;;;78         //
;;;79         // Save the I gain factor.
;;;80         //
;;;81         psState->lIGain = lIGain;
000002  e9c02301          STRD     r2,r3,[r0,#4]
;;;82     
;;;83         //
;;;84         // Save the integrator limits.
;;;85         //
;;;86         psState->lIntegMax = lIntegMax;
;;;87         psState->lIntegMin = lIntegMin;
;;;88     
;;;89         //
;;;90         // Limit the integrator to the new limits if necessary.
;;;91         //
;;;92         if(psState->lIntegrator > lIntegMax)
000006  6801              LDR      r1,[r0,#0]
000008  4291              CMP      r1,r2
00000a  dd01              BLE      |L2.16|
;;;93         {
;;;94             psState->lIntegrator = lIntegMax;
00000c  6002              STR      r2,[r0,#0]
                  |L2.14|
;;;95         }
;;;96         else if(psState->lIntegrator < lIntegMin)
;;;97         {
;;;98             psState->lIntegrator = lIntegMin;
;;;99         }
;;;100    }
00000e  4770              BX       lr
                  |L2.16|
000010  4299              CMP      r1,r3                 ;96
000012  dafc              BGE      |L2.14|
000014  6003              STR      r3,[r0,#0]            ;98
000016  4770              BX       lr
;;;101    
                          ENDP


                          AREA ||i.PIDGainPSet||, CODE, READONLY, ALIGN=1

                  PIDGainPSet PROC
;;;61     void
;;;62     PIDGainPSet(tPIDState *psState, long lPGain)
000000  6101              STR      r1,[r0,#0x10]
;;;63     {
;;;64         //
;;;65         // Save the P gain factor.
;;;66         //
;;;67         psState->lPGain = lPGain;
;;;68     }
000002  4770              BX       lr
;;;69     
                          ENDP


                          AREA ||i.PIDInitialize||, CODE, READONLY, ALIGN=1

                  PIDInitialize PROC
;;;40     void
;;;41     PIDInitialize(tPIDState *psState, long lIntegMax, long lIntegMin, long lPGain,
000000  b570              PUSH     {r4-r6,lr}
;;;42                   long lIGain, long lDGain)
;;;43     {
;;;44         //
;;;45         // Set the internal state, and save the integrator limits and gain factors.
;;;46         //
;;;47         psState->lIntegrator = 0;
000002  2400              MOVS     r4,#0
000004  e9dd5604          LDRD     r5,r6,[sp,#0x10]      ;43
000008  e9c04100          STRD     r4,r1,[r0,#0]
00000c  e9c02402          STRD     r2,r4,[r0,#8]
000010  3010              ADDS     r0,r0,#0x10
000012  c068              STM      r0!,{r3,r5,r6}
;;;48         psState->lIntegMax = lIntegMax;
;;;49         psState->lIntegMin = lIntegMin;
;;;50         psState->lPrevError = 0;
;;;51         psState->lPGain = lPGain;
;;;52         psState->lIGain = lIGain;
;;;53         psState->lDGain = lDGain;
;;;54     }
000014  bd70              POP      {r4-r6,pc}
;;;55     
                          ENDP


                          AREA ||i.PIDReset||, CODE, READONLY, ALIGN=1

                  PIDReset PROC
;;;122    void
;;;123    PIDReset(tPIDState *psState)
000000  2100              MOVS     r1,#0
;;;124    {
;;;125        //
;;;126        // Reset the integrator and previous error.
;;;127        //
;;;128        psState->lIntegrator = 0;
;;;129        psState->lPrevError = 0;
000002  6001              STR      r1,[r0,#0]
000004  60c1              STR      r1,[r0,#0xc]
;;;130    }
000006  4770              BX       lr
;;;131    
                          ENDP


                          AREA ||i.PIDUpdate||, CODE, READONLY, ALIGN=2

                  PIDUpdate PROC
;;;140    long
;;;141    PIDUpdate(tPIDState *psState, long lError)
000000  b570              PUSH     {r4-r6,lr}
;;;142    {
;;;143        long long llOutput;
;;;144        long lOutput;
;;;145    
;;;146        //
;;;147        // Update the error integrator.
;;;148        //
;;;149        if((psState->lIntegrator & 0x80000000) == (lError & 0x80000000))
000002  6802              LDR      r2,[r0,#0]
000004  f0014600          AND      r6,r1,#0x80000000
000008  f0024500          AND      r5,r2,#0x80000000
;;;150        {
;;;151            //
;;;152            // Add the error to the integrator.
;;;153            //
;;;154            psState->lIntegrator += lError;
00000c  1854              ADDS     r4,r2,r1
00000e  e9d02301          LDRD     r2,r3,[r0,#4]         ;149
000012  42b5              CMP      r5,r6                 ;149
000014  6004              STR      r4,[r0,#0]            ;149
000016  d109              BNE      |L6.44|
;;;155    
;;;156            //
;;;157            // Since the sign of the integrator and error matched before the above
;;;158            // addition, if the signs no longer match it is because the integrator
;;;159            // rolled over.  In this case, saturate appropriately.
;;;160            //
;;;161            if((lError < 0) && (psState->lIntegrator > 0))
000018  2900              CMP      r1,#0
00001a  da03              BGE      |L6.36|
00001c  2c00              CMP      r4,#0
00001e  dd05              BLE      |L6.44|
;;;162            {
;;;163                psState->lIntegrator = psState->lIntegMin;
000020  6003              STR      r3,[r0,#0]
000022  e003              B        |L6.44|
                  |L6.36|
;;;164            }
;;;165            if((lError > 0) && (psState->lIntegrator < 0))
000024  dd02              BLE      |L6.44|
000026  2c00              CMP      r4,#0
000028  da00              BGE      |L6.44|
;;;166            {
;;;167                psState->lIntegrator = psState->lIntegMax;
00002a  6002              STR      r2,[r0,#0]
                  |L6.44|
;;;168            }
;;;169        }
;;;170        else
;;;171        {
;;;172            //
;;;173            // Add the error to the integrator.
;;;174            //
;;;175            psState->lIntegrator += lError;
;;;176        }
;;;177    
;;;178        //
;;;179        // Saturate the integrator if necessary.
;;;180        //
;;;181        if(psState->lIntegrator > psState->lIntegMax)
00002c  6804              LDR      r4,[r0,#0]
00002e  4294              CMP      r4,r2
000030  dc01              BGT      |L6.54|
;;;182        {
;;;183            psState->lIntegrator = psState->lIntegMax;
;;;184        }
;;;185        if(psState->lIntegrator < psState->lIntegMin)
000032  4622              MOV      r2,r4
000034  e000              B        |L6.56|
                  |L6.54|
000036  6002              STR      r2,[r0,#0]            ;183
                  |L6.56|
000038  429a              CMP      r2,r3
00003a  da00              BGE      |L6.62|
;;;186        {
;;;187            psState->lIntegrator = psState->lIntegMin;
00003c  6003              STR      r3,[r0,#0]
                  |L6.62|
;;;188        }
;;;189    
;;;190        //
;;;191        // Compute the new control value.
;;;192        //
;;;193        llOutput = (((long long)psState->lPGain * (long long)lError) +
00003e  e9d02404          LDRD     r2,r4,[r0,#0x10]
000042  fb823201          SMULL    r3,r2,r2,r1
000046  6805              LDR      r5,[r0,#0]
000048  fbc43205          SMLAL    r3,r2,r4,r5
00004c  68c5              LDR      r5,[r0,#0xc]
00004e  6984              LDR      r4,[r0,#0x18]
000050  1b4d              SUBS     r5,r1,r5
000052  fbc43205          SMLAL    r3,r2,r4,r5
000056  f04f35ff          MOV      r5,#0xffffffff
00005a  0c6c              LSRS     r4,r5,#17
00005c  1aed              SUBS     r5,r5,r3
00005e  4194              SBCS     r4,r4,r2
;;;194                    ((long long)psState->lIGain *
;;;195                     (long long)psState->lIntegrator) +
;;;196                    ((long long)psState->lDGain *
;;;197                     (long long)(lError - psState->lPrevError)));
;;;198    
;;;199        //
;;;200        // Clip the new control value as appropriate.
;;;201        //
;;;202        if(llOutput > (long long)0x7fffffffffff)
000060  da02              BGE      |L6.104|
;;;203        {
;;;204            lOutput = 0x7fffffff;
000062  f06f4200          MVN      r2,#0x80000000
000066  e007              B        |L6.120|
                  |L6.104|
;;;205        }
;;;206        else if(llOutput < (long long)0xffff800000000000)
000068  4c05              LDR      r4,|L6.128|
00006a  42a2              CMP      r2,r4
00006c  da01              BGE      |L6.114|
;;;207        {
;;;208            lOutput = 0x80000000;
00006e  0422              LSLS     r2,r4,#16
000070  e002              B        |L6.120|
                  |L6.114|
;;;209        }
;;;210        else
;;;211        {
;;;212            lOutput = (llOutput >> 16) & 0xffffffff;
000072  0414              LSLS     r4,r2,#16
000074  ea444213          ORR      r2,r4,r3,LSR #16
                  |L6.120|
;;;213        }
;;;214    
;;;215        //
;;;216        // Save the current error for computing the derivative on the next
;;;217        // iteration.
;;;218        //
;;;219        psState->lPrevError = lError;
;;;220    
;;;221        //
;;;222        // Return the control value.
;;;223        //
;;;224        return(lOutput);
000078  60c1              STR      r1,[r0,#0xc]
00007a  4610              MOV      r0,r2
;;;225    }
00007c  bd70              POP      {r4-r6,pc}
                          ENDP

00007e  0000              DCW      0x0000
                  |L6.128|
                          DCD      0xffff8000
