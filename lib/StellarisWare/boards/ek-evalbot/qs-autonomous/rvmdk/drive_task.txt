; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\drive_task.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\drive_task.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\drive_task.crf drive_task.c]
                          THUMB

                          AREA ||i.DriveInit||, CODE, READONLY, ALIGN=2

                  DriveInit PROC
;;;510    void
;;;511    DriveInit(void)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;512    {
;;;513        unsigned int uMotor;
;;;514    
;;;515        //
;;;516        // Initialize a hardware timer that will just be used as a free-running
;;;517        // timer for measuring duration between wheel sensor pulses.  Interrupts
;;;518        // are not used, just let it run.
;;;519        //
;;;520        ROM_SysCtlPeripheralEnable(WHEEL_TIMER_PERIPH);
000004  f04f7480          MOV      r4,#0x1000000
000008  6c60              LDR      r0,[r4,#0x44]
00000a  6981              LDR      r1,[r0,#0x18]
00000c  4825              LDR      r0,|L1.164|
00000e  4788              BLX      r1
;;;521        ROM_TimerConfigure(WHEEL_TIMER_BASE, TIMER_CFG_PERIODIC_UP);
000010  6be0              LDR      r0,[r4,#0x3c]
000012  4d25              LDR      r5,|L1.168|
000014  2132              MOVS     r1,#0x32
000016  68c2              LDR      r2,[r0,#0xc]
000018  4628              MOV      r0,r5
00001a  4790              BLX      r2
;;;522        ROM_TimerLoadSet(WHEEL_TIMER_BASE, TIMER_BOTH, 0xffffffff);
00001c  6be0              LDR      r0,[r4,#0x3c]
00001e  f04f32ff          MOV      r2,#0xffffffff
000022  0c16              LSRS     r6,r2,#16
000024  6b83              LDR      r3,[r0,#0x38]
000026  4631              MOV      r1,r6
000028  4628              MOV      r0,r5
00002a  4798              BLX      r3
;;;523        ROM_TimerEnable(WHEEL_TIMER_BASE, TIMER_BOTH);
00002c  6be0              LDR      r0,[r4,#0x3c]
00002e  4631              MOV      r1,r6
000030  6842              LDR      r2,[r0,#4]
000032  4628              MOV      r0,r5
000034  4790              BLX      r2
;;;524    
;;;525        //
;;;526        // Compute the wheel tick rate constant.  This is part of the RPM
;;;527        // calculation that can be pre-computed.  This is based on the
;;;528        // following math:
;;;529        //
;;;530        //           Ftick(tick/sec) * 60(sec/min)
;;;531        // Srpm = ----------------------------------  =====> (rev/min)
;;;532        //        Telapsed(tick/click) * 8(click/rev)
;;;533        //
;;;534        // where:
;;;535        //  Ftick is the frequency of the wheel timer in ticks/second
;;;536        //  Telapsed is the elapsed time between "clicks" in timer ticks
;;;537        //  There are 8 wheel "clicks" per revolution
;;;538        //
;;;539        // The above can then be reduced to:
;;;540        //
;;;541        // RPM = (Ftick * 15) / (Telapsed * 2)
;;;542        //
;;;543        // All of this is known now except Telapsed, so the constant is:
;;;544        //
;;;545        // Kwheel = Ftick * 15 / 2
;;;546        //
;;;547        g_ulWheelTimerTickConstant = (ROM_SysCtlClockGet() * 15) / 2;
000036  6c60              LDR      r0,[r4,#0x44]
000038  6e00              LDR      r0,[r0,#0x60]
00003a  4780              BLX      r0
00003c  ebc01000          RSB      r0,r0,r0,LSL #4
000040  0840              LSRS     r0,r0,#1
;;;548    
;;;549        //
;;;550        // Pre-compute the number of ticks represented by the minimum and
;;;551        // maximum reasonable RPM so that they can be used in range comparison
;;;552        //
;;;553        g_ulMaxRPMTicks = g_ulWheelTimerTickConstant / MAX_WHEEL_RPM;
000042  2264              MOVS     r2,#0x64
000044  fbb0f2f2          UDIV     r2,r0,r2
000048  4918              LDR      r1,|L1.172|
;;;554        g_ulMinRPMTicks = g_ulWheelTimerTickConstant / MIN_WHEEL_RPM;
00004a  608a              STR      r2,[r1,#8]  ; g_ulMaxRPMTicks
00004c  6008              STR      r0,[r1,#0]  ; g_ulWheelTimerTickConstant
00004e  2205              MOVS     r2,#5
000050  fbb0f0f2          UDIV     r0,r0,r2
;;;555    
;;;556        //
;;;557        // Initialize the motor hardware
;;;558        //
;;;559        MotorsInit();
000054  6048              STR      r0,[r1,#4]  ; g_ulMinRPMTicks
000056  f7fffffe          BL       MotorsInit
;;;560    
;;;561        //
;;;562        // Initialize the wheel sensors, providing handler for wheel clicks
;;;563        //
;;;564        WheelSensorsInit(DriveWheelSensorHandler);
00005a  4815              LDR      r0,|L1.176|
00005c  f7fffffe          BL       WheelSensorsInit
;;;565    
;;;566        //
;;;567        // Process once each for left and right motor
;;;568        //
;;;569        for(uMotor = 0; uMotor < 2; uMotor++)
000060  2500              MOVS     r5,#0
;;;570        {
;;;571            tMotorDrive *pMotor = &g_sMotorDrives[uMotor];
000062  4f14              LDR      r7,|L1.180|
000064  462e              MOV      r6,r5                 ;569
;;;572    
;;;573            //
;;;574            // Initialize the PID controller
;;;575            //
;;;576            PIDInitialize(&pMotor->sPID,
000066  f44f5880          MOV      r8,#0x1000
                  |L1.106|
00006a  eb050045          ADD      r0,r5,r5,LSL #1       ;571
00006e  eb071400          ADD      r4,r7,r0,LSL #4       ;571
000072  2200              MOVS     r2,#0
000074  9600              STR      r6,[sp,#0]
000076  4643              MOV      r3,r8
000078  4611              MOV      r1,r2
00007a  f1040014          ADD      r0,r4,#0x14
00007e  9601              STR      r6,[sp,#4]
000080  f7fffffe          BL       PIDInitialize
;;;577                          MOTORPID_INTEGRATOR_MAX, MOTORPID_INTEGRATOR_MIN,
;;;578                          MOTORPID_PGAIN, MOTORPID_IGAIN, MOTORPID_DGAIN);
;;;579    
;;;580            //
;;;581            // Set the actual and target speeds to 0
;;;582            //
;;;583            pMotor->lActualSpeed = 0;
000084  60a6              STR      r6,[r4,#8]
;;;584            pMotor->lTargetSpeed = 0;
;;;585            pMotor->bRunning = 0;
000086  6066              STR      r6,[r4,#4]
000088  7066              STRB     r6,[r4,#1]
00008a  1c6d              ADDS     r5,r5,#1              ;569
00008c  2d02              CMP      r5,#2                 ;569
00008e  d3ec              BCC      |L1.106|
;;;586        }
;;;587    
;;;588        //
;;;589        // Enable the wheel sensors
;;;590        //
;;;591        WheelSensorEnable();
000090  f7fffffe          BL       WheelSensorEnable
;;;592        WheelSensorIntEnable(WHEEL_LEFT);
000094  2000              MOVS     r0,#0
000096  f7fffffe          BL       WheelSensorIntEnable
;;;593        WheelSensorIntEnable(WHEEL_RIGHT);
00009a  e8bd41fc          POP      {r2-r8,lr}
00009e  2001              MOVS     r0,#1
0000a0  f7ffbffe          B.W      WheelSensorIntEnable
;;;594    }
                          ENDP

                  |L1.164|
                          DCD      0x10100001
                  |L1.168|
                          DCD      0x40030000
                  |L1.172|
                          DCD      ||.data||
                  |L1.176|
                          DCD      DriveWheelSensorHandler
                  |L1.180|
                          DCD      ||.bss||

                          AREA ||i.DriveRun||, CODE, READONLY, ALIGN=2

                  DriveRun PROC
;;;390    void
;;;391    DriveRun(unsigned long ulDirection, unsigned long ulSpeed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;392    {
000004  460c              MOV      r4,r1
;;;393        //
;;;394        // Validate the inputs
;;;395        //
;;;396        if(((ulDirection != MOTOR_DRIVE_REVERSE) &&
000006  2804              CMP      r0,#4
000008  d004              BEQ      |L2.20|
;;;397            (ulDirection != MOTOR_DRIVE_FORWARD) &&
00000a  2803              CMP      r0,#3
00000c  d002              BEQ      |L2.20|
;;;398            (ulDirection != MOTOR_DRIVE_TURN_LEFT) &&
00000e  b108              CBZ      r0,|L2.20|
;;;399            (ulDirection != MOTOR_DRIVE_TURN_RIGHT)) ||
000010  2801              CMP      r0,#1
000012  d14e              BNE      |L2.178|
                  |L2.20|
;;;400           (ulSpeed > MAX_WHEEL_RPM))
000014  2c64              CMP      r4,#0x64
000016  d84c              BHI      |L2.178|
000018  2101              MOVS     r1,#1                 ;392
;;;401        {
;;;402            return;
;;;403        }
;;;404    
;;;405        //
;;;406        // Determine which direction each motor needs to run
;;;407        //
;;;408        switch(ulDirection)
;;;409        {
;;;410            //
;;;411            // Turn left - left motor reverse, right motor forward
;;;412            //
;;;413            case MOTOR_DRIVE_TURN_LEFT:
;;;414            {
;;;415                g_sMotorDrives[MOTOR_DRIVE_LEFT].bReverse = 1;
00001a  4d27              LDR      r5,|L2.184|
00001c  2600              MOVS     r6,#0                 ;392
00001e  b148              CBZ      r0,|L2.52|
000020  2801              CMP      r0,#1                 ;408
000022  d009              BEQ      |L2.56|
000024  2803              CMP      r0,#3                 ;408
000026  d009              BEQ      |L2.60|
000028  2804              CMP      r0,#4                 ;408
00002a  d00b              BEQ      |L2.68|
;;;416                g_sMotorDrives[MOTOR_DRIVE_RIGHT].bReverse = 0;
;;;417                break;
;;;418            }
;;;419    
;;;420            //
;;;421            // Turn right - left motor forward, right motor reverse
;;;422            //
;;;423            case MOTOR_DRIVE_TURN_RIGHT:
;;;424            {
;;;425                g_sMotorDrives[MOTOR_DRIVE_LEFT].bReverse = 0;
;;;426                g_sMotorDrives[MOTOR_DRIVE_RIGHT].bReverse = 1;
;;;427                break;
;;;428            }
;;;429    
;;;430            //
;;;431            // Forward - both motors forward
;;;432            //
;;;433            case MOTOR_DRIVE_FORWARD:
;;;434            {
;;;435                g_sMotorDrives[MOTOR_DRIVE_LEFT].bReverse = 0;
;;;436                g_sMotorDrives[MOTOR_DRIVE_RIGHT].bReverse = 0;
;;;437                break;
;;;438            }
;;;439    
;;;440            //
;;;441            // Reverse - both motors reverse
;;;442            //
;;;443            case MOTOR_DRIVE_REVERSE:
;;;444            {
;;;445                g_sMotorDrives[MOTOR_DRIVE_LEFT].bReverse = 1;
;;;446                g_sMotorDrives[MOTOR_DRIVE_RIGHT].bReverse = 1;
;;;447                break;
;;;448            }
;;;449    
;;;450            //
;;;451            // Default - should never happen so return with all stopped
;;;452            //
;;;453            default:
;;;454            {
;;;455                DriveStop();
00002c  e8bd41f0          POP      {r4-r8,lr}
000030  f7ffbffe          B.W      DriveStop
                  |L2.52|
000034  7029              STRB     r1,[r5,#0]            ;415
000036  e002              B        |L2.62|
                  |L2.56|
000038  702e              STRB     r6,[r5,#0]            ;425
00003a  e004              B        |L2.70|
                  |L2.60|
00003c  702e              STRB     r6,[r5,#0]            ;435
                  |L2.62|
00003e  f8856030          STRB     r6,[r5,#0x30]         ;416
000042  e002              B        |L2.74|
                  |L2.68|
000044  7029              STRB     r1,[r5,#0]            ;445
                  |L2.70|
000046  f8851030          STRB     r1,[r5,#0x30]         ;426
                  |L2.74|
;;;456                return;
;;;457            }
;;;458        }
;;;459    
;;;460        //
;;;461        // Set the target motor speed
;;;462        //
;;;463        g_sMotorDrives[MOTOR_DRIVE_LEFT].lTargetSpeed = ulSpeed;
;;;464        g_sMotorDrives[MOTOR_DRIVE_RIGHT].lTargetSpeed = ulSpeed;
00004a  606c              STR      r4,[r5,#4]  ; g_sMotorDrives
;;;465    
;;;466        //
;;;467        // Set each motor to forward or reverse as needed
;;;468        //
;;;469        MotorDir(LEFT_SIDE,
00004c  636c              STR      r4,[r5,#0x34]  ; g_sMotorDrives
00004e  7828              LDRB     r0,[r5,#0]  ; g_sMotorDrives
000050  b108              CBZ      r0,|L2.86|
;;;470                 g_sMotorDrives[MOTOR_DRIVE_LEFT].bReverse ? REVERSE : FORWARD);
000052  2101              MOVS     r1,#1
000054  e000              B        |L2.88|
                  |L2.86|
000056  2100              MOVS     r1,#0
                  |L2.88|
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       MotorDir
;;;471        MotorDir(RIGHT_SIDE,
00005e  f8950030          LDRB     r0,[r5,#0x30]  ; g_sMotorDrives
000062  b108              CBZ      r0,|L2.104|
;;;472                 g_sMotorDrives[MOTOR_DRIVE_RIGHT].bReverse ? REVERSE : FORWARD);
000064  2101              MOVS     r1,#1
000066  e000              B        |L2.106|
                  |L2.104|
000068  2100              MOVS     r1,#0
                  |L2.106|
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       MotorDir
;;;473    
;;;474        //
;;;475        // As an initial value, set the motor speed duty in percent to the same
;;;476        // as the request RPM.  This just takes advantage of a coincidence that
;;;477        // PWM duty cycle = RPM (approx).  Enable the motor to start running.
;;;478        //
;;;479        g_sMotorDrives[MOTOR_DRIVE_LEFT].lDuty = ulSpeed << 16;
000070  0420              LSLS     r0,r4,#16
;;;480        g_sMotorDrives[MOTOR_DRIVE_RIGHT].lDuty = ulSpeed << 16;
000072  6128              STR      r0,[r5,#0x10]  ; g_sMotorDrives
;;;481        MotorSpeed(LEFT_SIDE, (unsigned short)(ulSpeed << 8));
000074  0227              LSLS     r7,r4,#8
000076  6428              STR      r0,[r5,#0x40]  ; g_sMotorDrives
000078  b2b9              UXTH     r1,r7
00007a  2000              MOVS     r0,#0
00007c  f7fffffe          BL       MotorSpeed
;;;482        MotorSpeed(RIGHT_SIDE, (unsigned short)(ulSpeed << 8));
000080  b2b9              UXTH     r1,r7
000082  2001              MOVS     r0,#1
000084  f7fffffe          BL       MotorSpeed
;;;483        MotorRun(LEFT_SIDE);
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       MotorRun
;;;484        MotorRun(RIGHT_SIDE);
00008e  2001              MOVS     r0,#1
000090  f7fffffe          BL       MotorRun
;;;485    
;;;486        //
;;;487        // Make sure the wheel is marked as not running.  This will force the
;;;488        // wheel speed calculator to collect two edges before computing an
;;;489        // actual speed.  Then set the actual wheel speed to the commanded speed
;;;490        // so that the initial error calculation will be much closer to actual.
;;;491        //
;;;492        g_sMotorDrives[LEFT_SIDE].bRunning = 0;
000094  706e              STRB     r6,[r5,#1]
;;;493        g_sMotorDrives[RIGHT_SIDE].bRunning = 0;
000096  f8856031          STRB     r6,[r5,#0x31]
;;;494        g_sMotorDrives[LEFT_SIDE].lActualSpeed = ulSpeed;
00009a  60ac              STR      r4,[r5,#8]  ; g_sMotorDrives
;;;495        g_sMotorDrives[RIGHT_SIDE].lActualSpeed = ulSpeed;
00009c  63ac              STR      r4,[r5,#0x38]  ; g_sMotorDrives
;;;496    
;;;497        //
;;;498        // Since we (maybe) changed the speed, reset the PID controller
;;;499        //
;;;500        PIDReset(&g_sMotorDrives[LEFT_SIDE].sPID);
00009e  4806              LDR      r0,|L2.184|
0000a0  3014              ADDS     r0,r0,#0x14
0000a2  f7fffffe          BL       PIDReset
;;;501        PIDReset(&g_sMotorDrives[RIGHT_SIDE].sPID);
0000a6  e8bd41f0          POP      {r4-r8,lr}
0000aa  4803              LDR      r0,|L2.184|
0000ac  3044              ADDS     r0,r0,#0x44
0000ae  f7ffbffe          B.W      PIDReset
                  |L2.178|
;;;502    }
0000b2  e8bd81f0          POP      {r4-r8,pc}
;;;503    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L2.184|
                          DCD      ||.bss||

                          AREA ||i.DriveSpeedGet||, CODE, READONLY, ALIGN=2

                  DriveSpeedGet PROC
;;;216    long
;;;217    DriveSpeedGet(unsigned long ulMotor)
000000  b570              PUSH     {r4-r6,lr}
;;;218    {
;;;219        unsigned long ulElapsed;
;;;220        unsigned long ulNowTicks;
;;;221        volatile unsigned long ulLastTick;
;;;222    
;;;223        //
;;;224        // First get the value of the most recent edge tick.  This value is
;;;225        // copied to here because it might be changed by the wheel tick handler
;;;226        // while we are in this function.
;;;227        //
;;;228        ulLastTick = g_sMotorDrives[ulMotor].ulLastEdgeTick;
000002  eb000140          ADD      r1,r0,r0,LSL #1
000006  480a              LDR      r0,|L3.48|
000008  eb001401          ADD      r4,r0,r1,LSL #4
00000c  68e5              LDR      r5,[r4,#0xc]
;;;229    
;;;230        //
;;;231        // Get the current value of the wheel tick timer
;;;232        //
;;;233        ulNowTicks = ROM_TimerValueGet(WHEEL_TIMER_BASE, TIMER_A);
00000e  f04f7080          MOV      r0,#0x1000000
000012  21ff              MOVS     r1,#0xff
000014  6bc0              LDR      r0,[r0,#0x3c]
000016  6c02              LDR      r2,[r0,#0x40]
000018  4806              LDR      r0,|L3.52|
00001a  4790              BLX      r2
;;;234    
;;;235        //
;;;236        // Find out how much time has elapsed since the last wheel tick.
;;;237        //
;;;238        ulElapsed = ulNowTicks - ulLastTick;
;;;239    
;;;240        //
;;;241        // If it is longer than the time represented by minimum RPM, then
;;;242        // consider the speed to be 0.
;;;243        //
;;;244        if(ulElapsed > g_ulMinRPMTicks)
00001c  4906              LDR      r1,|L3.56|
00001e  1b40              SUBS     r0,r0,r5              ;238
000020  6849              LDR      r1,[r1,#4]  ; g_ulMinRPMTicks
000022  4288              CMP      r0,r1
000024  d902              BLS      |L3.44|
;;;245        {
;;;246            //
;;;247            // Mark the actual speed as 0 and the motor as stopped.
;;;248            //
;;;249            g_sMotorDrives[ulMotor].lActualSpeed = 0;
000026  2000              MOVS     r0,#0
000028  60a0              STR      r0,[r4,#8]
;;;250            g_sMotorDrives[ulMotor].bRunning = 0;
00002a  7060              STRB     r0,[r4,#1]
                  |L3.44|
;;;251        }
;;;252    
;;;253        //
;;;254        // Return the actual speed
;;;255        //
;;;256        return(g_sMotorDrives[ulMotor].lActualSpeed);
00002c  68a0              LDR      r0,[r4,#8]
;;;257    }
00002e  bd70              POP      {r4-r6,pc}
;;;258    
                          ENDP

                  |L3.48|
                          DCD      ||.bss||
                  |L3.52|
                          DCD      0x40030000
                  |L3.56|
                          DCD      ||.data||

                          AREA ||i.DriveStop||, CODE, READONLY, ALIGN=2

                  DriveStop PROC
;;;344    void
;;;345    DriveStop(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;346    {
;;;347        unsigned int uMotor;
;;;348    
;;;349        //
;;;350        // Process once each for left and right motor
;;;351        //
;;;352        for(uMotor = 0; uMotor < 2; uMotor++)
000004  2400              MOVS     r4,#0
;;;353        {
;;;354            tMotorDrive *pMotor = &g_sMotorDrives[uMotor];
000006  f8df8034          LDR      r8,|L4.60|
00000a  4626              MOV      r6,r4                 ;352
                  |L4.12|
00000c  eb040144          ADD      r1,r4,r4,LSL #1
000010  eb081501          ADD      r5,r8,r1,LSL #4
;;;355    
;;;356            //
;;;357            // Command the motor hardware to stop
;;;358            //
;;;359            MotorSpeed((unsigned char)uMotor, 0);
000014  b2e0              UXTB     r0,r4
000016  2100              MOVS     r1,#0
000018  4607              MOV      r7,r0
00001a  f7fffffe          BL       MotorSpeed
00001e  4638              MOV      r0,r7
;;;360            MotorStop(uMotor);
000020  f7fffffe          BL       MotorStop
;;;361    
;;;362            //
;;;363            // Set the actual and target speeds to 0
;;;364            //
;;;365            pMotor->lActualSpeed = 0;
000024  60ae              STR      r6,[r5,#8]
;;;366            pMotor->lTargetSpeed = 0;
;;;367    
;;;368            //
;;;369            // Mark motor as not running
;;;370            //
;;;371            pMotor->bRunning = 0;
000026  606e              STR      r6,[r5,#4]
000028  706e              STRB     r6,[r5,#1]
;;;372    
;;;373            //
;;;374            // Reset the PID controller
;;;375            //
;;;376            PIDReset(&pMotor->sPID);
00002a  f1050014          ADD      r0,r5,#0x14
00002e  f7fffffe          BL       PIDReset
000032  1c64              ADDS     r4,r4,#1              ;352
000034  2c02              CMP      r4,#2                 ;352
000036  d3e9              BCC      |L4.12|
;;;377        }
;;;378    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;379    
                          ENDP

                  |L4.60|
                          DCD      ||.bss||

                          AREA ||i.DriveTask||, CODE, READONLY, ALIGN=2

                  DriveTask PROC
;;;270    void
;;;271    DriveTask(void *pvParam)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;272    {
;;;273        unsigned int uMotor;
;;;274        long lDiff;
;;;275        long lPIDOutput;
;;;276        unsigned short usPercent;
;;;277    
;;;278        //
;;;279        // Process once each for left and right motor
;;;280        //
;;;281        for(uMotor = 0; uMotor < 2; uMotor++)
000004  2500              MOVS     r5,#0
;;;282        {
;;;283            tMotorDrive *pMotor = &g_sMotorDrives[uMotor];
000006  f8df9060          LDR      r9,|L5.104|
;;;284    
;;;285            //
;;;286            // Compute the difference between target speed and actual speed.
;;;287            //
;;;288            lDiff = pMotor->lTargetSpeed - pMotor->lActualSpeed;
;;;289    
;;;290            //
;;;291            // Feed the difference to the PID loop.  The output is interpreted
;;;292            // as a duty cycle adjustment (positive or negative), in percent,
;;;293            // in 16.16 format
;;;294            //
;;;295            lPIDOutput = PIDUpdate(&pMotor->sPID, lDiff << 16);
;;;296    
;;;297            //
;;;298            //
;;;299            // Restrict the duty cycle adjustment to a maximum range of
;;;300            // +/- 10%.
;;;301            //
;;;302            if(lPIDOutput > (10 << 16))
00000a  f44f2620          MOV      r6,#0xa0000
;;;303            {
;;;304                lPIDOutput = 10 << 16;
;;;305            }
;;;306            else if(lPIDOutput < -(10 << 16))
00000e  4277              RSBS     r7,r6,#0
;;;307            {
;;;308                lPIDOutput = -10 << 16;
;;;309            }
;;;310    
;;;311            //
;;;312            // Now apply the adjustment to the motor duty cycle.
;;;313            //
;;;314            pMotor->lDuty += lPIDOutput;
;;;315    
;;;316            //
;;;317            // Keep the resulting duty cycle between 0 and 100%
;;;318            //
;;;319            if(pMotor->lDuty > (100 << 16))
000010  f44f08c8          MOV      r8,#0x640000
                  |L5.20|
000014  eb050145          ADD      r1,r5,r5,LSL #1       ;283
000018  eb091401          ADD      r4,r9,r1,LSL #4       ;283
00001c  e9d40101          LDRD     r0,r1,[r4,#4]         ;288
000020  1a40              SUBS     r0,r0,r1              ;288
000022  0401              LSLS     r1,r0,#16             ;295
000024  f1040014          ADD      r0,r4,#0x14           ;295
000028  f7fffffe          BL       PIDUpdate
00002c  42b0              CMP      r0,r6                 ;302
00002e  dd01              BLE      |L5.52|
000030  4630              MOV      r0,r6                 ;304
000032  e002              B        |L5.58|
                  |L5.52|
000034  42b8              CMP      r0,r7                 ;306
000036  da00              BGE      |L5.58|
000038  4638              MOV      r0,r7                 ;308
                  |L5.58|
00003a  6921              LDR      r1,[r4,#0x10]         ;314
00003c  4408              ADD      r0,r0,r1              ;314
00003e  6120              STR      r0,[r4,#0x10]
000040  4540              CMP      r0,r8
000042  dd02              BLE      |L5.74|
;;;320            {
;;;321                pMotor->lDuty = 100 << 16;
000044  f8c48010          STR      r8,[r4,#0x10]
000048  e003              B        |L5.82|
                  |L5.74|
;;;322            }
;;;323            else if(pMotor->lDuty < 0)
00004a  2800              CMP      r0,#0
00004c  da01              BGE      |L5.82|
;;;324            {
;;;325                pMotor->lDuty = 0;
00004e  2000              MOVS     r0,#0
000050  6120              STR      r0,[r4,#0x10]
                  |L5.82|
;;;326            }
;;;327    
;;;328            //
;;;329            // The duty cycle is kept in units of percent, in 16.16 format.  Pass
;;;330            // the new duty cycle value to the motor duty cycle control function.
;;;331            // The duty cycle needs to be converted to 8.8 format which is
;;;332            // expected by that function.
;;;333            //
;;;334            usPercent = (unsigned short)(pMotor->lDuty >> 8);
000052  6920              LDR      r0,[r4,#0x10]
000054  f3c0210f          UBFX     r1,r0,#8,#16
;;;335            MotorSpeed((unsigned char)uMotor, usPercent);
000058  b2e8              UXTB     r0,r5
00005a  f7fffffe          BL       MotorSpeed
00005e  1c6d              ADDS     r5,r5,#1              ;281
000060  2d02              CMP      r5,#2                 ;281
000062  d3d7              BCC      |L5.20|
;;;336        }
;;;337    }
000064  e8bd87f0          POP      {r4-r10,pc}
;;;338    
                          ENDP

                  |L5.104|
                          DCD      ||.bss||

                          AREA ||i.DriveWheelSensorHandler||, CODE, READONLY, ALIGN=2

                  DriveWheelSensorHandler PROC
;;;143    static void
;;;144    DriveWheelSensorHandler(tWheel eWheel)
000000  b510              PUSH     {r4,lr}
;;;145    {
000002  0004              MOVS     r4,r0
;;;146        unsigned long ulNowTicks;
;;;147        unsigned long ulElapsed;
;;;148    
;;;149        //
;;;150        // Make sure that the motor specified is valid
;;;151        //
;;;152        if((eWheel != WHEEL_LEFT) && (eWheel != WHEEL_RIGHT))
000004  d001              BEQ      |L6.10|
000006  2c01              CMP      r4,#1
000008  d11c              BNE      |L6.68|
                  |L6.10|
;;;153        {
;;;154            //
;;;155            // Do nothing if bad value was passed in
;;;156            //
;;;157            return;
;;;158        }
;;;159    
;;;160        //
;;;161        // Get the current value of the wheel tick timer
;;;162        //
;;;163        ulNowTicks = ROM_TimerValueGet(WHEEL_TIMER_BASE, TIMER_A);
00000a  f04f7080          MOV      r0,#0x1000000
00000e  21ff              MOVS     r1,#0xff
000010  6bc0              LDR      r0,[r0,#0x3c]
000012  6c02              LDR      r2,[r0,#0x40]
000014  480e              LDR      r0,|L6.80|
000016  4790              BLX      r2
;;;164    
;;;165        //
;;;166        // If the wheel was previously not running, then save this edge time,
;;;167        // mark this wheel as now running, and return without computing a new
;;;168        // wheel speed.  This is done so that a bogus speed is not calculated
;;;169        // on the first click when the motor starts from a stop.
;;;170        //
;;;171        if(!g_sMotorDrives[eWheel].bRunning)
000018  490e              LDR      r1,|L6.84|
00001a  eb040244          ADD      r2,r4,r4,LSL #1
00001e  eb011202          ADD      r2,r1,r2,LSL #4
000022  7851              LDRB     r1,[r2,#1]
000024  b179              CBZ      r1,|L6.70|
;;;172        {
;;;173            g_sMotorDrives[eWheel].ulLastEdgeTick = ulNowTicks;
;;;174            g_sMotorDrives[eWheel].bRunning = true;
;;;175            return;
;;;176        }
;;;177    
;;;178        //
;;;179        // Compute how many ticks since the last wheel click.
;;;180        // Note: use of unsigned, full-scale math means that tick timer rollover
;;;181        // is taken care of automatically.
;;;182        //
;;;183        ulElapsed = ulNowTicks - g_sMotorDrives[eWheel].ulLastEdgeTick;
000026  68d1              LDR      r1,[r2,#0xc]
;;;184    
;;;185        //
;;;186        // Cap the measured elapsed time to the reasonable range.
;;;187        //
;;;188        if(ulElapsed > g_ulMinRPMTicks)
000028  4c0b              LDR      r4,|L6.88|
00002a  1a41              SUBS     r1,r0,r1              ;183
00002c  6863              LDR      r3,[r4,#4]  ; g_ulMinRPMTicks
00002e  4299              CMP      r1,r3
000030  d802              BHI      |L6.56|
;;;189        {
;;;190            ulElapsed = g_ulMinRPMTicks;
;;;191        }
;;;192        else if(ulElapsed < g_ulMaxRPMTicks)
000032  68a3              LDR      r3,[r4,#8]  ; g_ulMaxRPMTicks
000034  4299              CMP      r1,r3
000036  d200              BCS      |L6.58|
                  |L6.56|
000038  4619              MOV      r1,r3
                  |L6.58|
;;;193        {
;;;194            ulElapsed = g_ulMaxRPMTicks;
;;;195        }
;;;196    
;;;197        //
;;;198        // Save the timer tick value from this pass, so that next time it will
;;;199        // be used for determining the elapsed time.
;;;200        //
;;;201        g_sMotorDrives[eWheel].ulLastEdgeTick = ulNowTicks;
00003a  60d0              STR      r0,[r2,#0xc]
;;;202    
;;;203        //
;;;204        // Now compute the actual speed.  The speed is in RPM in 32.0 format.
;;;205        //
;;;206        g_sMotorDrives[eWheel].lActualSpeed = g_ulWheelTimerTickConstant /
00003c  6820              LDR      r0,[r4,#0]  ; g_ulWheelTimerTickConstant
00003e  fbb0f0f1          UDIV     r0,r0,r1
000042  6090              STR      r0,[r2,#8]
                  |L6.68|
;;;207                                              ulElapsed;
;;;208    }
000044  bd10              POP      {r4,pc}
                  |L6.70|
000046  60d0              STR      r0,[r2,#0xc]          ;173
000048  2001              MOVS     r0,#1                 ;174
00004a  7050              STRB     r0,[r2,#1]            ;174
00004c  bd10              POP      {r4,pc}
;;;209    
                          ENDP

00004e  0000              DCW      0x0000
                  |L6.80|
                          DCD      0x40030000
                  |L6.84|
                          DCD      ||.bss||
                  |L6.88|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_sMotorDrives
                          %        96

                          AREA ||.data||, DATA, ALIGN=2

                  g_ulWheelTimerTickConstant
                          DCD      0x00000000
                  g_ulMinRPMTicks
                          DCD      0x00000000
                  g_ulMaxRPMTicks
                          DCD      0x00000000
