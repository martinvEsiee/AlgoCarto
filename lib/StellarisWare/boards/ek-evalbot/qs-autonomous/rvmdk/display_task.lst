L 1 "display_task.c"
N//****************************************************************************
N//
N// display_task.c - Display task for EVALBOT autonomous example.
N//
N// Copyright (c) 2011-2012 Texas Instruments Incorporated.  All rights reserved.
N// Software License Agreement
N// 
N// Texas Instruments (TI) is supplying this software for use solely and
N// exclusively on TI's microcontroller products. The software is owned by
N// TI and/or its suppliers, and is protected under applicable copyright
N// laws. You may not combine this software with "viral" open-source
N// software in order to form a larger program.
N// 
N// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
N// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
N// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
N// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
N// DAMAGES, FOR ANY REASON WHATSOEVER.
N// 
N// This is part of revision 9107 of the Stellaris Firmware Development Package.
N//
N//****************************************************************************
N
N#include "inc/hw_types.h"
L 1 "..\..\..\inc/hw_types.h" 1
N//*****************************************************************************
N//
N// hw_types.h - Common types and macros.
N//
N// Copyright (c) 2005-2012 Texas Instruments Incorporated.  All rights reserved.
N// Software License Agreement
N// 
N//   Redistribution and use in source and binary forms, with or without
N//   modification, are permitted provided that the following conditions
N//   are met:
N// 
N//   Redistributions of source code must retain the above copyright
N//   notice, this list of conditions and the following disclaimer.
N// 
N//   Redistributions in binary form must reproduce the above copyright
N//   notice, this list of conditions and the following disclaimer in the
N//   documentation and/or other materials provided with the  
N//   distribution.
N// 
N//   Neither the name of Texas Instruments Incorporated nor the names of
N//   its contributors may be used to endorse or promote products derived
N//   from this software without specific prior written permission.
N// 
N// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
N// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
N// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
N// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
N// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
N// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N// 
N// This is part of revision 9107 of the Stellaris Firmware Development Package.
N//
N//*****************************************************************************
N
N#ifndef __HW_TYPES_H__
N#define __HW_TYPES_H__
N
N//*****************************************************************************
N//
N// Define a boolean type, and values for true and false.
N//
N//*****************************************************************************
Ntypedef unsigned char tBoolean;
N
N#ifndef true
N#define true 1
N#endif
N
N#ifndef false
N#define false 0
N#endif
N
N//*****************************************************************************
N//
N// Macros for hardware access, both direct and via the bit-band region.
N//
N//*****************************************************************************
N#define HWREG(x)                                                              \
N        (*((volatile unsigned long *)(x)))
X#define HWREG(x)                                                                      (*((volatile unsigned long *)(x)))
N#define HWREGH(x)                                                             \
N        (*((volatile unsigned short *)(x)))
X#define HWREGH(x)                                                                     (*((volatile unsigned short *)(x)))
N#define HWREGB(x)                                                             \
N        (*((volatile unsigned char *)(x)))
X#define HWREGB(x)                                                                     (*((volatile unsigned char *)(x)))
N#define HWREGBITW(x, b)                                                       \
N        HWREG(((unsigned long)(x) & 0xF0000000) | 0x02000000 |                \
N              (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))
X#define HWREGBITW(x, b)                                                               HWREG(((unsigned long)(x) & 0xF0000000) | 0x02000000 |                              (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))
N#define HWREGBITH(x, b)                                                       \
N        HWREGH(((unsigned long)(x) & 0xF0000000) | 0x02000000 |               \
N               (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))
X#define HWREGBITH(x, b)                                                               HWREGH(((unsigned long)(x) & 0xF0000000) | 0x02000000 |                              (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))
N#define HWREGBITB(x, b)                                                       \
N        HWREGB(((unsigned long)(x) & 0xF0000000) | 0x02000000 |               \
N               (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))
X#define HWREGBITB(x, b)                                                               HWREGB(((unsigned long)(x) & 0xF0000000) | 0x02000000 |                              (((unsigned long)(x) & 0x000FFFFF) << 5) | ((b) << 2))
N
N//*****************************************************************************
N//
N// Helper Macros for determining silicon revisions, etc.
N//
N// These macros will be used by Driverlib at "run-time" to create necessary
N// conditional code blocks that will allow a single version of the Driverlib
N// "binary" code to support multiple(all) Stellaris silicon revisions.
N//
N// It is expected that these macros will be used inside of a standard 'C'
N// conditional block of code, e.g.
N//
N//     if(CLASS_IS_SANDSTORM)
N//     {
N//         do some Sandstorm-class specific code here.
N//     }
N//
N// By default, these macros will be defined as run-time checks of the
N// appropriate register(s) to allow creation of run-time conditional code
N// blocks for a common DriverLib across the entire Stellaris family.
N//
N// However, if code-space optimization is required, these macros can be "hard-
N// coded" for a specific version of Stellaris silicon.  Many compilers will
N// then detect the "hard-coded" conditionals, and appropriately optimize the
N// code blocks, eliminating any "unreachable" code.  This would result in
N// a smaller Driverlib, thus producing a smaller final application size, but
N// at the cost of limiting the Driverlib binary to a specific Stellaris
N// silicon revision.
N//
N//*****************************************************************************
N#ifndef CLASS_IS_SANDSTORM
N#define CLASS_IS_SANDSTORM                                                    \
N        (((HWREG(SYSCTL_DID0) & SYSCTL_DID0_VER_M) == SYSCTL_DID0_VER_0) ||   \
N         ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
N          (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_SANDSTORM)))
X#define CLASS_IS_SANDSTORM                                                            (((HWREG(SYSCTL_DID0) & SYSCTL_DID0_VER_M) == SYSCTL_DID0_VER_0) ||            ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) ==           (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_SANDSTORM)))
N#endif
N
N#ifndef CLASS_IS_FURY
N#define CLASS_IS_FURY                                                        \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
N         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_FURY))
X#define CLASS_IS_FURY                                                                ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) ==          (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_FURY))
N#endif
N
N#ifndef CLASS_IS_DUSTDEVIL
N#define CLASS_IS_DUSTDEVIL                                                   \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
N         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_DUSTDEVIL))
X#define CLASS_IS_DUSTDEVIL                                                           ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) ==          (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_DUSTDEVIL))
N#endif
N
N#ifndef CLASS_IS_TEMPEST
N#define CLASS_IS_TEMPEST                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
N         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_TEMPEST))
X#define CLASS_IS_TEMPEST                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) ==          (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_TEMPEST))
N#endif
N
N#ifndef CLASS_IS_FIRESTORM
N#define CLASS_IS_FIRESTORM                                                   \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
N         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_FIRESTORM))
X#define CLASS_IS_FIRESTORM                                                           ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) ==          (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_FIRESTORM))
N#endif
N
N#ifndef CLASS_IS_BLIZZARD
N#define CLASS_IS_BLIZZARD                                                    \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) == \
N         (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_BLIZZARD))
X#define CLASS_IS_BLIZZARD                                                            ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_VER_M | SYSCTL_DID0_CLASS_M)) ==          (SYSCTL_DID0_VER_1 | SYSCTL_DID0_CLASS_BLIZZARD))
N#endif
N
N#ifndef REVISION_IS_A0
N#define REVISION_IS_A0                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_0))
X#define REVISION_IS_A0                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_0))
N#endif
N
N#ifndef REVISION_IS_A1
N#define REVISION_IS_A1                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_0))
X#define REVISION_IS_A1                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_0))
N#endif
N
N#ifndef REVISION_IS_A2
N#define REVISION_IS_A2                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_2))
X#define REVISION_IS_A2                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVA | SYSCTL_DID0_MIN_2))
N#endif
N
N#ifndef REVISION_IS_B0
N#define REVISION_IS_B0                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVB | SYSCTL_DID0_MIN_0))
X#define REVISION_IS_B0                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVB | SYSCTL_DID0_MIN_0))
N#endif
N
N#ifndef REVISION_IS_B1
N#define REVISION_IS_B1                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVB | SYSCTL_DID0_MIN_1))
X#define REVISION_IS_B1                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVB | SYSCTL_DID0_MIN_1))
N#endif
N
N#ifndef REVISION_IS_C0
N#define REVISION_IS_C0                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_0))
X#define REVISION_IS_C0                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_0))
N#endif
N
N#ifndef REVISION_IS_C1
N#define REVISION_IS_C1                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_1))
X#define REVISION_IS_C1                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_1))
N#endif
N
N#ifndef REVISION_IS_C2
N#define REVISION_IS_C2                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_2))
X#define REVISION_IS_C2                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_2))
N#endif
N
N#ifndef REVISION_IS_C3
N#define REVISION_IS_C3                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_3))
X#define REVISION_IS_C3                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_3))
N#endif
N
N#ifndef REVISION_IS_C5
N#define REVISION_IS_C5                                                     \
N        ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) == \
N         (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_5))
X#define REVISION_IS_C5                                                             ((HWREG(SYSCTL_DID0) & (SYSCTL_DID0_MAJ_M | SYSCTL_DID0_MIN_M)) ==          (SYSCTL_DID0_MAJ_REVC | SYSCTL_DID0_MIN_5))
N#endif
N
N//*****************************************************************************
N//
N// Deprecated silicon class and revision detection macros.
N//
N//*****************************************************************************
N#ifndef DEPRECATED
N#define DEVICE_IS_SANDSTORM     CLASS_IS_SANDSTORM
N#define DEVICE_IS_FURY          CLASS_IS_FURY
N#define DEVICE_IS_REVA2         REVISION_IS_A2
N#define DEVICE_IS_REVC1         REVISION_IS_C1
N#define DEVICE_IS_REVC2         REVISION_IS_C2
N#endif
N
N#endif // __HW_TYPES_H__
L 26 "display_task.c" 2
N#include "drivers/display96x16x1.h"
L 1 "..\drivers/display96x16x1.h" 1
N//*****************************************************************************
N//
N// display96x16x1.h - Prototypes for the driver for the 96x16 monochrome
N//                    graphical OLED display found on the ek-evalbot board.
N//
N// Copyright (c) 2011-2012 Texas Instruments Incorporated.  All rights reserved.
N// Software License Agreement
N// 
N// Texas Instruments (TI) is supplying this software for use solely and
N// exclusively on TI's microcontroller products. The software is owned by
N// TI and/or its suppliers, and is protected under applicable copyright
N// laws. You may not combine this software with "viral" open-source
N// software in order to form a larger program.
N// 
N// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
N// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
N// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
N// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
N// DAMAGES, FOR ANY REASON WHATSOEVER.
N// 
N// This is part of revision 9107 of the Stellaris Firmware Development Package.
N//
N//*****************************************************************************
N
N#ifndef __DISPLAY96X16X1_H__
N#define __DISPLAY96X16X1_H__
N
N//*****************************************************************************
N//
N//! The number of pixel columns across the display.
N//
N//*****************************************************************************
N#define DISPLAY_WIDTH 96
N
N//*****************************************************************************
N//
N//! The width of a character cell in pixels.  This applies to the font embedded
N//! within the display driver.
N//
N//*****************************************************************************
N#define CHAR_CELL_WIDTH 6
N
N//*****************************************************************************
N//
N//! The number of characters that can be printed on a single line of the
N//! display assuming a 6 pixel wide character cell.
N//
N//*****************************************************************************
N#define CHARS_PER_LINE (DISPLAY_WIDTH / CHAR_CELL_WIDTH)
N
N//*****************************************************************************
N//
N// Prototypes for the driver APIs.
N//
N//*****************************************************************************
Nextern void Display96x16x1Clear(void);
Nextern void Display96x16x1ClearLine(unsigned long ulY);
Nextern void Display96x16x1StringDraw(const char *pcStr, unsigned long ulX,
N                                   unsigned long ulY);
Nextern void Display96x16x1StringDrawLen(const char *pcStr, unsigned long ulLen,
N                                        unsigned long ulX, unsigned long ulY);
Nextern void Display96x16x1StringDrawCentered(const char *pcStr,
N                                             unsigned long ulY,
N                                             tBoolean bClear);
Nextern void Display96x16x1ImageDraw(const unsigned char *pucImage,
N                                  unsigned long ulX, unsigned long ulY,
N                                  unsigned long ulWidth,
N                                  unsigned long ulHeight);
Nextern void Display96x16x1Init(tBoolean bFast);
Nextern void Display96x16x1DisplayOn(void);
Nextern void Display96x16x1DisplayOff(void);
N
N#endif // __DISPLAY96X16X1_H__
L 27 "display_task.c" 2
N#include "utils/scheduler.h"
L 1 "..\..\..\utils/scheduler.h" 1
N//****************************************************************************
N//
N// scheduler.h - Public header for the simple timed function scheduler module.
N//
N// Copyright (c) 2010-2012 Texas Instruments Incorporated.  All rights reserved.
N// Software License Agreement
N// 
N// Texas Instruments (TI) is supplying this software for use solely and
N// exclusively on TI's microcontroller products. The software is owned by
N// TI and/or its suppliers, and is protected under applicable copyright
N// laws. You may not combine this software with "viral" open-source
N// software in order to form a larger program.
N// 
N// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
N// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
N// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
N// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
N// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
N// DAMAGES, FOR ANY REASON WHATSOEVER.
N// 
N// This is part of revision 9107 of the Stellaris Firmware Development Package.
N//
N//****************************************************************************
N#ifndef __SCHEDULER_H__
N#define __SCHEDULER_H__
N
N//*****************************************************************************
N//
N// If building with a C++ compiler, make all of the definitions in this header
N// have a C binding.
N//
N//*****************************************************************************
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N//*****************************************************************************
N//
N//! \addtogroup scheduler_api
N//! @{
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// Prototype of a function that the scheduler can call periodically.
N//
N//*****************************************************************************
Ntypedef void (*tSchedulerFunction)(void *pvParam);
N
N//*****************************************************************************
N//
N//! The structure defining a function which the scheduler will call
N//! periodically.
N//
N//*****************************************************************************
Ntypedef struct
N{
N    //
N    //! A pointer to the function which is to be called periodically by the
N    //! scheduler.
N    //
N    void (*pfnFunction)(void *);
N
N    //
N    //! The parameter which is to be passed to this function when it is called.
N    //
N    void *pvParam;
N
N    //
N    //! The frequency the function is to be called expressed in terms of system
N    //! ticks.  If this value is 0, the function will be called on every call
N    //! to SchedulerRun.
N    //
N    unsigned long ulFrequencyTicks;
N
N    //
N    //! Tick count when this function was last called.  This field is updated
N    //! by the scheduler.
N    //
N    unsigned long ulLastCall;
N
N    //
N    //! A flag indicating whether or not this task is active.  If true, the
N    //! function will be called periodically.  If false, the function is
N    //! disabled and will not be called.
N    //
N    tBoolean bActive;
N}
NtSchedulerTask;
N
N//*****************************************************************************
N//
N//! This global table must be populated by the client and contains information
N//! on each function that the scheduler is to call.
N//
N//*****************************************************************************
Nextern tSchedulerTask g_psSchedulerTable[];
N
N//*****************************************************************************
N//
N//! This global variable must be exported by the client.  It must contain the
N//! number of entries in the g_psSchedulerTable array.
N//
N//*****************************************************************************
Nextern unsigned long g_ulSchedulerNumTasks;
N
N//*****************************************************************************
N//
N// Close the Doxygen group.
N//! @}
N//
N//*****************************************************************************
N
N//*****************************************************************************
N//
N// Public function prototypes
N//
N//*****************************************************************************
Nextern void SchedulerSysTickIntHandler(void);
Nextern void SchedulerInit(unsigned long ulTicksPerSecond);
Nextern void SchedulerRun(void);
Nextern void SchedulerTaskEnable(unsigned long ulIndex, tBoolean bRunNow);
Nextern void SchedulerTaskDisable(unsigned long ulIndex);
Nextern unsigned long SchedulerTickCountGet(void);
Nextern unsigned long SchedulerElapsedTicksGet(unsigned long ulTickCount);
Nextern unsigned long SchedulerElapsedTicksCalc(unsigned long ulTickStart,
N                                               unsigned long ulTickEnd);
N
N//*****************************************************************************
N//
N// Mark the end of the C bindings section for C++ compilers.
N//
N//*****************************************************************************
N#ifdef __cplusplus
S}
N#endif
N
N#endif // __ SCHEDULER_H_
L 28 "display_task.c" 2
N
N//*****************************************************************************
N//
N// A bitmap for the Texas Instruments logo type.  The bitmap is as follows:
N//
N//    123456781234567812345678123456781234567812345678123456781234567812345678
N//  0 .xxxxxxxxxxxx..............................................xxxxxx.......
N//  1 .xxxxxxxxxxxxx.............................................xxxxx........
N//  2 xx....xxx...xx..............................................xxx.........
N//  3 x.....xxx..xxxxxxxxx.xxxxxx.xxxxx...xxx.......xxxxx.........xxx..xxx....
N//  4 ......xxx..xxxxxxxxx.xxxxx..xxxxx...xxxx....xxxxxxxx........xxx..xxxx...
N//  5 ......xxx...xxx...xxx.xxxx...xx....xxxxx....xxx.xxxx........xxx...xxxx..
N//  6 ......xxx...xxx.....x..xxxx.xx.....xxxxx...xxx....xx........xxx...xxxxx.
N//  7 ......xxx...xxx....x....xxxxxx.....xx.xxx..xxxxx............xxx...xxxxxx
N//  0 ......xxx...xxxxxxxx.....xxxx.....xx..xxx...xxxxxxx.........xxx...xx.xxx
N//  1 ......xxx...xxxxxxxx.....xxxx.....xx..xxxx...xxxxxxx........xxx...xx..xx
N//  2 ......xxx...xxx....x....xxxxxx...xxxxxxxxx.....xxxxxx.......xxx...xx...x
N//  3 ......xxx...xxx.........xx.xxx...xxxxxxxxx.xx.....xxx.......xxx...xx....
N//  4 ......xxx...xxx.....xx.xx...xxx..xx....xxxxxx.....xxx.......xxx...xx....
N//  5 .....xxxxx..xxxxxxxxx.xxx...xxxxxxx.....xxx.xxxxxxxx.......xxxxx..xx....
N//  6 .....xxxxx.xxxxxxxxxxxxxx..xxxxxxxx....xxxxxxxxxxxx........xxxxx.xxxx...
N//  7 ........................................................................
N//
N// Continued...
N//    123456781234567812345678123456781234567812345678123456781234567812345678
N//  0 ........................................................................
N//  1 ........................................................................
N//  2 ........................................................................
N//  3 ..xxxx..xxxx...xxxxxxxxx.xxxxxxx....xxxxx...xxxxxxxx......xxxxxxxxxxxxx.
N//  4 ..xxx..xxxxxxx.xxxxxxxxxxxxxxxxxxxx.xxxxx...xxxxxxxxx....xxxx.xxxxxxxxx.
N//  5 ..xx.xxx..xxx.xx.xxx.xxx.xxxxxxxxx..xxx.....xx..xxxx....xxxxx..xxx...xxx
N//  6 ..xx.xx.....xxx..xxx...x.xxx...xxxx.xxx.....xx..xxxxx...xxxxx..xxx.....x
N//  7 ..xx.xxxx........xxx.....xxx...xxxx.xxx.....xx..xxxxx...xxxxx..xxx...xx.
N//  0 x.xx.xxxxxxx.....xxx.....xxx..xxxx..xxx.....xx..xx.xxx.xx.xxx..xxxxxxxx.
N//  1 xxxx..xxxxxxxx...xxx.....xxxxxxxx...xxx.....xx..xx.xxx.xx.xxx..xxx...xx.
N//  2 xxxx.....xxxxx...xxx.....xxx.xxxx...xxx.....xx..xx.xxxxx..xxx..xxx......
N//  3 xxxx.x.....xxx...xxx.....xxx..xxxx..xxx.....xx..xx..xxxx..xxx..xxx......
N//  4 xxxx.xx... xxx...xxx.....xxx...xxx..xxx.....xx..xx..xxxx..xxx..xxx.....x
N//  5 .xxx.xxxxxxxxx...xxx.....xxx...xxxx..xxxxxxxxx..xx....xx..xxx..xxxxxxxxx
N//  6 ..xx..xxxxxx....xxxxx...xxxxx...xxxx..xxxxxxx..xxxx...xx.xxxxxxxxxxxxxxx
N//  7 ........................................................................
N//
N// Continued...
N//
N//    12345678123456781234567812345678
N//  0 ................................
N//  1 ................................
N//  2 ................................
N//  3 xxxx....xxxx.xxxxxxxx...xxxx....
N//  4 xxxxx...xxxxxxxxxxxxxx.xxxxxxxx.
N//  5 .xxxxx...xx.xx. xxx.xx.xxx..xxx.
N//  6 .xxxxx...xx.x...xxx..xxxx.....x.
N//  7 .xx.xxx..xx.....xxx....xxxx.....
N//  0 .xx.xxxx.xx.....xxx....xxxxxxx..
N//  1 .xx..xxxxxx.....xxx.....xxxxxxx.
N//  2 .xx...xxxxx.....xxx........xxxxx
N//  3 .xx....xxxx.....xxx...xx.....xxx
N//  4 .xx.....xxx.....xxx...xxx....xxx
N//  5 .xx......xx.....xxx....xxxxxxxx.
N//  6 xxxx.....xx....xxxxx...xxxxxxx..
N//  7 ................................
N//
N//*****************************************************************************
Nstatic const unsigned char g_pucTILogo[] =
N{
N 	//
N    // Top Row (blank columns added to left and right edges)
N    //
N    0x00,
N};
N/*
N	0x0c, 0x07, 0x03, 0x03, 0x03, 0x03, 0xff, 0xff,
N    0xff, 0x03, 0x03, 0x1b, 0xfe, 0xfe, 0xf8, 0x18,
N    0x18, 0x18, 0x38, 0xb8, 0x60, 0x18, 0x38, 0x78,
N    0xf8, 0xf8, 0xc8, 0x80, 0xd8, 0xf8, 0x38, 0x18,
N    0x18, 0x00, 0x00, 0xe0, 0xf8, 0x78, 0xf8, 0xf0,
N    0x80, 0x00, 0x00, 0xc0, 0xf0, 0xf0, 0xb8, 0x98,
N    0x38, 0x38, 0x78, 0x70, 0x00, 0x00, 0x00, 0x00,
N    0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x03,
N    0x01, 0x18, 0xf8, 0xf8, 0xf0, 0xe0, 0xc0, 0x80,
N
N    0x00, 0x00, 0xf8, 0xf8, 0x18, 0xe8, 0xe0, 0xb0,
N    0x98, 0x18, 0x38, 0x38, 0x70, 0x50, 0x60, 0x38,
N    0x18, 0xf8, 0xf8, 0xf8, 0x18, 0x38, 0x38, 0x78,
N    0x10, 0xf8, 0xf8, 0xf8, 0x38, 0x38, 0x38, 0xf8,
N    0xf0, 0xf0, 0xd0, 0x00, 0xf8, 0xf8, 0xf8, 0x18,
N    0x18, 0x00, 0x00, 0x00, 0xf8, 0xf8, 0x18, 0x18,
N    0xf8, 0xf8, 0xf8, 0xf8, 0xd0, 0x00, 0x00, 0x00,
N    0xe0, 0xf0, 0xf8, 0xf8, 0xf8, 0x08, 0x18, 0xf8,
N    0xf8, 0xf8, 0x18, 0x18, 0x18, 0xb8, 0xb8, 0x60,
N
N    0x18, 0xf8, 0xf8, 0x78, 0xf0, 0xe0, 0x80, 0x00,
N    0x18, 0xf8, 0xf8, 0x18, 0x70, 0x38, 0x18, 0x18,
N    0xf8, 0xf8, 0xf8, 0x18, 0x38, 0x70, 0x40, 0xf0,
N    0xf8, 0xb8, 0x98, 0x18, 0x38, 0x30, 0x70, 0x00,
N    0x00,
N
N    //
N    // Second row (blank columns added to left and right edges)
N    //
N    0x00,
N    0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x7f, 0x7f,
N    0x7f, 0x60, 0x00, 0x40, 0x7f, 0x7f, 0x7f, 0x63,
N    0x63, 0x63, 0x63, 0x67, 0x70, 0x50, 0x60, 0x70,
N    0x7c, 0x0f, 0x07, 0x4f, 0x7f, 0x7c, 0x70, 0x60,
N    0x60, 0x7c, 0x7f, 0x0f, 0x0c, 0x0c, 0x0f, 0x5f,
N    0x7f, 0x7e, 0x70, 0x58, 0x79, 0x63, 0x63, 0x67,
N    0x67, 0x67, 0x7f, 0x3e, 0x1c, 0x00, 0x00, 0x00,
N    0x00, 0x00, 0x00, 0x60, 0x7f, 0x7f, 0x7f, 0x60,
N    0x00, 0x40, 0x7f, 0x7f, 0x40, 0x01, 0x03, 0x07,
N
N    0x1f, 0x3e, 0x7f, 0x7f, 0x00, 0x39, 0x73, 0x63,
N    0x63, 0x67, 0x67, 0x7f, 0x3e, 0x3e, 0x00, 0x00,
N    0x40, 0x7f, 0x7f, 0x7f, 0x40, 0x00, 0x00, 0x00,
N    0x40, 0x7f, 0x7f, 0x7f, 0x42, 0x06, 0x0f, 0x3f,
N    0x7f, 0x79, 0x60, 0x40, 0x1f, 0x3f, 0x7f, 0x60,
N    0x60, 0x60, 0x60, 0x60, 0x7f, 0x3f, 0x00, 0x40,
N    0x7f, 0x7f, 0x40, 0x07, 0x1f, 0x1f, 0x7c, 0x7f,
N    0x03, 0x40, 0x7f, 0x7f, 0x7f, 0x40, 0x40, 0x7f,
N    0x7f, 0x7f, 0x61, 0x61, 0x61, 0x63, 0x63, 0x70,
N
N    0x40, 0x7f, 0x7f, 0x40, 0x01, 0x03, 0x07, 0x0f,
N    0x0e, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x40,
N    0x7f, 0x7f, 0x7f, 0x40, 0x00, 0x00, 0x18, 0x79,
N    0x73, 0x63, 0x61, 0x63, 0x63, 0x7f, 0x3e, 0x1c,
N    0x00
N};
N*/
N//*****************************************************************************
N//
N// Frame buffer used for rendering the display content before being sent to
N// the display.
N//
N//*****************************************************************************
Nstatic unsigned char g_pucFrame[192];
N
N//*****************************************************************************
N//
N// Scrolls a wide image across the display.  The first time this function is
N// called, the width of the image must be specified in the ulImageWidth
N// parameter.  This initializes the image for scrolling.  Then, this function
N// should be called successively with the ulImageWidth parameter set to 0.
N// This causes the image to advance by one pixel across the screen each time
N// it is called.  By calling this function periodically the image can be made
N// to appear to smoothly scroll across the screen.
N//
N// The image passed should be an image that is suitable to pass to the display
N// driver "ImageDraw" function.
N//
N// As long as the image has not scrolled off the screen, this function will
N// return a non-zero value.  Once the image has completely scrolled off the
N// screen, it will return 0.
N//
N//*****************************************************************************
Nstatic unsigned long
NScrollImage(const unsigned char *pucImage, unsigned long ulImageWidth)
N{
N    unsigned long ulLoop;
N    static unsigned long ulIdx = 0;
N    static unsigned long ulWidth;
N
N    //
N    // If an image width is specified, then initialize the scrolling image
N    // display variables.
N    //
N    if(ulImageWidth)
N    {
N        ulWidth = ulImageWidth;
N        ulIdx = 0;
N    }
N
N    //
N    // Otherwise, the ulImageWidth parameter was 0, which means to advance
N    // the image across the screen by one pixel.
N    //
N    else
N    {
N        //
N        // Clear the local frame buffer.
N        //
N        for(ulLoop = 0; ulLoop < 192; ulLoop += 4)
N        {
N            *(unsigned long *)(g_pucFrame + ulLoop) = 0;
N        }
N
N        //
N        // See if the image has reached the left side of the display.
N        //
N        if(ulIdx <= 96)
N        {
N            //
N            // Copy the first N columns of the image to the right side of the
N            // local frame buffer.
N            //
N            for(ulLoop = 0; ulLoop < ulIdx; ulLoop++)
N            {
N                g_pucFrame[ulLoop + 96 - ulIdx] = pucImage[ulLoop];
N                g_pucFrame[ulLoop + 96 - ulIdx + 96] =
N                    pucImage[ulLoop + ulWidth];
N            }
N        }
N
N        //
N        // See if the right side of the image has reached the right side of the
N        // display.
N        //
N        else if(ulIdx < ulWidth)
N        {
N            //
N            // Copy 96 columns from the middle of the image to the local frame
N            // buffer.
N            //
N            for(ulLoop = 0; ulLoop < 96; ulLoop++)
N            {
N                g_pucFrame[ulLoop] = pucImage[ulLoop + ulIdx - 96];
N                g_pucFrame[ulLoop + 96] =
N                    pucImage[ulLoop + ulIdx - 96 + ulWidth];
N            }
N        }
N
N        //
N        // Otherwise, the right side of the image has already reached the right
N        // side of the display.
N        //
N        else
N        {
N            //
N            // Copy the right N columns of the image to the left side of the
N            // local frame buffer.
N            //
N            for(ulLoop = 0; ulLoop < (ulWidth + 96 - ulIdx); ulLoop++)
N            {
N                g_pucFrame[ulLoop] = pucImage[ulLoop + ulIdx - 96];
N                g_pucFrame[ulLoop + 96] =
N                    pucImage[ulLoop + ulIdx - 96 + ulWidth];
N            }
N        }
N
N        //
N        // Display the local frame buffer on the display.
N        //
N        Display96x16x1ImageDraw(g_pucFrame, 0, 0, 96, 2);
N    }
N
N    //
N    // Increment the scrolling column index.
N    //
N    ulIdx++;
N
N    //
N    // Return 1 if the image is still scrolling, 0 if done
N    //
N    return((ulIdx > (ulWidth + 96)) ? 1 : 0);
N}
N//*****************************************************************************
N//
N// This function is the display "task" that is called periodically by the
N// Scheduler from the application main processing loop.
N// This function displays a cycle of several messages on the display.
N//
N// Odd values are used for timeouts for some of the displayed messaged.  For
N// example a message may be shown for 5.3 seconds.  This is done to keep the
N// changes on the display out of sync with the LED blinking which occurs
N// once per second.
N//
N//*****************************************************************************
Nvoid
NDisplayTask(void *pvParam)
N{
N    static unsigned long ulState = 2; //TG il etait a 0
N    static unsigned long ulLastTick = 0;
N    static unsigned long ulTimeout = 0;
N
N    //
N    // Check to see if the timeout has expired and it is time to change the
N    // display.
N    //
N    if(SchedulerElapsedTicksGet(ulLastTick) > ulTimeout)
N    {
N        //
N        // Save the current tick value to use for comparison next time through
N        //
N        ulLastTick = SchedulerTickCountGet();
N
N        //
N        // Switch based on the display task state
N        //
N        switch(ulState)
N        {
N            //
N            // In this state, the scrolling TI logo is initialized, and the
N            // state changed to next state.  A short timeout is used so that
N            // the scrolling image will start next time through this task.
N            //
N            case 0:
N            {
N                ScrollImage(g_pucTILogo, sizeof(g_pucTILogo) / 2);
N                ulTimeout = 1;
N                ulState = 1;
N                break;
N            }
N
N            //
N            // In this state the TI logo is scrolled across the screen with
N            // a scroll rate of this task period (each time this task is
N            // called by the scheduler it advances the scroll by one pixel
N            // column).
N            //
N            case 1:
N            {
N                if(ScrollImage(g_pucTILogo, 0))
N                {
N                    //
N                    // If the scrolling is done, then advance the state and
N                    // set the timeout for 1.3 seconds (next state will start
N                    // in 1.3 seconds).
N                    //
N                    ulTimeout = 130;
N                    ulState = 2;
N                }
N                break;
N            }
N
N            //
N            // This state shows the text "STELLARIS" on the display for 5.3
N            // seconds.
N            //
N            case 2:
N            {
N                Display96x16x1StringDraw("FLORIAN", 21, 0);
N                ulTimeout = 530;
N                ulState = 3;
N                break;
N            }
N
N            //
N            // This state clears the screen for 1.3 seconds.
N            //
N            case 3:
N            {
N                Display96x16x1Clear();
N                ulTimeout = 130;
N                ulState = 4;
N                break;
N            }
N
N            //
N            // This state shows "EVALBOT" for 5.3 seconds.
N            //
N            case 4:
N            {
N                Display96x16x1StringDraw("EVALBOT", 27, 0);
N                ulTimeout = 530;
N                ulState = 5;
N                break;
N            }
N
N            //
N            // This state clears the screen for 1.3 seconds.
N            //
N            case 5:
N            {
N                Display96x16x1Clear();
N                ulTimeout = 130;
N                ulState = 0;
N                break;
N            }
N
N            //
N            // The default state should not occur, but if it does, then reset
N            // back to the beginning state.
N            //
N            default:
N            {
N                ulTimeout = 130;
N                ulState = 0;
N                break;
N            }
N        }
N    }
N}
N
N//*****************************************************************************
N//
N// This function initializes the display task.  It should be called from the
N// application initialization code.
N//
N//*****************************************************************************
Nvoid
NDisplayTaskInit(void *pvParam)
N{
N    //
N    // Initialize the display driver and turn the display on.
N    //
N    Display96x16x1Init(false);
X    Display96x16x1Init(0);
N    Display96x16x1DisplayOn();
N}
