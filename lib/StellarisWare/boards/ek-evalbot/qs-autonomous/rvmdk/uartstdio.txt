; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\uartstdio.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\uartstdio.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\uartstdio.crf ..\..\..\utils\uartstdio.c]
                          THUMB

                          AREA ||i.GetBufferCount||, CODE, READONLY, ALIGN=1

                  GetBufferCount PROC
;;;253    static unsigned long
;;;254    GetBufferCount(volatile unsigned long *pulRead,
000000  6809              LDR      r1,[r1,#0]
;;;255                   volatile unsigned long *pulWrite, unsigned long ulSize)
;;;256    {
;;;257        unsigned long ulWrite;
;;;258        unsigned long ulRead;
;;;259    
;;;260        ulWrite = *pulWrite;
;;;261        ulRead = *pulRead;
000002  6800              LDR      r0,[r0,#0]
;;;262    
;;;263        return((ulWrite >= ulRead) ? (ulWrite - ulRead) :
000004  4281              CMP      r1,r0
000006  d301              BCC      |L1.12|
000008  1a08              SUBS     r0,r1,r0
;;;264                                     (ulSize - (ulRead - ulWrite)));
;;;265    }
00000a  4770              BX       lr
                  |L1.12|
00000c  1a40              SUBS     r0,r0,r1              ;264
00000e  1a10              SUBS     r0,r2,r0              ;264
000010  4770              BX       lr
;;;266    #endif
                          ENDP


                          AREA ||i.IsBufferEmpty||, CODE, READONLY, ALIGN=1

                  IsBufferEmpty PROC
;;;222    static tBoolean
;;;223    IsBufferEmpty(volatile unsigned long *pulRead,
000000  6809              LDR      r1,[r1,#0]
;;;224                  volatile unsigned long *pulWrite)
;;;225    {
;;;226        unsigned long ulWrite;
;;;227        unsigned long ulRead;
;;;228    
;;;229        ulWrite = *pulWrite;
;;;230        ulRead = *pulRead;
000002  6800              LDR      r0,[r0,#0]
;;;231    
;;;232        return((ulWrite  == ulRead) ? true : false);
000004  4281              CMP      r1,r0
000006  d101              BNE      |L2.12|
000008  2001              MOVS     r0,#1
;;;233    }
00000a  4770              BX       lr
                  |L2.12|
00000c  2000              MOVS     r0,#0                 ;232
00000e  4770              BX       lr
;;;234    #endif
                          ENDP


                          AREA ||i.IsBufferFull||, CODE, READONLY, ALIGN=1

                  IsBufferFull PROC
;;;191    static tBoolean
;;;192    IsBufferFull(volatile unsigned long *pulRead,
000000  6809              LDR      r1,[r1,#0]
;;;193                 volatile unsigned long *pulWrite, unsigned long ulSize)
;;;194    {
;;;195        unsigned long ulWrite;
;;;196        unsigned long ulRead;
;;;197    
;;;198        ulWrite = *pulWrite;
;;;199        ulRead = *pulRead;
000002  6800              LDR      r0,[r0,#0]
;;;200    
;;;201        return((((ulWrite + 1) % ulSize) == ulRead) ? true : false);
000004  1c49              ADDS     r1,r1,#1
000006  fbb1f3f2          UDIV     r3,r1,r2
00000a  fb021113          MLS      r1,r2,r3,r1
00000e  4281              CMP      r1,r0
000010  d101              BNE      |L3.22|
000012  2001              MOVS     r0,#1
;;;202    }
000014  4770              BX       lr
                  |L3.22|
000016  2000              MOVS     r0,#0                 ;201
000018  4770              BX       lr
;;;203    #endif
                          ENDP


                          AREA ||i.UARTEchoSet||, CODE, READONLY, ALIGN=2

                  UARTEchoSet PROC
;;;1513   void
;;;1514   UARTEchoSet(tBoolean bEnable)
000000  b118              CBZ      r0,|L4.10|
;;;1515   {
;;;1516       g_bDisableEcho = !bEnable;
000002  2000              MOVS     r0,#0
                  |L4.4|
000004  4902              LDR      r1,|L4.16|
000006  7048              STRB     r0,[r1,#1]
;;;1517   }
000008  4770              BX       lr
                  |L4.10|
00000a  2001              MOVS     r0,#1                 ;1516
00000c  e7fa              B        |L4.4|
;;;1518   #endif
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      ||.data||

                          AREA ||i.UARTFlushRx||, CODE, READONLY, ALIGN=2

                  UARTFlushRx PROC
;;;1405   void
;;;1406   UARTFlushRx(void)
000000  b510              PUSH     {r4,lr}
;;;1407   {
;;;1408       unsigned long ulInt;
;;;1409   
;;;1410       //
;;;1411       // Temporarily turn off interrupts.
;;;1412       //
;;;1413       ulInt = MAP_IntMasterDisable();
000002  f04f7480          MOV      r4,#0x1000000
000006  6ca0              LDR      r0,[r4,#0x48]
000008  6880              LDR      r0,[r0,#8]
00000a  4780              BLX      r0
;;;1414   
;;;1415       //
;;;1416       // Flush the receive buffer.
;;;1417       //
;;;1418       g_ulUARTRxReadIndex = 0;
00000c  4a05              LDR      r2,|L5.36|
00000e  2100              MOVS     r1,#0
000010  6111              STR      r1,[r2,#0x10]  ; g_ulUARTRxReadIndex
;;;1419       g_ulUARTRxWriteIndex = 0;
000012  60d1              STR      r1,[r2,#0xc]  ; g_ulUARTRxWriteIndex
;;;1420   
;;;1421       //
;;;1422       // If interrupts were enabled when we turned them off, turn them
;;;1423       // back on again.
;;;1424       //
;;;1425       if(!ulInt)
000014  2800              CMP      r0,#0
000016  d104              BNE      |L5.34|
;;;1426       {
;;;1427           MAP_IntMasterEnable();
000018  6ca0              LDR      r0,[r4,#0x48]
00001a  6840              LDR      r0,[r0,#4]
00001c  e8bd4010          POP      {r4,lr}
000020  4700              BX       r0
                  |L5.34|
;;;1428       }
;;;1429   }
000022  bd10              POP      {r4,pc}
;;;1430   #endif
                          ENDP

                  |L5.36|
                          DCD      ||.data||

                          AREA ||i.UARTFlushTx||, CODE, READONLY, ALIGN=2

                  UARTFlushTx PROC
;;;1449   void
;;;1450   UARTFlushTx(tBoolean bDiscard)
000000  b510              PUSH     {r4,lr}
;;;1451   {
;;;1452       unsigned long ulInt;
;;;1453   
;;;1454       //
;;;1455       // Should the remaining data be discarded or transmitted?
;;;1456       //
;;;1457       if(bDiscard)
000002  b178              CBZ      r0,|L6.36|
;;;1458       {
;;;1459           //
;;;1460           // The remaining data should be discarded, so temporarily turn off
;;;1461           // interrupts.
;;;1462           //
;;;1463           ulInt = MAP_IntMasterDisable();
000004  f04f7480          MOV      r4,#0x1000000
000008  6ca0              LDR      r0,[r4,#0x48]
00000a  6880              LDR      r0,[r0,#8]
00000c  4780              BLX      r0
;;;1464   
;;;1465           //
;;;1466           // Flush the transmit buffer.
;;;1467           //
;;;1468           g_ulUARTTxReadIndex = 0;
00000e  4909              LDR      r1,|L6.52|
000010  2200              MOVS     r2,#0
000012  608a              STR      r2,[r1,#8]  ; g_ulUARTTxReadIndex
;;;1469           g_ulUARTTxWriteIndex = 0;
000014  604a              STR      r2,[r1,#4]  ; g_ulUARTTxWriteIndex
;;;1470   
;;;1471           //
;;;1472           // If interrupts were enabled when we turned them off, turn them
;;;1473           // back on again.
;;;1474           //
;;;1475           if(!ulInt)
000016  2800              CMP      r0,#0
000018  d10b              BNE      |L6.50|
;;;1476           {
;;;1477               MAP_IntMasterEnable();
00001a  6ca0              LDR      r0,[r4,#0x48]
00001c  6840              LDR      r0,[r0,#4]
00001e  e8bd4010          POP      {r4,lr}
000022  4700              BX       r0
                  |L6.36|
;;;1478           }
;;;1479       }
;;;1480       else
;;;1481       {
;;;1482           //
;;;1483           // Wait for all remaining data to be transmitted before returning.
;;;1484           //
;;;1485           while(!TX_BUFFER_EMPTY)
000024  4903              LDR      r1,|L6.52|
000026  1d09              ADDS     r1,r1,#4
000028  1d08              ADDS     r0,r1,#4
00002a  f7fffffe          BL       IsBufferEmpty
00002e  2800              CMP      r0,#0
000030  d0f8              BEQ      |L6.36|
                  |L6.50|
;;;1486           {
;;;1487           }
;;;1488       }
;;;1489   }
000032  bd10              POP      {r4,pc}
;;;1490   #endif
                          ENDP

                  |L6.52|
                          DCD      ||.data||

                          AREA ||i.UARTPeek||, CODE, READONLY, ALIGN=2

                  UARTPeek PROC
;;;1351   int
;;;1352   UARTPeek(unsigned char ucChar)
000000  b570              PUSH     {r4-r6,lr}
;;;1353   {
;;;1354       int iCount;
;;;1355       int iAvail;
;;;1356       unsigned long ulReadIndex;
;;;1357   
;;;1358       //
;;;1359       // How many characters are there in the receive buffer?
;;;1360       //
;;;1361       iAvail = (int)RX_BUFFER_USED;
000002  490c              LDR      r1,|L7.52|
000004  4604              MOV      r4,r0                 ;1353
000006  2280              MOVS     r2,#0x80
000008  1d08              ADDS     r0,r1,#4
00000a  f7fffffe          BL       GetBufferCount
00000e  4603              MOV      r3,r0
;;;1362       ulReadIndex = g_ulUARTRxReadIndex;
000010  4808              LDR      r0,|L7.52|
000012  380c              SUBS     r0,r0,#0xc
000014  6901              LDR      r1,[r0,#0x10]  ; g_ulUARTRxReadIndex
;;;1363   
;;;1364       //
;;;1365       // Check all the unread characters looking for the one passed.
;;;1366       //
;;;1367       for(iCount = 0; iCount < iAvail; iCount++)
000016  2000              MOVS     r0,#0
;;;1368       {
;;;1369           if(g_pcUARTRxBuffer[ulReadIndex] == ucChar)
000018  4a07              LDR      r2,|L7.56|
00001a  e006              B        |L7.42|
                  |L7.28|
00001c  5c55              LDRB     r5,[r2,r1]
00001e  42a5              CMP      r5,r4
000020  d007              BEQ      |L7.50|
;;;1370           {
;;;1371               //
;;;1372               // We found it so return the index
;;;1373               //
;;;1374               return(iCount);
;;;1375           }
;;;1376           else
;;;1377           {
;;;1378               //
;;;1379               // This one didn't match so move on to the next character.
;;;1380               //
;;;1381               ADVANCE_RX_BUFFER_INDEX(ulReadIndex);
000022  1c49              ADDS     r1,r1,#1
000024  f001017f          AND      r1,r1,#0x7f
000028  1c40              ADDS     r0,r0,#1              ;1367
                  |L7.42|
00002a  4298              CMP      r0,r3                 ;1367
00002c  dbf6              BLT      |L7.28|
;;;1382           }
;;;1383       }
;;;1384   
;;;1385       //
;;;1386       // If we drop out of the loop, we didn't find the character in the receive
;;;1387       // buffer.
;;;1388       //
;;;1389       return(-1);
00002e  f04f30ff          MOV      r0,#0xffffffff
                  |L7.50|
;;;1390   }
000032  bd70              POP      {r4-r6,pc}
;;;1391   #endif
                          ENDP

                  |L7.52|
                          DCD      ||.data||+0xc
                  |L7.56|
                          DCD      ||.bss||+0x400

                          AREA ||i.UARTPrimeTransmit||, CODE, READONLY, ALIGN=2

                  UARTPrimeTransmit PROC
;;;275    static void
;;;276    UARTPrimeTransmit(unsigned long ulBase)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;277    {
;;;278        //
;;;279        // Do we have any data to transmit?
;;;280        //
;;;281        if(!TX_BUFFER_EMPTY)
000004  4919              LDR      r1,|L8.108|
000006  4680              MOV      r8,r0                 ;277
000008  1d08              ADDS     r0,r1,#4
00000a  f7fffffe          BL       IsBufferEmpty
00000e  2800              CMP      r0,#0
000010  d12a              BNE      |L8.104|
;;;282        {
;;;283            //
;;;284            // Disable the UART interrupt. If we don't do this there is a race
;;;285            // condition which can cause the read index to be corrupted.
;;;286            //
;;;287            MAP_IntDisable(g_ulUARTInt[g_ulPortNum]);
000012  4c16              LDR      r4,|L8.108|
000014  f04f7580          MOV      r5,#0x1000000
000018  1f24              SUBS     r4,r4,#4
00001a  6ca9              LDR      r1,[r5,#0x48]
00001c  4e14              LDR      r6,|L8.112|
00001e  69a0              LDR      r0,[r4,#0x18]  ; g_ulPortNum
000020  68c9              LDR      r1,[r1,#0xc]
000022  f8560020          LDR      r0,[r6,r0,LSL #2]
000026  4788              BLX      r1
;;;288    
;;;289            //
;;;290            // Yes - take some characters out of the transmit buffer and feed
;;;291            // them to the UART transmit FIFO.
;;;292            //
;;;293            while(MAP_UARTSpaceAvail(ulBase) && !TX_BUFFER_EMPTY)
;;;294            {
;;;295                MAP_UARTCharPutNonBlocking(ulBase,
000028  4f12              LDR      r7,|L8.116|
;;;296                                           g_pcUARTTxBuffer[g_ulUARTTxReadIndex]);
;;;297                ADVANCE_TX_BUFFER_INDEX(g_ulUARTTxReadIndex);
00002a  e00a              B        |L8.66|
                  |L8.44|
00002c  68a0              LDR      r0,[r4,#8]            ;295  ; g_ulUARTTxReadIndex
00002e  5c39              LDRB     r1,[r7,r0]            ;295
000030  6968              LDR      r0,[r5,#0x14]         ;295
000032  6bc2              LDR      r2,[r0,#0x3c]         ;295
000034  4640              MOV      r0,r8                 ;295
000036  4790              BLX      r2                    ;295
000038  68a0              LDR      r0,[r4,#8]  ; g_ulUARTTxReadIndex
00003a  1c40              ADDS     r0,r0,#1
00003c  f3c00009          UBFX     r0,r0,#0,#10
000040  60a0              STR      r0,[r4,#8]  ; g_ulUARTTxReadIndex
                  |L8.66|
000042  6968              LDR      r0,[r5,#0x14]         ;293
000044  6b01              LDR      r1,[r0,#0x30]         ;293
000046  4640              MOV      r0,r8                 ;293
000048  4788              BLX      r1                    ;293
00004a  b128              CBZ      r0,|L8.88|
00004c  4907              LDR      r1,|L8.108|
00004e  1d08              ADDS     r0,r1,#4              ;293
000050  f7fffffe          BL       IsBufferEmpty
000054  2800              CMP      r0,#0                 ;293
000056  d0e9              BEQ      |L8.44|
                  |L8.88|
;;;298            }
;;;299    
;;;300            //
;;;301            // Reenable the UART interrupt.
;;;302            //
;;;303            MAP_IntEnable(g_ulUARTInt[g_ulPortNum]);
000058  69a0              LDR      r0,[r4,#0x18]  ; g_ulPortNum
00005a  6ca9              LDR      r1,[r5,#0x48]
00005c  f8560020          LDR      r0,[r6,r0,LSL #2]
000060  6809              LDR      r1,[r1,#0]
000062  e8bd41f0          POP      {r4-r8,lr}
000066  4708              BX       r1
                  |L8.104|
;;;304        }
;;;305    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;306    #endif
                          ENDP

                  |L8.108|
                          DCD      ||.data||+0x4
                  |L8.112|
                          DCD      ||.constdata||+0x10
                  |L8.116|
                          DCD      ||.bss||

                          AREA ||i.UARTRxBytesAvail||, CODE, READONLY, ALIGN=2

                  UARTRxBytesAvail PROC
;;;1305   int
;;;1306   UARTRxBytesAvail(void)
000000  4902              LDR      r1,|L9.12|
;;;1307   {
;;;1308       return(RX_BUFFER_USED);
000002  2280              MOVS     r2,#0x80
000004  1d08              ADDS     r0,r1,#4
000006  f7ffbffe          B.W      GetBufferCount
;;;1309   }
;;;1310   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      ||.data||+0xc

                          AREA ||i.UARTStdioInit||, CODE, READONLY, ALIGN=1

                  UARTStdioInit PROC
;;;331    void
;;;332    UARTStdioInit(unsigned long ulPortNum)
000000  f44f31e1          MOV      r1,#0x1c200
;;;333    {
;;;334        //
;;;335        // Pass this call on to the version of the function allowing the baud rate
;;;336        // to be specified.
;;;337        //
;;;338        UARTStdioInitExpClk(ulPortNum, 115200);
000004  f7ffbffe          B.W      UARTStdioInitExpClk
;;;339    }
;;;340    
                          ENDP


                          AREA ||i.UARTStdioInitExpClk||, CODE, READONLY, ALIGN=2

                  UARTStdioInitExpClk PROC
;;;366    void
;;;367    UARTStdioInitExpClk(unsigned long ulPortNum, unsigned long ulBaud)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;368    {
;;;369        //
;;;370        // Check the arguments.
;;;371        //
;;;372        ASSERT((ulPortNum == 0) || (ulPortNum == 1) ||
;;;373               (ulPortNum == 2));
;;;374    
;;;375    #ifdef UART_BUFFERED
;;;376        //
;;;377        // In buffered mode, we only allow a single instance to be opened.
;;;378        //
;;;379        ASSERT(g_ulBase == 0);
;;;380    #endif
;;;381    
;;;382        //
;;;383        // Check to make sure the UART peripheral is present.
;;;384        //
;;;385        if(!MAP_SysCtlPeripheralPresent(g_ulUARTPeriph[ulPortNum]))
000004  f04f7580          MOV      r5,#0x1000000
000008  4688              MOV      r8,r1                 ;368
00000a  6c69              LDR      r1,[r5,#0x44]
00000c  4f21              LDR      r7,|L11.148|
00000e  4604              MOV      r4,r0                 ;368
000010  6909              LDR      r1,[r1,#0x10]
000012  f8570024          LDR      r0,[r7,r4,LSL #2]
000016  4788              BLX      r1
000018  2800              CMP      r0,#0
00001a  d038              BEQ      |L11.142|
;;;386        {
;;;387            return;
;;;388        }
;;;389    
;;;390        //
;;;391        // Select the base address of the UART.
;;;392        //
;;;393        g_ulBase = g_ulUARTBase[ulPortNum];
00001c  f1a70018          SUB      r0,r7,#0x18
000020  4e1d              LDR      r6,|L11.152|
000022  f8500024          LDR      r0,[r0,r4,LSL #2]
;;;394    
;;;395        //
;;;396        // Enable the UART peripheral for use.
;;;397        //
;;;398        MAP_SysCtlPeripheralEnable(g_ulUARTPeriph[ulPortNum]);
000026  6170              STR      r0,[r6,#0x14]  ; g_ulBase
000028  6c69              LDR      r1,[r5,#0x44]
00002a  f8570024          LDR      r0,[r7,r4,LSL #2]
00002e  6989              LDR      r1,[r1,#0x18]
000030  4788              BLX      r1
;;;399    
;;;400        //
;;;401        // Configure the UART for 115200, n, 8, 1
;;;402        //
;;;403        MAP_UARTConfigSetExpClk(g_ulBase, MAP_SysCtlClockGet(), ulBaud,
000032  6c68              LDR      r0,[r5,#0x44]
000034  6e00              LDR      r0,[r0,#0x60]
000036  4780              BLX      r0
000038  4601              MOV      r1,r0
00003a  6968              LDR      r0,[r5,#0x14]
00003c  2360              MOVS     r3,#0x60
00003e  4642              MOV      r2,r8
000040  6947              LDR      r7,[r0,#0x14]
000042  6970              LDR      r0,[r6,#0x14]  ; g_ulBase
000044  47b8              BLX      r7
;;;404                                (UART_CONFIG_PAR_NONE | UART_CONFIG_STOP_ONE |
;;;405                                 UART_CONFIG_WLEN_8));
;;;406    
;;;407    #ifdef UART_BUFFERED
;;;408        //
;;;409        // Set the UART to interrupt whenever the TX FIFO is almost empty or
;;;410        // when any character is received.
;;;411        //
;;;412        MAP_UARTFIFOLevelSet(g_ulBase, UART_FIFO_TX1_8, UART_FIFO_RX1_8);
000046  6968              LDR      r0,[r5,#0x14]
000048  2200              MOVS     r2,#0
00004a  4611              MOV      r1,r2
00004c  68c3              LDR      r3,[r0,#0xc]
00004e  6970              LDR      r0,[r6,#0x14]  ; g_ulBase
000050  4798              BLX      r3
;;;413    
;;;414        //
;;;415        // Flush both the buffers.
;;;416        //
;;;417        UARTFlushRx();
000052  f7fffffe          BL       UARTFlushRx
;;;418        UARTFlushTx(true);
000056  2001              MOVS     r0,#1
000058  f7fffffe          BL       UARTFlushTx
;;;419    
;;;420        //
;;;421        // Remember which interrupt we are dealing with.
;;;422        //
;;;423        g_ulPortNum = ulPortNum;
;;;424    
;;;425        //
;;;426        // We are configured for buffered output so enable the master interrupt
;;;427        // for this UART and the receive interrupts.  We don't actually enable the
;;;428        // transmit interrupt in the UART itself until some data has been placed
;;;429        // in the transmit buffer.
;;;430        //
;;;431        MAP_UARTIntDisable(g_ulBase, 0xFFFFFFFF);
00005c  61b4              STR      r4,[r6,#0x18]  ; g_ulPortNum
00005e  6968              LDR      r0,[r5,#0x14]
000060  f04f31ff          MOV      r1,#0xffffffff
000064  6c82              LDR      r2,[r0,#0x48]
000066  6970              LDR      r0,[r6,#0x14]  ; g_ulBase
000068  4790              BLX      r2
;;;432        MAP_UARTIntEnable(g_ulBase, UART_INT_RX | UART_INT_RT);
00006a  6968              LDR      r0,[r5,#0x14]
00006c  2150              MOVS     r1,#0x50
00006e  6c42              LDR      r2,[r0,#0x44]
000070  6970              LDR      r0,[r6,#0x14]  ; g_ulBase
000072  4790              BLX      r2
;;;433        MAP_IntEnable(g_ulUARTInt[ulPortNum]);
000074  4807              LDR      r0,|L11.148|
000076  6ca9              LDR      r1,[r5,#0x48]
000078  380c              SUBS     r0,r0,#0xc
00007a  6809              LDR      r1,[r1,#0]
00007c  f8500024          LDR      r0,[r0,r4,LSL #2]
000080  4788              BLX      r1
;;;434    #endif
;;;435    
;;;436        //
;;;437        // Enable the UART operation.
;;;438        //
;;;439        MAP_UARTEnable(g_ulBase);
000082  6968              LDR      r0,[r5,#0x14]
000084  69c1              LDR      r1,[r0,#0x1c]
000086  6970              LDR      r0,[r6,#0x14]  ; g_ulBase
000088  e8bd41f0          POP      {r4-r8,lr}
00008c  4708              BX       r1
                  |L11.142|
;;;440    }
00008e  e8bd81f0          POP      {r4-r8,pc}
;;;441    
                          ENDP

000092  0000              DCW      0x0000
                  |L11.148|
                          DCD      ||.constdata||+0x1c
                  |L11.152|
                          DCD      ||.data||

                          AREA ||i.UARTStdioIntHandler||, CODE, READONLY, ALIGN=2

                  UARTStdioIntHandler PROC
;;;1533   void
;;;1534   UARTStdioIntHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1535   {
;;;1536       unsigned long ulInts;
;;;1537       char cChar;
;;;1538       long lChar;
;;;1539       static tBoolean bLastWasCR = false;
;;;1540   
;;;1541       //
;;;1542       // Get and clear the current interrupt source(s)
;;;1543       //
;;;1544       ulInts = MAP_UARTIntStatus(g_ulBase, true);
000002  f04f7680          MOV      r6,#0x1000000
000006  4d3b              LDR      r5,|L12.244|
000008  6970              LDR      r0,[r6,#0x14]
00000a  2101              MOVS     r1,#1
00000c  6cc2              LDR      r2,[r0,#0x4c]
00000e  6968              LDR      r0,[r5,#0x14]  ; g_ulBase
000010  4790              BLX      r2
000012  4604              MOV      r4,r0
;;;1545       MAP_UARTIntClear(g_ulBase, ulInts);
000014  6970              LDR      r0,[r6,#0x14]
000016  4621              MOV      r1,r4
000018  6d02              LDR      r2,[r0,#0x50]
00001a  6968              LDR      r0,[r5,#0x14]  ; g_ulBase
00001c  4790              BLX      r2
;;;1546   
;;;1547       //
;;;1548       // Are we being interrupted because the TX FIFO has space available?
;;;1549       //
;;;1550       if(ulInts & UART_INT_TX)
00001e  06a0              LSLS     r0,r4,#26
000020  d50c              BPL      |L12.60|
;;;1551       {
;;;1552           //
;;;1553           // Move as many bytes as we can into the transmit FIFO.
;;;1554           //
;;;1555           UARTPrimeTransmit(g_ulBase);
000022  6968              LDR      r0,[r5,#0x14]  ; g_ulBase
000024  f7fffffe          BL       UARTPrimeTransmit
;;;1556   
;;;1557           //
;;;1558           // If the output buffer is empty, turn off the transmit interrupt.
;;;1559           //
;;;1560           if(TX_BUFFER_EMPTY)
000028  1d29              ADDS     r1,r5,#4
00002a  1d08              ADDS     r0,r1,#4
00002c  f7fffffe          BL       IsBufferEmpty
000030  b120              CBZ      r0,|L12.60|
;;;1561           {
;;;1562               MAP_UARTIntDisable(g_ulBase, UART_INT_TX);
000032  6970              LDR      r0,[r6,#0x14]
000034  2120              MOVS     r1,#0x20
000036  6c82              LDR      r2,[r0,#0x48]
000038  6968              LDR      r0,[r5,#0x14]  ; g_ulBase
00003a  4790              BLX      r2
                  |L12.60|
;;;1563           }
;;;1564       }
;;;1565   
;;;1566       //
;;;1567       // Are we being interrupted due to a received character?
;;;1568       //
;;;1569       if(ulInts & (UART_INT_RX | UART_INT_RT))
00003c  f0140f50          TST      r4,#0x50
000040  d149              BNE      |L12.214|
;;;1570       {
;;;1571           //
;;;1572           // Get all the available characters from the UART.
;;;1573           //
;;;1574           while(MAP_UARTCharsAvail(g_ulBase))
;;;1575           {
;;;1576               //
;;;1577               // Read a character
;;;1578               //
;;;1579               lChar = MAP_UARTCharGetNonBlocking(g_ulBase);
;;;1580               cChar = (unsigned char)(lChar & 0xFF);
;;;1581   
;;;1582               //
;;;1583               // If echo is disabled, we skip the various text filtering
;;;1584               // operations that would typically be required when supporting a
;;;1585               // command line.
;;;1586               //
;;;1587               if(!g_bDisableEcho)
;;;1588               {
;;;1589                   //
;;;1590                   // Handle backspace by erasing the last character in the buffer.
;;;1591                   //
;;;1592                   if(cChar == '\b')
;;;1593                   {
;;;1594                       //
;;;1595                       // If there are any characters already in the buffer, then
;;;1596                       // delete the last.
;;;1597                       //
;;;1598                       if(!RX_BUFFER_EMPTY)
;;;1599                       {
;;;1600                           //
;;;1601                           // Rub out the previous character on the users terminal.
;;;1602                           //
;;;1603                           UARTwrite("\b \b", 3);
;;;1604   
;;;1605                           //
;;;1606                           // Decrement the number of characters in the buffer.
;;;1607                           //
;;;1608                           if(g_ulUARTRxWriteIndex == 0)
;;;1609                           {
;;;1610                               g_ulUARTRxWriteIndex = UART_RX_BUFFER_SIZE - 1;
;;;1611                           }
;;;1612                           else
;;;1613                           {
;;;1614                               g_ulUARTRxWriteIndex--;
;;;1615                           }
;;;1616                       }
;;;1617   
;;;1618                       //
;;;1619                       // Skip ahead to read the next character.
;;;1620                       //
;;;1621                       continue;
;;;1622                   }
;;;1623   
;;;1624                   //
;;;1625                   // If this character is LF and last was CR, then just gobble up
;;;1626                   // the character since we already echoed the previous CR and we
;;;1627                   // don't want to store 2 characters in the buffer if we don't
;;;1628                   // need to.
;;;1629                   //
;;;1630                   if((cChar == '\n') && bLastWasCR)
;;;1631                   {
;;;1632                       bLastWasCR = false;
;;;1633                       continue;
;;;1634                   }
;;;1635   
;;;1636                   //
;;;1637                   // See if a newline or escape character was received.
;;;1638                   //
;;;1639                   if((cChar == '\r') || (cChar == '\n') || (cChar == 0x1b))
;;;1640                   {
;;;1641                       //
;;;1642                       // If the character is a CR, then it may be followed by an
;;;1643                       // LF which should be paired with the CR.  So remember that
;;;1644                       // a CR was received.
;;;1645                       //
;;;1646                       if(cChar == '\r')
;;;1647                       {
;;;1648                           bLastWasCR = 1;
;;;1649                       }
;;;1650   
;;;1651                       //
;;;1652                       // Regardless of the line termination character received,
;;;1653                       // put a CR in the receive buffer as a marker telling
;;;1654                       // UARTgets() where the line ends.  We also send an
;;;1655                       // additional LF to ensure that the local terminal echo
;;;1656                       // receives both CR and LF.
;;;1657                       //
;;;1658                       cChar = '\r';
;;;1659                       UARTwrite("\n", 1);
;;;1660                   }
;;;1661               }
;;;1662   
;;;1663               //
;;;1664               // If there is space in the receive buffer, put the character
;;;1665               // there, otherwise throw it away.
;;;1666               //
;;;1667               if(!RX_BUFFER_FULL)
;;;1668               {
;;;1669                   //
;;;1670                   // Store the new character in the receive buffer
;;;1671                   //
;;;1672                   g_pcUARTRxBuffer[g_ulUARTRxWriteIndex] =
;;;1673                       (unsigned char)(lChar & 0xFF);
;;;1674                   ADVANCE_RX_BUFFER_INDEX(g_ulUARTRxWriteIndex);
;;;1675   
;;;1676                   //
;;;1677                   // If echo is enabled, write the character to the transmit
;;;1678                   // buffer so that the user gets some immediate feedback.
;;;1679                   //
;;;1680                   if(!g_bDisableEcho)
;;;1681                   {
;;;1682                       UARTwrite(&cChar, 1);
;;;1683                   }
;;;1684               }
;;;1685           }
;;;1686   
;;;1687           //
;;;1688           // If we wrote anything to the transmit buffer, make sure it actually
;;;1689           // gets transmitted.
;;;1690           //
;;;1691           UARTPrimeTransmit(g_ulBase);
;;;1692           MAP_UARTIntEnable(g_ulBase, UART_INT_TX);
;;;1693       }
;;;1694   }
000042  bdf8              POP      {r3-r7,pc}
                  |L12.68|
000044  6970              LDR      r0,[r6,#0x14]         ;1579
000046  6b41              LDR      r1,[r0,#0x34]         ;1579
000048  6968              LDR      r0,[r5,#0x14]         ;1579  ; g_ulBase
00004a  4788              BLX      r1                    ;1579
00004c  b2c4              UXTB     r4,r0                 ;1580
00004e  f88d4000          STRB     r4,[sp,#0]            ;1580
000052  7868              LDRB     r0,[r5,#1]            ;1587  ; g_bDisableEcho
000054  bb50              CBNZ     r0,|L12.172|
000056  2c08              CMP      r4,#8                 ;1592
000058  d008              BEQ      |L12.108|
00005a  2c0a              CMP      r4,#0xa               ;1630
00005c  d018              BEQ      |L12.144|
00005e  2c0d              CMP      r4,#0xd               ;1639
000060  d01b              BEQ      |L12.154|
000062  2c0a              CMP      r4,#0xa               ;1639
000064  d01b              BEQ      |L12.158|
000066  2c1b              CMP      r4,#0x1b              ;1639
000068  d019              BEQ      |L12.158|
00006a  e01f              B        |L12.172|
                  |L12.108|
00006c  4921              LDR      r1,|L12.244|
00006e  310c              ADDS     r1,r1,#0xc            ;1598
000070  1d08              ADDS     r0,r1,#4              ;1598
000072  f7fffffe          BL       IsBufferEmpty
000076  bb70              CBNZ     r0,|L12.214|
000078  2103              MOVS     r1,#3                 ;1603
00007a  a01f              ADR      r0,|L12.248|
00007c  f7fffffe          BL       UARTwrite
000080  68e8              LDR      r0,[r5,#0xc]          ;1608  ; g_ulUARTRxWriteIndex
000082  b118              CBZ      r0,|L12.140|
000084  68e8              LDR      r0,[r5,#0xc]          ;1614  ; g_ulUARTRxWriteIndex
000086  1e40              SUBS     r0,r0,#1              ;1614
                  |L12.136|
000088  60e8              STR      r0,[r5,#0xc]          ;1614  ; g_ulUARTRxWriteIndex
00008a  e024              B        |L12.214|
                  |L12.140|
00008c  207f              MOVS     r0,#0x7f              ;1610
00008e  e7fb              B        |L12.136|
                  |L12.144|
000090  7828              LDRB     r0,[r5,#0]            ;1630  ; bLastWasCR
000092  b120              CBZ      r0,|L12.158|
000094  2000              MOVS     r0,#0                 ;1632
000096  7028              STRB     r0,[r5,#0]            ;1632
000098  e01d              B        |L12.214|
                  |L12.154|
00009a  2001              MOVS     r0,#1                 ;1648
00009c  7028              STRB     r0,[r5,#0]            ;1648
                  |L12.158|
00009e  200d              MOVS     r0,#0xd               ;1658
0000a0  f88d0000          STRB     r0,[sp,#0]            ;1658
0000a4  2101              MOVS     r1,#1                 ;1659
0000a6  a015              ADR      r0,|L12.252|
0000a8  f7fffffe          BL       UARTwrite
                  |L12.172|
0000ac  4911              LDR      r1,|L12.244|
0000ae  2280              MOVS     r2,#0x80              ;1667
0000b0  310c              ADDS     r1,r1,#0xc            ;1667
0000b2  1d08              ADDS     r0,r1,#4              ;1667
0000b4  f7fffffe          BL       IsBufferFull
0000b8  b968              CBNZ     r0,|L12.214|
0000ba  4811              LDR      r0,|L12.256|
0000bc  68e9              LDR      r1,[r5,#0xc]          ;1672  ; g_ulUARTRxWriteIndex
0000be  5444              STRB     r4,[r0,r1]            ;1672
0000c0  68e8              LDR      r0,[r5,#0xc]          ;1674  ; g_ulUARTRxWriteIndex
0000c2  1c40              ADDS     r0,r0,#1              ;1674
0000c4  f000007f          AND      r0,r0,#0x7f           ;1674
0000c8  60e8              STR      r0,[r5,#0xc]          ;1674  ; g_ulUARTRxWriteIndex
0000ca  7868              LDRB     r0,[r5,#1]            ;1680  ; g_bDisableEcho
0000cc  b918              CBNZ     r0,|L12.214|
0000ce  2101              MOVS     r1,#1                 ;1682
0000d0  4668              MOV      r0,sp                 ;1682
0000d2  f7fffffe          BL       UARTwrite
                  |L12.214|
0000d6  6970              LDR      r0,[r6,#0x14]         ;1574
0000d8  6ac1              LDR      r1,[r0,#0x2c]         ;1574
0000da  6968              LDR      r0,[r5,#0x14]         ;1574  ; g_ulBase
0000dc  4788              BLX      r1                    ;1574
0000de  2800              CMP      r0,#0                 ;1574
0000e0  d1b0              BNE      |L12.68|
0000e2  6968              LDR      r0,[r5,#0x14]         ;1691  ; g_ulBase
0000e4  f7fffffe          BL       UARTPrimeTransmit
0000e8  6970              LDR      r0,[r6,#0x14]         ;1692
0000ea  2120              MOVS     r1,#0x20              ;1692
0000ec  6c42              LDR      r2,[r0,#0x44]         ;1692
0000ee  6968              LDR      r0,[r5,#0x14]         ;1692  ; g_ulBase
0000f0  4790              BLX      r2                    ;1692
0000f2  bdf8              POP      {r3-r7,pc}
;;;1695   #endif
                          ENDP

                  |L12.244|
                          DCD      ||.data||
                  |L12.248|
0000f8  08200800          DCB      "\b \b",0
                  |L12.252|
0000fc  0a00              DCB      "\n",0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L12.256|
                          DCD      ||.bss||+0x400

                          AREA ||i.UARTTxBytesFree||, CODE, READONLY, ALIGN=2

                  UARTTxBytesFree PROC
;;;1324   int
;;;1325   UARTTxBytesFree(void)
000000  4904              LDR      r1,|L13.20|
;;;1326   {
000002  b510              PUSH     {r4,lr}
;;;1327       return(TX_BUFFER_FREE);
000004  f44f6280          MOV      r2,#0x400
000008  1d08              ADDS     r0,r1,#4
00000a  f7fffffe          BL       GetBufferCount
00000e  f5c06080          RSB      r0,r0,#0x400
;;;1328   }
000012  bd10              POP      {r4,pc}
;;;1329   #endif
                          ENDP

                  |L13.20|
                          DCD      ||.data||+0x4

                          AREA ||i.UARTgetc||, CODE, READONLY, ALIGN=2

                  UARTgetc PROC
;;;818    unsigned char
;;;819    UARTgetc(void)
000000  b510              PUSH     {r4,lr}
                  |L14.2|
;;;820    {
;;;821    #ifdef UART_BUFFERED
;;;822        unsigned char cChar;
;;;823    
;;;824        //
;;;825        // Wait for a character to be received.
;;;826        //
;;;827        while(RX_BUFFER_EMPTY)
000002  4908              LDR      r1,|L14.36|
000004  1d08              ADDS     r0,r1,#4
000006  f7fffffe          BL       IsBufferEmpty
00000a  2800              CMP      r0,#0
00000c  d1f9              BNE      |L14.2|
;;;828        {
;;;829            //
;;;830            // Block waiting for a character to be received (if the buffer is
;;;831            // currently empty).
;;;832            //
;;;833        }
;;;834    
;;;835        //
;;;836        // Read a character from the buffer.
;;;837        //
;;;838        cChar = g_pcUARTRxBuffer[g_ulUARTRxReadIndex];
00000e  4905              LDR      r1,|L14.36|
000010  4805              LDR      r0,|L14.40|
000012  390c              SUBS     r1,r1,#0xc
000014  690a              LDR      r2,[r1,#0x10]  ; g_ulUARTRxReadIndex
000016  5c80              LDRB     r0,[r0,r2]
;;;839        ADVANCE_RX_BUFFER_INDEX(g_ulUARTRxReadIndex);
000018  690a              LDR      r2,[r1,#0x10]  ; g_ulUARTRxReadIndex
00001a  1c52              ADDS     r2,r2,#1
00001c  f002027f          AND      r2,r2,#0x7f
000020  610a              STR      r2,[r1,#0x10]  ; g_ulUARTRxReadIndex
;;;840    
;;;841        //
;;;842        // Return the character to the caller.
;;;843        //
;;;844        return(cChar);
;;;845    #else
;;;846        //
;;;847        // Block until a character is received by the UART then return it to
;;;848        // the caller.
;;;849        //
;;;850        return(MAP_UARTCharGet(g_ulBase));
;;;851    #endif
;;;852    }
000022  bd10              POP      {r4,pc}
;;;853    
                          ENDP

                  |L14.36|
                          DCD      ||.data||+0xc
                  |L14.40|
                          DCD      ||.bss||+0x400

                          AREA ||i.UARTgets||, CODE, READONLY, ALIGN=2

                  UARTgets PROC
;;;601    int
;;;602    UARTgets(char *pcBuf, unsigned long ulLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;603    {
;;;604    #ifdef UART_BUFFERED
;;;605        unsigned long ulCount = 0;
000004  2400              MOVS     r4,#0
;;;606        char cChar;
;;;607    
;;;608        //
;;;609        // Check the arguments.
;;;610        //
;;;611        ASSERT(pcBuf != 0);
;;;612        ASSERT(ulLen != 0);
;;;613        ASSERT(g_ulBase != 0);
;;;614    
;;;615        //
;;;616        // Adjust the length back by 1 to leave space for the trailing
;;;617        // null terminator.
;;;618        //
;;;619        ulLen--;
;;;620    
;;;621        //
;;;622        // Process characters until a newline is received.
;;;623        //
;;;624        while(1)
;;;625        {
;;;626            //
;;;627            // Read the next character from the receive buffer.
;;;628            //
;;;629            if(!RX_BUFFER_EMPTY)
;;;630            {
;;;631                cChar = g_pcUARTRxBuffer[g_ulUARTRxReadIndex];
000006  f8df8048          LDR      r8,|L15.80|
00000a  4f12              LDR      r7,|L15.84|
00000c  4606              MOV      r6,r0                 ;603
00000e  1e4d              SUBS     r5,r1,#1              ;619
                  |L15.16|
000010  4910              LDR      r1,|L15.84|
000012  310c              ADDS     r1,r1,#0xc            ;629
000014  1d08              ADDS     r0,r1,#4              ;629
000016  f7fffffe          BL       IsBufferEmpty
00001a  2800              CMP      r0,#0                 ;629
00001c  d1f8              BNE      |L15.16|
00001e  6939              LDR      r1,[r7,#0x10]  ; g_ulUARTRxReadIndex
000020  f8180001          LDRB     r0,[r8,r1]
;;;632                ADVANCE_RX_BUFFER_INDEX(g_ulUARTRxReadIndex);
000024  6939              LDR      r1,[r7,#0x10]  ; g_ulUARTRxReadIndex
000026  1c49              ADDS     r1,r1,#1
000028  f001017f          AND      r1,r1,#0x7f
00002c  6139              STR      r1,[r7,#0x10]  ; g_ulUARTRxReadIndex
;;;633    
;;;634                //
;;;635                // See if a newline or escape character was received.
;;;636                //
;;;637                if((cChar == '\r') || (cChar == '\n') || (cChar == 0x1b))
00002e  280d              CMP      r0,#0xd
000030  d008              BEQ      |L15.68|
000032  280a              CMP      r0,#0xa
000034  d006              BEQ      |L15.68|
000036  281b              CMP      r0,#0x1b
000038  d004              BEQ      |L15.68|
;;;638                {
;;;639                    //
;;;640                    // Stop processing the input and end the line.
;;;641                    //
;;;642                    break;
;;;643                }
;;;644    
;;;645                //
;;;646                // Process the received character as long as we are not at the end
;;;647                // of the buffer.  If the end of the buffer has been reached then
;;;648                // all additional characters are ignored until a newline is
;;;649                // received.
;;;650                //
;;;651                if(ulCount < ulLen)
00003a  42ac              CMP      r4,r5
00003c  d2e8              BCS      |L15.16|
;;;652                {
;;;653                    //
;;;654                    // Store the character in the caller supplied buffer.
;;;655                    //
;;;656                    pcBuf[ulCount] = cChar;
00003e  5530              STRB     r0,[r6,r4]
;;;657    
;;;658                    //
;;;659                    // Increment the count of characters received.
;;;660                    //
;;;661                    ulCount++;
000040  1c64              ADDS     r4,r4,#1
000042  e7e5              B        |L15.16|
                  |L15.68|
;;;662                }
;;;663            }
;;;664        }
;;;665    
;;;666        //
;;;667        // Add a null termination to the string.
;;;668        //
;;;669        pcBuf[ulCount] = 0;
000044  2000              MOVS     r0,#0
000046  5530              STRB     r0,[r6,r4]
;;;670    
;;;671        //
;;;672        // Return the count of chars in the buffer, not counting the trailing 0.
;;;673        //
;;;674        return(ulCount);
000048  4620              MOV      r0,r4
;;;675    #else
;;;676        unsigned long ulCount = 0;
;;;677        char cChar;
;;;678        static char bLastWasCR = 0;
;;;679    
;;;680        //
;;;681        // Check the arguments.
;;;682        //
;;;683        ASSERT(pcBuf != 0);
;;;684        ASSERT(ulLen != 0);
;;;685        ASSERT(g_ulBase != 0);
;;;686    
;;;687        //
;;;688        // Adjust the length back by 1 to leave space for the trailing
;;;689        // null terminator.
;;;690        //
;;;691        ulLen--;
;;;692    
;;;693        //
;;;694        // Process characters until a newline is received.
;;;695        //
;;;696        while(1)
;;;697        {
;;;698            //
;;;699            // Read the next character from the console.
;;;700            //
;;;701            cChar = MAP_UARTCharGet(g_ulBase);
;;;702    
;;;703            //
;;;704            // See if the backspace key was pressed.
;;;705            //
;;;706            if(cChar == '\b')
;;;707            {
;;;708                //
;;;709                // If there are any characters already in the buffer, then delete
;;;710                // the last.
;;;711                //
;;;712                if(ulCount)
;;;713                {
;;;714                    //
;;;715                    // Rub out the previous character.
;;;716                    //
;;;717                    UARTwrite("\b \b", 3);
;;;718    
;;;719                    //
;;;720                    // Decrement the number of characters in the buffer.
;;;721                    //
;;;722                    ulCount--;
;;;723                }
;;;724    
;;;725                //
;;;726                // Skip ahead to read the next character.
;;;727                //
;;;728                continue;
;;;729            }
;;;730    
;;;731            //
;;;732            // If this character is LF and last was CR, then just gobble up the
;;;733            // character because the EOL processing was taken care of with the CR.
;;;734            //
;;;735            if((cChar == '\n') && bLastWasCR)
;;;736            {
;;;737                bLastWasCR = 0;
;;;738                continue;
;;;739            }
;;;740    
;;;741            //
;;;742            // See if a newline or escape character was received.
;;;743            //
;;;744            if((cChar == '\r') || (cChar == '\n') || (cChar == 0x1b))
;;;745            {
;;;746                //
;;;747                // If the character is a CR, then it may be followed by a LF which
;;;748                // should be paired with the CR.  So remember that a CR was
;;;749                // received.
;;;750                //
;;;751                if(cChar == '\r')
;;;752                {
;;;753                    bLastWasCR = 1;
;;;754                }
;;;755    
;;;756                //
;;;757                // Stop processing the input and end the line.
;;;758                //
;;;759                break;
;;;760            }
;;;761    
;;;762            //
;;;763            // Process the received character as long as we are not at the end of
;;;764            // the buffer.  If the end of the buffer has been reached then all
;;;765            // additional characters are ignored until a newline is received.
;;;766            //
;;;767            if(ulCount < ulLen)
;;;768            {
;;;769                //
;;;770                // Store the character in the caller supplied buffer.
;;;771                //
;;;772                pcBuf[ulCount] = cChar;
;;;773    
;;;774                //
;;;775                // Increment the count of characters received.
;;;776                //
;;;777                ulCount++;
;;;778    
;;;779                //
;;;780                // Reflect the character back to the user.
;;;781                //
;;;782                MAP_UARTCharPut(g_ulBase, cChar);
;;;783            }
;;;784        }
;;;785    
;;;786        //
;;;787        // Add a null termination to the string.
;;;788        //
;;;789        pcBuf[ulCount] = 0;
;;;790    
;;;791        //
;;;792        // Send a CRLF pair to the terminal to end the line.
;;;793        //
;;;794        UARTwrite("\r\n", 2);
;;;795    
;;;796        //
;;;797        // Return the count of chars in the buffer, not counting the trailing 0.
;;;798        //
;;;799        return(ulCount);
;;;800    #endif
;;;801    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;802    
                          ENDP

00004e  0000              DCW      0x0000
                  |L15.80|
                          DCD      ||.bss||+0x400
                  |L15.84|
                          DCD      ||.data||

                          AREA ||i.UARTprintf||, CODE, READONLY, ALIGN=2

                  UARTprintf PROC
;;;892    void
;;;893    UARTprintf(const char *pcString, ...)
000000  b40f              PUSH     {r0-r3}
;;;894    {
000002  e92d47f0          PUSH     {r4-r10,lr}
000006  b086              SUB      sp,sp,#0x18
;;;895        unsigned long ulIdx, ulValue, ulPos, ulCount, ulBase, ulNeg;
;;;896        char *pcStr, pcBuf[16], cFill;
;;;897        va_list vaArgP;
;;;898    
;;;899        //
;;;900        // Check the arguments.
;;;901        //
;;;902        ASSERT(pcString != 0);
;;;903    
;;;904        //
;;;905        // Start the varargs processing.
;;;906        //
;;;907        va_start(vaArgP, pcString);
000008  ad0f              ADD      r5,sp,#0x3c
;;;908    
;;;909        //
;;;910        // Loop while there are more characters in the string.
;;;911        //
;;;912        while(*pcString)
;;;913        {
;;;914            //
;;;915            // Find the first non-% character, or the end of the string.
;;;916            //
;;;917            for(ulIdx = 0; (pcString[ulIdx] != '%') && (pcString[ulIdx] != '\0');
;;;918                ulIdx++)
;;;919            {
;;;920            }
;;;921    
;;;922            //
;;;923            // Write this portion of the string.
;;;924            //
;;;925            UARTwrite(pcString, ulIdx);
;;;926    
;;;927            //
;;;928            // Skip the portion of the string that was written.
;;;929            //
;;;930            pcString += ulIdx;
;;;931    
;;;932            //
;;;933            // See if the next character is a %.
;;;934            //
;;;935            if(*pcString == '%')
;;;936            {
;;;937                //
;;;938                // Skip the %.
;;;939                //
;;;940                pcString++;
;;;941    
;;;942                //
;;;943                // Set the digit count to zero, and the fill character to space
;;;944                // (i.e. to the defaults).
;;;945                //
;;;946                ulCount = 0;
;;;947                cFill = ' ';
;;;948    
;;;949                //
;;;950                // It may be necessary to get back here to process more characters.
;;;951                // Goto's aren't pretty, but effective.  I feel extremely dirty for
;;;952                // using not one but two of the beasts.
;;;953                //
;;;954    again:
;;;955    
;;;956                //
;;;957                // Determine how to handle the next character.
;;;958                //
;;;959                switch(*pcString++)
;;;960                {
;;;961                    //
;;;962                    // Handle the digit characters.
;;;963                    //
;;;964                    case '0':
;;;965                    case '1':
;;;966                    case '2':
;;;967                    case '3':
;;;968                    case '4':
;;;969                    case '5':
;;;970                    case '6':
;;;971                    case '7':
;;;972                    case '8':
;;;973                    case '9':
;;;974                    {
;;;975                        //
;;;976                        // If this is a zero, and it is the first digit, then the
;;;977                        // fill character is a zero instead of a space.
;;;978                        //
;;;979                        if((pcString[-1] == '0') && (ulCount == 0))
;;;980                        {
;;;981                            cFill = '0';
;;;982                        }
;;;983    
;;;984                        //
;;;985                        // Update the digit count.
;;;986                        //
;;;987                        ulCount *= 10;
;;;988                        ulCount += pcString[-1] - '0';
;;;989    
;;;990                        //
;;;991                        // Get the next character.
;;;992                        //
;;;993                        goto again;
;;;994                    }
;;;995    
;;;996                    //
;;;997                    // Handle the %c command.
;;;998                    //
;;;999                    case 'c':
;;;1000                   {
;;;1001                       //
;;;1002                       // Get the value from the varargs.
;;;1003                       //
;;;1004                       ulValue = va_arg(vaArgP, unsigned long);
;;;1005   
;;;1006                       //
;;;1007                       // Print out the character.
;;;1008                       //
;;;1009                       UARTwrite((char *)&ulValue, 1);
;;;1010   
;;;1011                       //
;;;1012                       // This command has been handled.
;;;1013                       //
;;;1014                       break;
;;;1015                   }
;;;1016   
;;;1017                   //
;;;1018                   // Handle the %d command.
;;;1019                   //
;;;1020                   case 'd':
;;;1021                   {
;;;1022                       //
;;;1023                       // Get the value from the varargs.
;;;1024                       //
;;;1025                       ulValue = va_arg(vaArgP, unsigned long);
;;;1026   
;;;1027                       //
;;;1028                       // Reset the buffer position.
;;;1029                       //
;;;1030                       ulPos = 0;
;;;1031   
;;;1032                       //
;;;1033                       // If the value is negative, make it positive and indicate
;;;1034                       // that a minus sign is needed.
;;;1035                       //
;;;1036                       if((long)ulValue < 0)
;;;1037                       {
;;;1038                           //
;;;1039                           // Make the value positive.
;;;1040                           //
;;;1041                           ulValue = -(long)ulValue;
;;;1042   
;;;1043                           //
;;;1044                           // Indicate that the value is negative.
;;;1045                           //
;;;1046                           ulNeg = 1;
;;;1047                       }
;;;1048                       else
;;;1049                       {
;;;1050                           //
;;;1051                           // Indicate that the value is positive so that a minus
;;;1052                           // sign isn't inserted.
;;;1053                           //
;;;1054                           ulNeg = 0;
;;;1055                       }
;;;1056   
;;;1057                       //
;;;1058                       // Set the base to 10.
;;;1059                       //
;;;1060                       ulBase = 10;
;;;1061   
;;;1062                       //
;;;1063                       // Convert the value to ASCII.
;;;1064                       //
;;;1065                       goto convert;
;;;1066                   }
;;;1067   
;;;1068                   //
;;;1069                   // Handle the %s command.
;;;1070                   //
;;;1071                   case 's':
;;;1072                   {
;;;1073                       //
;;;1074                       // Get the string pointer from the varargs.
;;;1075                       //
;;;1076                       pcStr = va_arg(vaArgP, char *);
;;;1077   
;;;1078                       //
;;;1079                       // Determine the length of the string.
;;;1080                       //
;;;1081                       for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
;;;1082                       {
;;;1083                       }
;;;1084   
;;;1085                       //
;;;1086                       // Write the string.
;;;1087                       //
;;;1088                       UARTwrite(pcStr, ulIdx);
;;;1089   
;;;1090                       //
;;;1091                       // Write any required padding spaces
;;;1092                       //
;;;1093                       if(ulCount > ulIdx)
;;;1094                       {
;;;1095                           ulCount -= ulIdx;
;;;1096                           while(ulCount--)
;;;1097                           {
;;;1098                               UARTwrite(" ", 1);
;;;1099                           }
;;;1100                       }
;;;1101                       //
;;;1102                       // This command has been handled.
;;;1103                       //
;;;1104                       break;
;;;1105                   }
;;;1106   
;;;1107                   //
;;;1108                   // Handle the %u command.
;;;1109                   //
;;;1110                   case 'u':
;;;1111                   {
;;;1112                       //
;;;1113                       // Get the value from the varargs.
;;;1114                       //
;;;1115                       ulValue = va_arg(vaArgP, unsigned long);
;;;1116   
;;;1117                       //
;;;1118                       // Reset the buffer position.
;;;1119                       //
;;;1120                       ulPos = 0;
;;;1121   
;;;1122                       //
;;;1123                       // Set the base to 10.
;;;1124                       //
;;;1125                       ulBase = 10;
;;;1126   
;;;1127                       //
;;;1128                       // Indicate that the value is positive so that a minus sign
;;;1129                       // isn't inserted.
;;;1130                       //
;;;1131                       ulNeg = 0;
;;;1132   
;;;1133                       //
;;;1134                       // Convert the value to ASCII.
;;;1135                       //
;;;1136                       goto convert;
;;;1137                   }
;;;1138   
;;;1139                   //
;;;1140                   // Handle the %x and %X commands.  Note that they are treated
;;;1141                   // identically; i.e. %X will use lower case letters for a-f
;;;1142                   // instead of the upper case letters is should use.  We also
;;;1143                   // alias %p to %x.
;;;1144                   //
;;;1145                   case 'x':
;;;1146                   case 'X':
;;;1147                   case 'p':
;;;1148                   {
;;;1149                       //
;;;1150                       // Get the value from the varargs.
;;;1151                       //
;;;1152                       ulValue = va_arg(vaArgP, unsigned long);
;;;1153   
;;;1154                       //
;;;1155                       // Reset the buffer position.
;;;1156                       //
;;;1157                       ulPos = 0;
;;;1158   
;;;1159                       //
;;;1160                       // Set the base to 16.
;;;1161                       //
;;;1162                       ulBase = 16;
;;;1163   
;;;1164                       //
;;;1165                       // Indicate that the value is positive so that a minus sign
;;;1166                       // isn't inserted.
;;;1167                       //
;;;1168                       ulNeg = 0;
;;;1169   
;;;1170                       //
;;;1171                       // Determine the number of digits in the string version of
;;;1172                       // the value.
;;;1173                       //
;;;1174   convert:
;;;1175                       for(ulIdx = 1;
;;;1176                           (((ulIdx * ulBase) <= ulValue) &&
;;;1177                            (((ulIdx * ulBase) / ulBase) == ulIdx));
;;;1178                           ulIdx *= ulBase, ulCount--)
;;;1179                       {
;;;1180                       }
;;;1181   
;;;1182                       //
;;;1183                       // If the value is negative, reduce the count of padding
;;;1184                       // characters needed.
;;;1185                       //
;;;1186                       if(ulNeg)
;;;1187                       {
;;;1188                           ulCount--;
;;;1189                       }
;;;1190   
;;;1191                       //
;;;1192                       // If the value is negative and the value is padded with
;;;1193                       // zeros, then place the minus sign before the padding.
;;;1194                       //
;;;1195                       if(ulNeg && (cFill == '0'))
;;;1196                       {
;;;1197                           //
;;;1198                           // Place the minus sign in the output buffer.
;;;1199                           //
;;;1200                           pcBuf[ulPos++] = '-';
00000a  f04f0a2d          MOV      r10,#0x2d
00000e  f10d0904          ADD      r9,sp,#4              ;896
000012  e0bf              B        |L16.404|
                  |L16.20|
000014  2400              MOVS     r4,#0                 ;917
000016  e000              B        |L16.26|
                  |L16.24|
000018  1c64              ADDS     r4,r4,#1              ;918
                  |L16.26|
00001a  5d01              LDRB     r1,[r0,r4]            ;917
00001c  2925              CMP      r1,#0x25              ;917
00001e  d001              BEQ      |L16.36|
000020  2900              CMP      r1,#0                 ;917
000022  d1f9              BNE      |L16.24|
                  |L16.36|
000024  4621              MOV      r1,r4                 ;925
000026  f7fffffe          BL       UARTwrite
00002a  980e              LDR      r0,[sp,#0x38]         ;930
00002c  4420              ADD      r0,r0,r4              ;930
00002e  900e              STR      r0,[sp,#0x38]         ;935
000030  7801              LDRB     r1,[r0,#0]            ;935
000032  2925              CMP      r1,#0x25              ;935
000034  d174              BNE      |L16.288|
000036  1c40              ADDS     r0,r0,#1              ;940
000038  2400              MOVS     r4,#0                 ;946
00003a  2720              MOVS     r7,#0x20              ;947
00003c  900e              STR      r0,[sp,#0x38]         ;947
                  |L16.62|
00003e  990e              LDR      r1,[sp,#0x38]         ;959
000040  f8110b01          LDRB     r0,[r1],#1            ;959
000044  910e              STR      r1,[sp,#0x38]         ;959
000046  2838              CMP      r0,#0x38              ;959
000048  d02a              BEQ      |L16.160|
00004a  dc14              BGT      |L16.118|
00004c  2833              CMP      r0,#0x33              ;959
00004e  d027              BEQ      |L16.160|
000050  dc08              BGT      |L16.100|
000052  2825              CMP      r0,#0x25              ;959
000054  d07e              BEQ      |L16.340|
000056  2830              CMP      r0,#0x30              ;959
000058  d022              BEQ      |L16.160|
00005a  2831              CMP      r0,#0x31              ;959
00005c  d020              BEQ      |L16.160|
00005e  2832              CMP      r0,#0x32              ;959
000060  d11b              BNE      |L16.154|
000062  e01d              B        |L16.160|
                  |L16.100|
000064  2834              CMP      r0,#0x34              ;959
000066  d01b              BEQ      |L16.160|
000068  2835              CMP      r0,#0x35              ;959
00006a  d019              BEQ      |L16.160|
00006c  2836              CMP      r0,#0x36              ;959
00006e  d017              BEQ      |L16.160|
000070  2837              CMP      r0,#0x37              ;959
000072  d112              BNE      |L16.154|
000074  e014              B        |L16.160|
                  |L16.118|
000076  2870              CMP      r0,#0x70              ;959
000078  d049              BEQ      |L16.270|
00007a  dc08              BGT      |L16.142|
00007c  2839              CMP      r0,#0x39              ;959
00007e  d00f              BEQ      |L16.160|
000080  2858              CMP      r0,#0x58              ;959
000082  d044              BEQ      |L16.270|
000084  2863              CMP      r0,#0x63              ;959
000086  d017              BEQ      |L16.184|
000088  2864              CMP      r0,#0x64              ;959
00008a  d106              BNE      |L16.154|
00008c  e019              B        |L16.194|
                  |L16.142|
00008e  2873              CMP      r0,#0x73              ;959
000090  d023              BEQ      |L16.218|
000092  2875              CMP      r0,#0x75              ;959
000094  d036              BEQ      |L16.260|
000096  2878              CMP      r0,#0x78              ;959
000098  d039              BEQ      |L16.270|
                  |L16.154|
;;;1201   
;;;1202                           //
;;;1203                           // The minus sign has been placed, so turn off the
;;;1204                           // negative flag.
;;;1205                           //
;;;1206                           ulNeg = 0;
;;;1207                       }
;;;1208   
;;;1209                       //
;;;1210                       // Provide additional padding at the beginning of the
;;;1211                       // string conversion if needed.
;;;1212                       //
;;;1213                       if((ulCount > 1) && (ulCount < 16))
;;;1214                       {
;;;1215                           for(ulCount--; ulCount; ulCount--)
;;;1216                           {
;;;1217                               pcBuf[ulPos++] = cFill;
;;;1218                           }
;;;1219                       }
;;;1220   
;;;1221                       //
;;;1222                       // If the value is negative, then place the minus sign
;;;1223                       // before the number.
;;;1224                       //
;;;1225                       if(ulNeg)
;;;1226                       {
;;;1227                           //
;;;1228                           // Place the minus sign in the output buffer.
;;;1229                           //
;;;1230                           pcBuf[ulPos++] = '-';
;;;1231                       }
;;;1232   
;;;1233                       //
;;;1234                       // Convert the value into a string.
;;;1235                       //
;;;1236                       for(; ulIdx; ulIdx /= ulBase)
;;;1237                       {
;;;1238                           pcBuf[ulPos++] = g_pcHex[(ulValue / ulIdx) % ulBase];
;;;1239                       }
;;;1240   
;;;1241                       //
;;;1242                       // Write the string.
;;;1243                       //
;;;1244                       UARTwrite(pcBuf, ulPos);
;;;1245   
;;;1246                       //
;;;1247                       // This command has been handled.
;;;1248                       //
;;;1249                       break;
;;;1250                   }
;;;1251   
;;;1252                   //
;;;1253                   // Handle the %% command.
;;;1254                   //
;;;1255                   case '%':
;;;1256                   {
;;;1257                       //
;;;1258                       // Simply write a single %.
;;;1259                       //
;;;1260                       UARTwrite(pcString - 1, 1);
;;;1261   
;;;1262                       //
;;;1263                       // This command has been handled.
;;;1264                       //
;;;1265                       break;
;;;1266                   }
;;;1267   
;;;1268                   //
;;;1269                   // Handle all other commands.
;;;1270                   //
;;;1271                   default:
;;;1272                   {
;;;1273                       //
;;;1274                       // Indicate an error.
;;;1275                       //
;;;1276                       UARTwrite("ERROR", 5);
00009a  2105              MOVS     r1,#5
00009c  a042              ADR      r0,|L16.424|
;;;1277   
;;;1278                       //
;;;1279                       // This command has been handled.
;;;1280                       //
;;;1281                       break;
00009e  e077              B        |L16.400|
                  |L16.160|
0000a0  f8110c01          LDRB     r0,[r1,#-1]           ;979
0000a4  2830              CMP      r0,#0x30              ;979
0000a6  d101              BNE      |L16.172|
0000a8  b904              CBNZ     r4,|L16.172|
0000aa  2730              MOVS     r7,#0x30              ;981
                  |L16.172|
0000ac  eb040184          ADD      r1,r4,r4,LSL #2       ;987
0000b0  0049              LSLS     r1,r1,#1              ;987
0000b2  3930              SUBS     r1,r1,#0x30           ;988
0000b4  1844              ADDS     r4,r0,r1              ;988
0000b6  e7c2              B        |L16.62|
                  |L16.184|
0000b8  cd01              LDM      r5!,{r0}              ;1004
0000ba  9000              STR      r0,[sp,#0]            ;1009
0000bc  2101              MOVS     r1,#1                 ;1009
0000be  4668              MOV      r0,sp                 ;1009
0000c0  e066              B        |L16.400|
                  |L16.194|
0000c2  cd01              LDM      r5!,{r0}              ;1025
0000c4  2100              MOVS     r1,#0                 ;1030
0000c6  9000              STR      r0,[sp,#0]            ;1036
0000c8  2800              CMP      r0,#0                 ;1036
0000ca  da03              BGE      |L16.212|
0000cc  4240              RSBS     r0,r0,#0              ;1041
0000ce  2301              MOVS     r3,#1                 ;1046
0000d0  9000              STR      r0,[sp,#0]            ;1046
0000d2  e000              B        |L16.214|
                  |L16.212|
0000d4  2300              MOVS     r3,#0                 ;1054
                  |L16.214|
0000d6  220a              MOVS     r2,#0xa               ;1060
0000d8  e01e              B        |L16.280|
                  |L16.218|
0000da  cd01              LDM      r5!,{r0}              ;1076
0000dc  2600              MOVS     r6,#0                 ;1081
0000de  e000              B        |L16.226|
                  |L16.224|
0000e0  1c76              ADDS     r6,r6,#1              ;1081
                  |L16.226|
0000e2  5d81              LDRB     r1,[r0,r6]            ;1081
0000e4  2900              CMP      r1,#0                 ;1081
0000e6  d1fb              BNE      |L16.224|
0000e8  4631              MOV      r1,r6                 ;1088
0000ea  f7fffffe          BL       UARTwrite
0000ee  42b4              CMP      r4,r6                 ;1093
0000f0  d950              BLS      |L16.404|
0000f2  1ba4              SUBS     r4,r4,r6              ;1095
0000f4  e003              B        |L16.254|
                  |L16.246|
0000f6  2101              MOVS     r1,#1                 ;1098
0000f8  a02d              ADR      r0,|L16.432|
0000fa  f7fffffe          BL       UARTwrite
                  |L16.254|
0000fe  1e64              SUBS     r4,r4,#1              ;1096
000100  d348              BCC      |L16.404|
000102  e7f8              B        |L16.246|
                  |L16.260|
000104  cd01              LDM      r5!,{r0}              ;1115
000106  2100              MOVS     r1,#0                 ;1120
000108  220a              MOVS     r2,#0xa               ;1125
00010a  9000              STR      r0,[sp,#0]            ;1136
00010c  e003              B        |L16.278|
                  |L16.270|
00010e  cd01              LDM      r5!,{r0}              ;1152
000110  2100              MOVS     r1,#0                 ;1157
000112  2210              MOVS     r2,#0x10              ;1162
000114  9000              STR      r0,[sp,#0]            ;1162
                  |L16.278|
000116  2300              MOVS     r3,#0                 ;1168
                  |L16.280|
000118  2001              MOVS     r0,#1                 ;1175
00011a  f8ddc000          LDR      r12,[sp,#0]           ;1178
00011e  e002              B        |L16.294|
                  |L16.288|
000120  e038              B        |L16.404|
                  |L16.290|
000122  4630              MOV      r0,r6                 ;1178
000124  1e64              SUBS     r4,r4,#1              ;1178
                  |L16.294|
000126  fb00f602          MUL      r6,r0,r2              ;1176
00012a  4566              CMP      r6,r12                ;1176
00012c  d803              BHI      |L16.310|
00012e  fbb6f8f2          UDIV     r8,r6,r2              ;1177
000132  4580              CMP      r8,r0                 ;1177
000134  d0f5              BEQ      |L16.290|
                  |L16.310|
000136  b133              CBZ      r3,|L16.326|
000138  1e64              SUBS     r4,r4,#1              ;1188
00013a  2f30              CMP      r7,#0x30              ;1195
00013c  d103              BNE      |L16.326|
00013e  f809a001          STRB     r10,[r9,r1]           ;1200
000142  1c49              ADDS     r1,r1,#1              ;1200
000144  2300              MOVS     r3,#0                 ;1206
                  |L16.326|
000146  1ea6              SUBS     r6,r4,#2              ;1213
000148  2e0e              CMP      r6,#0xe               ;1213
00014a  d208              BCS      |L16.350|
00014c  1e64              SUBS     r4,r4,#1              ;1215
00014e  d006              BEQ      |L16.350|
000150  464e              MOV      r6,r9                 ;896
                  |L16.338|
000152  e000              B        |L16.342|
                  |L16.340|
000154  e019              B        |L16.394|
                  |L16.342|
000156  5477              STRB     r7,[r6,r1]            ;1217
000158  1c49              ADDS     r1,r1,#1              ;1217
00015a  1e64              SUBS     r4,r4,#1              ;1215
00015c  d1f9              BNE      |L16.338|
                  |L16.350|
00015e  b113              CBZ      r3,|L16.358|
000160  f809a001          STRB     r10,[r9,r1]           ;1230
000164  1c49              ADDS     r1,r1,#1              ;1230
                  |L16.358|
000166  4f13              LDR      r7,|L16.436|
000168  464e              MOV      r6,r9                 ;896
                  |L16.362|
00016a  b160              CBZ      r0,|L16.390|
00016c  fbbcf3f0          UDIV     r3,r12,r0             ;1238
000170  fbb3f4f2          UDIV     r4,r3,r2              ;1238
000174  fb023314          MLS      r3,r2,r4,r3           ;1238
000178  683c              LDR      r4,[r7,#0]            ;1238  ; g_pcHex
00017a  fbb0f0f2          UDIV     r0,r0,r2              ;1236
00017e  5ce3              LDRB     r3,[r4,r3]            ;1238
000180  5473              STRB     r3,[r6,r1]            ;1238
000182  1c49              ADDS     r1,r1,#1              ;1238
000184  e7f1              B        |L16.362|
                  |L16.390|
000186  a801              ADD      r0,sp,#4              ;1244
000188  e002              B        |L16.400|
                  |L16.394|
00018a  980e              LDR      r0,[sp,#0x38]         ;1260
00018c  2101              MOVS     r1,#1                 ;1260
00018e  1e40              SUBS     r0,r0,#1              ;1260
                  |L16.400|
000190  f7fffffe          BL       UARTwrite
                  |L16.404|
000194  980e              LDR      r0,[sp,#0x38]         ;912
000196  7801              LDRB     r1,[r0,#0]            ;912
000198  2900              CMP      r1,#0                 ;912
00019a  f47faf3b          BNE      |L16.20|
;;;1282                   }
;;;1283               }
;;;1284           }
;;;1285       }
;;;1286   
;;;1287       //
;;;1288       // End the varargs processing.
;;;1289       //
;;;1290       va_end(vaArgP);
;;;1291   }
00019e  b006              ADD      sp,sp,#0x18
0001a0  e8bd07f0          POP      {r4-r10}
0001a4  f85dfb14          LDR      pc,[sp],#0x14
;;;1292   
                          ENDP

                  |L16.424|
0001a8  4552524f          DCB      "ERROR",0
0001ac  5200    
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L16.432|
0001b0  2000              DCB      " ",0
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L16.436|
                          DCD      ||.constdata||

                          AREA ||i.UARTwrite||, CODE, READONLY, ALIGN=2

                  UARTwrite PROC
;;;468    int
;;;469    UARTwrite(const char *pcBuf, unsigned long ulLen)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;470    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;471    #ifdef UART_BUFFERED
;;;472        unsigned int uIdx;
;;;473    
;;;474        //
;;;475        // Check for valid arguments.
;;;476        //
;;;477        ASSERT(pcBuf != 0);
;;;478        ASSERT(g_ulBase != 0);
;;;479    
;;;480        //
;;;481        // Send the characters
;;;482        //
;;;483        for(uIdx = 0; uIdx < ulLen; uIdx++)
000008  2400              MOVS     r4,#0
;;;484        {
;;;485            //
;;;486            // If the character to the UART is \n, then add a \r before it so that
;;;487            // \n is translated to \n\r in the output.
;;;488            //
;;;489            if(pcBuf[uIdx] == '\n')
;;;490            {
;;;491                if(!TX_BUFFER_FULL)
00000a  f44f6a80          MOV      r10,#0x400
;;;492                {
;;;493                    g_pcUARTTxBuffer[g_ulUARTTxWriteIndex] = '\r';
00000e  4f1e              LDR      r7,|L17.136|
000010  4d1e              LDR      r5,|L17.140|
000012  f04f090d          MOV      r9,#0xd
000016  e021              B        |L17.92|
                  |L17.24|
000018  5d30              LDRB     r0,[r6,r4]            ;489
00001a  280a              CMP      r0,#0xa               ;489
00001c  d10e              BNE      |L17.60|
00001e  491b              LDR      r1,|L17.140|
000020  4652              MOV      r2,r10                ;491
000022  1d09              ADDS     r1,r1,#4              ;491
000024  1d08              ADDS     r0,r1,#4              ;491
000026  f7fffffe          BL       IsBufferFull
00002a  b9c8              CBNZ     r0,|L17.96|
00002c  6869              LDR      r1,[r5,#4]  ; g_ulUARTTxWriteIndex
00002e  f8079001          STRB     r9,[r7,r1]
;;;494                    ADVANCE_TX_BUFFER_INDEX(g_ulUARTTxWriteIndex);
000032  6868              LDR      r0,[r5,#4]  ; g_ulUARTTxWriteIndex
000034  1c40              ADDS     r0,r0,#1
000036  f3c00009          UBFX     r0,r0,#0,#10
00003a  6068              STR      r0,[r5,#4]  ; g_ulUARTTxWriteIndex
                  |L17.60|
;;;495                }
;;;496                else
;;;497                {
;;;498                    //
;;;499                    // Buffer is full - discard remaining characters and return.
;;;500                    //
;;;501                    break;
;;;502                }
;;;503            }
;;;504    
;;;505            //
;;;506            // Send the character to the UART output.
;;;507            //
;;;508            if(!TX_BUFFER_FULL)
00003c  4913              LDR      r1,|L17.140|
00003e  4652              MOV      r2,r10
000040  1d09              ADDS     r1,r1,#4
000042  1d08              ADDS     r0,r1,#4
000044  f7fffffe          BL       IsBufferFull
000048  b950              CBNZ     r0,|L17.96|
;;;509            {
;;;510                g_pcUARTTxBuffer[g_ulUARTTxWriteIndex] = pcBuf[uIdx];
00004a  5d30              LDRB     r0,[r6,r4]
00004c  6869              LDR      r1,[r5,#4]  ; g_ulUARTTxWriteIndex
00004e  5478              STRB     r0,[r7,r1]
;;;511                ADVANCE_TX_BUFFER_INDEX(g_ulUARTTxWriteIndex);
000050  6868              LDR      r0,[r5,#4]  ; g_ulUARTTxWriteIndex
000052  1c40              ADDS     r0,r0,#1
000054  f3c00009          UBFX     r0,r0,#0,#10
000058  6068              STR      r0,[r5,#4]  ; g_ulUARTTxWriteIndex
00005a  1c64              ADDS     r4,r4,#1              ;483
                  |L17.92|
00005c  4544              CMP      r4,r8                 ;483
00005e  d3db              BCC      |L17.24|
                  |L17.96|
;;;512            }
;;;513            else
;;;514            {
;;;515                //
;;;516                // Buffer is full - discard remaining characters and return.
;;;517                //
;;;518                break;
;;;519            }
;;;520        }
;;;521    
;;;522        //
;;;523        // If we have anything in the buffer, make sure that the UART is set
;;;524        // up to transmit it.
;;;525        //
;;;526        if(!TX_BUFFER_EMPTY)
000060  490a              LDR      r1,|L17.140|
000062  1d09              ADDS     r1,r1,#4
000064  1d08              ADDS     r0,r1,#4
000066  f7fffffe          BL       IsBufferEmpty
00006a  b948              CBNZ     r0,|L17.128|
;;;527        {
;;;528            UARTPrimeTransmit(g_ulBase);
00006c  6968              LDR      r0,[r5,#0x14]  ; g_ulBase
00006e  f7fffffe          BL       UARTPrimeTransmit
;;;529            MAP_UARTIntEnable(g_ulBase, UART_INT_TX);
000072  f04f7080          MOV      r0,#0x1000000
000076  2120              MOVS     r1,#0x20
000078  6940              LDR      r0,[r0,#0x14]
00007a  6c42              LDR      r2,[r0,#0x44]
00007c  6968              LDR      r0,[r5,#0x14]  ; g_ulBase
00007e  4790              BLX      r2
                  |L17.128|
;;;530        }
;;;531    
;;;532        //
;;;533        // Return the number of characters written.
;;;534        //
;;;535        return(uIdx);
000080  4620              MOV      r0,r4
;;;536    #else
;;;537        unsigned int uIdx;
;;;538    
;;;539        //
;;;540        // Check for valid UART base address, and valid arguments.
;;;541        //
;;;542        ASSERT(g_ulBase != 0);
;;;543        ASSERT(pcBuf != 0);
;;;544    
;;;545        //
;;;546        // Send the characters
;;;547        //
;;;548        for(uIdx = 0; uIdx < ulLen; uIdx++)
;;;549        {
;;;550            //
;;;551            // If the character to the UART is \n, then add a \r before it so that
;;;552            // \n is translated to \n\r in the output.
;;;553            //
;;;554            if(pcBuf[uIdx] == '\n')
;;;555            {
;;;556                MAP_UARTCharPut(g_ulBase, '\r');
;;;557            }
;;;558    
;;;559            //
;;;560            // Send the character to the UART output.
;;;561            //
;;;562            MAP_UARTCharPut(g_ulBase, pcBuf[uIdx]);
;;;563        }
;;;564    
;;;565        //
;;;566        // Return the number of characters written.
;;;567        //
;;;568        return(uIdx);
;;;569    #endif
;;;570    }
000082  e8bd87f0          POP      {r4-r10,pc}
;;;571    
                          ENDP

000086  0000              DCW      0x0000
                  |L17.136|
                          DCD      ||.bss||
                  |L17.140|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_pcUARTTxBuffer
                          %        1024
                  g_pcUARTRxBuffer
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_pcHex
                          DCD      ||.conststring||
                  g_ulUARTBase
                          DCD      0x4000c000
                          DCD      0x4000d000
                          DCD      0x4000e000
                  g_ulUARTInt
                          DCD      0x00000015
                          DCD      0x00000016
                          DCD      0x00000031
                  g_ulUARTPeriph
                          DCD      0x10000001
                          DCD      0x10000002
                          DCD      0x10000004

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=0

000000  30313233          DCB      "0123456789abcdef",0
000004  34353637
000008  38396162
00000c  63646566
000010  00      

                          AREA ||.data||, DATA, ALIGN=2

                  bLastWasCR
000000  00                DCB      0x00
                  g_bDisableEcho
000001  000000            DCB      0x00,0x00,0x00
                  g_ulUARTTxWriteIndex
                          DCD      0x00000000
                  g_ulUARTTxReadIndex
                          DCD      0x00000000
                  g_ulUARTRxWriteIndex
                          DCD      0x00000000
                  g_ulUARTRxReadIndex
                          DCD      0x00000000
                  g_ulBase
                          DCD      0x00000000
                  g_ulPortNum
                          DCD      0x00000000
