; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\motor.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\motor.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\motor.crf ..\drivers\motor.c]
                          THUMB

                          AREA ||i.MotorDir||, CODE, READONLY, ALIGN=2

                  MotorDir PROC
;;;158    void
;;;159    MotorDir (tSide ucMotor, tDirection eDirection)
000000  f04f7280          MOV      r2,#0x1000000
;;;160    {
;;;161        //
;;;162        // Check for invalid parameters.
;;;163        //
;;;164        ASSERT((ucMotor == LEFT_SIDE) || (ucMotor == RIGHT_SIDE));
;;;165        ASSERT((eDirection == FORWARD) || (eDirection == REVERSE));
;;;166    
;;;167        //
;;;168        // Which motor are we setting?
;;;169        //
;;;170        if(ucMotor == LEFT_SIDE)
;;;171        {
;;;172            //
;;;173            // Set the left side GPIO direction pin.
;;;174            //
;;;175            if(eDirection == FORWARD)
;;;176            {
;;;177                ROM_GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_1 , 0);
000004  6a12              LDR      r2,[r2,#0x20]
000006  6813              LDR      r3,[r2,#0]            ;170
000008  b110              CBZ      r0,|L1.16|
;;;178            }
;;;179            else
;;;180            {
;;;181                ROM_GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_1 , GPIO_PIN_1);
;;;182            }
;;;183        }
;;;184        else
;;;185        {
;;;186            //
;;;187            // Set the right side GPIO direction pin.
;;;188            //
;;;189            if(eDirection == FORWARD)
;;;190            {
;;;191                ROM_GPIOPinWrite(GPIO_PORTD_BASE, GPIO_PIN_1 , GPIO_PIN_1);
00000a  4805              LDR      r0,|L1.32|
00000c  b111              CBZ      r1,|L1.20|
00000e  e003              B        |L1.24|
                  |L1.16|
000010  4804              LDR      r0,|L1.36|
000012  b109              CBZ      r1,|L1.24|
                  |L1.20|
000014  2202              MOVS     r2,#2                 ;181
000016  e000              B        |L1.26|
                  |L1.24|
000018  2200              MOVS     r2,#0                 ;177
                  |L1.26|
;;;192            }
;;;193            else
;;;194            {
;;;195                ROM_GPIOPinWrite(GPIO_PORTD_BASE, GPIO_PIN_1 , 0);
00001a  2102              MOVS     r1,#2
00001c  4718              BX       r3
;;;196            }
;;;197        }
;;;198    }
;;;199    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x40007000
                  |L1.36|
                          DCD      0x40027000

                          AREA ||i.MotorRun||, CODE, READONLY, ALIGN=2

                  MotorRun PROC
;;;214    void
;;;215    MotorRun (tSide ucMotor)
000000  b130              CBZ      r0,|L2.16|
;;;216    {
;;;217        unsigned long ulPort;
;;;218    
;;;219        //
;;;220        // Check for invalid parameters.
;;;221        //
;;;222        ASSERT((ucMotor == LEFT_SIDE) || (ucMotor == RIGHT_SIDE));
;;;223    
;;;224        //
;;;225        // Select the correct GPIO port for the motor.
;;;226        //
;;;227        ulPort = (ucMotor == LEFT_SIDE) ? GPIO_PORTH_BASE : GPIO_PORTD_BASE;
000002  4804              LDR      r0,|L2.20|
                  |L2.4|
;;;228    
;;;229        //
;;;230        // Configure the pin to be controlled by the PWM module.  This enables
;;;231        // the PWM signal onto the pin, which causes the motor to start running.
;;;232        //
;;;233        ROM_GPIOPinTypePWM(ulPort, GPIO_PIN_0);
000004  f04f7180          MOV      r1,#0x1000000
000008  6a09              LDR      r1,[r1,#0x20]
00000a  6c4a              LDR      r2,[r1,#0x44]
00000c  2101              MOVS     r1,#1
00000e  4710              BX       r2
                  |L2.16|
000010  4801              LDR      r0,|L2.24|
000012  e7f7              B        |L2.4|
;;;234    }
;;;235    
                          ENDP

                  |L2.20|
                          DCD      0x40007000
                  |L2.24|
                          DCD      0x40027000

                          AREA ||i.MotorSpeed||, CODE, READONLY, ALIGN=2

                  MotorSpeed PROC
;;;295    void
;;;296    MotorSpeed(tSide ucMotor, unsigned short usPercent)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;297    {
000004  4688              MOV      r8,r1
;;;298        unsigned long ulPWMOut, ulPWMOutBit;
;;;299    
;;;300        //
;;;301        // Check for invalid parameters.
;;;302        //
;;;303        ASSERT((ucMotor == LEFT_SIDE) || (ucMotor == RIGHT_SIDE));
;;;304        ASSERT(usPercent < (100 << 8));
;;;305    
;;;306        //
;;;307        // Which PWM output are we controlling?
;;;308        //
;;;309        if(ucMotor == LEFT_SIDE)
000006  b320              CBZ      r0,|L3.82|
;;;310        {
;;;311            ulPWMOut = PWM_OUT_2;
;;;312            ulPWMOutBit = PWM_OUT_2_BIT;
;;;313        }
;;;314        else
;;;315        {
;;;316            ulPWMOut = PWM_OUT_0;
000008  2440              MOVS     r4,#0x40
;;;317            ulPWMOutBit = PWM_OUT_0_BIT;
00000a  2501              MOVS     r5,#1
                  |L3.12|
;;;318        }
;;;319    
;;;320        //
;;;321        // First, enable the PWM output in case it was disabled by the
;;;322        // previously requested speed being greater than 95%
;;;323        //
;;;324        ROM_PWMOutputState(PWM0_BASE, ulPWMOutBit, true);
00000c  f04f7680          MOV      r6,#0x1000000
000010  4f11              LDR      r7,|L3.88|
000012  6b30              LDR      r0,[r6,#0x30]
000014  2201              MOVS     r2,#1
000016  4629              MOV      r1,r5
000018  6ac3              LDR      r3,[r0,#0x2c]
00001a  4638              MOV      r0,r7
00001c  4798              BLX      r3
;;;325    
;;;326        //
;;;327        // Make sure that output is not inverted.
;;;328        //
;;;329        ROM_PWMOutputInvert(PWM0_BASE, ulPWMOutBit, false);
00001e  6b30              LDR      r0,[r6,#0x30]
000020  2200              MOVS     r2,#0
000022  4629              MOV      r1,r5
000024  6b03              LDR      r3,[r0,#0x30]
000026  4638              MOV      r0,r7
000028  4798              BLX      r3
;;;330    
;;;331        //
;;;332        // Set the pulse width to the requested value. Divide by two since
;;;333        // we are using 6V motors with 12V power rail.
;;;334        //
;;;335        ROM_PWMPulseWidthSet(PWM0_BASE, ulPWMOut, ((PWM_PERIOD * usPercent) /
00002a  6c70              LDR      r0,[r6,#0x44]
00002c  6e00              LDR      r0,[r0,#0x60]
00002e  4780              BLX      r0
000030  f44f517a          MOV      r1,#0x3e80
000034  fbb0f0f1          UDIV     r0,r0,r1
000038  fb00f008          MUL      r0,r0,r8
00003c  f44f41c8          MOV      r1,#0x6400
000040  fbb0f2f1          UDIV     r2,r0,r1
000044  6b30              LDR      r0,[r6,#0x30]
000046  4621              MOV      r1,r4
000048  6803              LDR      r3,[r0,#0]
00004a  4638              MOV      r0,r7
00004c  e8bd41f0          POP      {r4-r8,lr}
000050  4718              BX       r3
                  |L3.82|
000052  2482              MOVS     r4,#0x82              ;311
000054  2504              MOVS     r5,#4                 ;312
000056  e7d9              B        |L3.12|
;;;336                             (100 << 8)));
;;;337    }
;;;338    
                          ENDP

                  |L3.88|
                          DCD      0x40028000

                          AREA ||i.MotorStop||, CODE, READONLY, ALIGN=2

                  MotorStop PROC
;;;249    void
;;;250    MotorStop (tSide ucMotor)
000000  b570              PUSH     {r4-r6,lr}
;;;251    {
;;;252        unsigned long ulPort;
;;;253    
;;;254        //
;;;255        // Check for invalid parameters.
;;;256        //
;;;257        ASSERT((ucMotor == LEFT_SIDE) || (ucMotor == RIGHT_SIDE));
;;;258    
;;;259        //
;;;260        // Select the correct GPIO port for the motor.
;;;261        //
;;;262        ulPort = (ucMotor == LEFT_SIDE) ? GPIO_PORTH_BASE : GPIO_PORTD_BASE;
000002  b178              CBZ      r0,|L4.36|
000004  4c08              LDR      r4,|L4.40|
                  |L4.6|
;;;263    
;;;264        //
;;;265        // Configure the pin to be a software controlled GPIO output.  This stops
;;;266        // the PWM generator from controlling this pin.  This causes the motor
;;;267        // to stop running.
;;;268        //
;;;269        ROM_GPIOPinTypeGPIOOutput(ulPort, GPIO_PIN_0);
000006  f04f7580          MOV      r5,#0x1000000
00000a  2101              MOVS     r1,#1
00000c  6a28              LDR      r0,[r5,#0x20]
00000e  6bc2              LDR      r2,[r0,#0x3c]
000010  4620              MOV      r0,r4
000012  4790              BLX      r2
;;;270    
;;;271        //
;;;272        // Set the pin low.
;;;273        //
;;;274        ROM_GPIOPinWrite(ulPort, GPIO_PIN_0, 0);
000014  6a28              LDR      r0,[r5,#0x20]
000016  2200              MOVS     r2,#0
000018  2101              MOVS     r1,#1
00001a  6803              LDR      r3,[r0,#0]
00001c  4620              MOV      r0,r4
00001e  e8bd4070          POP      {r4-r6,lr}
000022  4718              BX       r3
                  |L4.36|
000024  4c01              LDR      r4,|L4.44|
000026  e7ee              B        |L4.6|
;;;275    }
;;;276    
                          ENDP

                  |L4.40|
                          DCD      0x40007000
                  |L4.44|
                          DCD      0x40027000

                          AREA ||i.MotorsInit||, CODE, READONLY, ALIGN=2

                  MotorsInit PROC
;;;60     void
;;;61     MotorsInit (void)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
;;;63         //
;;;64         // Enable the PWM controller and set its clock rate.
;;;65         //
;;;66         ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);
000002  f04f7480          MOV      r4,#0x1000000
000006  6c60              LDR      r0,[r4,#0x44]
000008  6981              LDR      r1,[r0,#0x18]
00000a  f04f1010          MOV      r0,#0x100010
00000e  4788              BLX      r1
;;;67         ROM_SysCtlPWMClockSet(SYSCTL_PWMDIV_1);
000010  6c60              LDR      r0,[r4,#0x44]
000012  6e41              LDR      r1,[r0,#0x64]
000014  2000              MOVS     r0,#0
000016  4788              BLX      r1
;;;68     
;;;69         //
;;;70         // Enable the GPIO ports used by the motor.
;;;71         //
;;;72         ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
000018  6c60              LDR      r0,[r4,#0x44]
00001a  6981              LDR      r1,[r0,#0x18]
00001c  4843              LDR      r0,|L5.300|
00001e  4788              BLX      r1
;;;73         ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
000020  6c60              LDR      r0,[r4,#0x44]
000022  6981              LDR      r1,[r0,#0x18]
000024  4841              LDR      r0,|L5.300|
000026  3078              ADDS     r0,r0,#0x78
000028  4788              BLX      r1
;;;74     
;;;75         //
;;;76         // Set up the pin muxing for the PWM pins
;;;77         //
;;;78         GPIOPinConfigure(GPIO_PD0_PWM0);
00002a  4841              LDR      r0,|L5.304|
00002c  f7fffffe          BL       GPIOPinConfigure
;;;79         GPIOPinConfigure(GPIO_PH0_PWM2);
000030  4840              LDR      r0,|L5.308|
000032  f7fffffe          BL       GPIOPinConfigure
;;;80     
;;;81         //
;;;82         // Configure the PWM0 generator
;;;83         //
;;;84         ROM_PWMGenConfigure(PWM0_BASE, PWM_GEN_0,
000036  6b20              LDR      r0,[r4,#0x30]
000038  4e3f              LDR      r6,|L5.312|
00003a  2202              MOVS     r2,#2
00003c  6843              LDR      r3,[r0,#4]
00003e  2140              MOVS     r1,#0x40
000040  4630              MOV      r0,r6
000042  4798              BLX      r3
;;;85                             PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);
;;;86         ROM_PWMGenPeriodSet(PWM0_BASE, PWM_GEN_0, PWM_PERIOD);
000044  6c60              LDR      r0,[r4,#0x44]
000046  6e00              LDR      r0,[r0,#0x60]
000048  4780              BLX      r0
00004a  f44f557a          MOV      r5,#0x3e80
00004e  fbb0f2f5          UDIV     r2,r0,r5
000052  6b20              LDR      r0,[r4,#0x30]
000054  2140              MOVS     r1,#0x40
000056  6883              LDR      r3,[r0,#8]
000058  4630              MOV      r0,r6
00005a  4798              BLX      r3
;;;87     
;;;88         //
;;;89         // Configure the PWM1 generator
;;;90         //
;;;91         ROM_PWMGenConfigure(PWM0_BASE, PWM_GEN_1,
00005c  6b20              LDR      r0,[r4,#0x30]
00005e  2202              MOVS     r2,#2
000060  2180              MOVS     r1,#0x80
000062  6843              LDR      r3,[r0,#4]
000064  4630              MOV      r0,r6
000066  4798              BLX      r3
;;;92                             PWM_GEN_MODE_UP_DOWN | PWM_GEN_MODE_NO_SYNC);
;;;93         ROM_PWMGenPeriodSet(PWM0_BASE, PWM_GEN_1, PWM_PERIOD);
000068  6c60              LDR      r0,[r4,#0x44]
00006a  6e00              LDR      r0,[r0,#0x60]
00006c  4780              BLX      r0
00006e  fbb0f2f5          UDIV     r2,r0,r5
000072  6b20              LDR      r0,[r4,#0x30]
000074  2180              MOVS     r1,#0x80
000076  6883              LDR      r3,[r0,#8]
000078  4630              MOV      r0,r6
00007a  4798              BLX      r3
;;;94     
;;;95     
;;;96         //
;;;97         // Configure the pulse widths for each PWM signal to initially 0%
;;;98         //
;;;99         ROM_PWMPulseWidthSet(PWM0_BASE, PWM_OUT_0, 0);
00007c  6b20              LDR      r0,[r4,#0x30]
00007e  2200              MOVS     r2,#0
000080  2140              MOVS     r1,#0x40
000082  6803              LDR      r3,[r0,#0]
000084  4630              MOV      r0,r6
000086  4798              BLX      r3
;;;100        ROM_PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, 0);
000088  6b20              LDR      r0,[r4,#0x30]
00008a  2200              MOVS     r2,#0
00008c  2182              MOVS     r1,#0x82
00008e  6803              LDR      r3,[r0,#0]
000090  4630              MOV      r0,r6
000092  4798              BLX      r3
;;;101    
;;;102        //
;;;103        // Initially disable the the PWM0 and PWM2 output signals.
;;;104        //
;;;105        ROM_PWMOutputState(PWM0_BASE, PWM_OUT_0_BIT | PWM_OUT_2_BIT, false);
000094  6b20              LDR      r0,[r4,#0x30]
000096  2200              MOVS     r2,#0
000098  2105              MOVS     r1,#5
00009a  6ac3              LDR      r3,[r0,#0x2c]
00009c  4630              MOV      r0,r6
00009e  4798              BLX      r3
;;;106    
;;;107        //
;;;108        // Enable the PWM generators.
;;;109        //
;;;110        ROM_PWMGenEnable(PWM0_BASE, PWM_GEN_0);
0000a0  6b20              LDR      r0,[r4,#0x30]
0000a2  2140              MOVS     r1,#0x40
0000a4  6902              LDR      r2,[r0,#0x10]
0000a6  4630              MOV      r0,r6
0000a8  4790              BLX      r2
;;;111        ROM_PWMGenEnable(PWM0_BASE, PWM_GEN_1);
0000aa  6b20              LDR      r0,[r4,#0x30]
0000ac  2180              MOVS     r1,#0x80
0000ae  6902              LDR      r2,[r0,#0x10]
0000b0  4630              MOV      r0,r6
0000b2  4790              BLX      r2
;;;112    
;;;113        //
;;;114        // Set the pins connected to the motor driver fault signal to input with
;;;115        // pull ups.
;;;116        //
;;;117        ROM_GPIOPinTypeGPIOInput(GPIO_PORTD_BASE, GPIO_PIN_3);
0000b4  6a20              LDR      r0,[r4,#0x20]
0000b6  4e21              LDR      r6,|L5.316|
0000b8  2108              MOVS     r1,#8
0000ba  6b82              LDR      r2,[r0,#0x38]
0000bc  4630              MOV      r0,r6
0000be  4790              BLX      r2
;;;118        ROM_GPIOPadConfigSet(GPIO_PORTD_BASE, GPIO_PIN_3, GPIO_STRENGTH_2MA,
0000c0  6a20              LDR      r0,[r4,#0x20]
0000c2  230a              MOVS     r3,#0xa
0000c4  2201              MOVS     r2,#1
0000c6  6945              LDR      r5,[r0,#0x14]
0000c8  2108              MOVS     r1,#8
0000ca  4630              MOV      r0,r6
0000cc  47a8              BLX      r5
;;;119                             GPIO_PIN_TYPE_STD_WPU);
;;;120    
;;;121        //
;;;122        // Enable slow decay mode.
;;;123        //
;;;124        ROM_GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_2);
0000ce  6a20              LDR      r0,[r4,#0x20]
0000d0  2104              MOVS     r1,#4
0000d2  6bc2              LDR      r2,[r0,#0x3c]
0000d4  4630              MOV      r0,r6
0000d6  4790              BLX      r2
;;;125        ROM_GPIOPinWrite(GPIO_PORTD_BASE, GPIO_PIN_2, GPIO_PIN_2);
0000d8  6a20              LDR      r0,[r4,#0x20]
0000da  2204              MOVS     r2,#4
0000dc  4611              MOV      r1,r2
0000de  6803              LDR      r3,[r0,#0]
0000e0  4630              MOV      r0,r6
0000e2  4798              BLX      r3
;;;126    
;;;127        //
;;;128        // Initially configure the direction control and enable pins as GPIO and
;;;129        // set low.
;;;130        //
;;;131        ROM_GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_0 | GPIO_PIN_1);
0000e4  6a20              LDR      r0,[r4,#0x20]
0000e6  2103              MOVS     r1,#3
0000e8  6bc2              LDR      r2,[r0,#0x3c]
0000ea  4630              MOV      r0,r6
0000ec  4790              BLX      r2
;;;132        ROM_GPIOPinTypeGPIOOutput(GPIO_PORTH_BASE, GPIO_PIN_0 | GPIO_PIN_1);
0000ee  6a20              LDR      r0,[r4,#0x20]
0000f0  4d13              LDR      r5,|L5.320|
0000f2  2103              MOVS     r1,#3
0000f4  6bc2              LDR      r2,[r0,#0x3c]
0000f6  4628              MOV      r0,r5
0000f8  4790              BLX      r2
;;;133        ROM_GPIOPinWrite(GPIO_PORTD_BASE, GPIO_PIN_0 | GPIO_PIN_1, 0);
0000fa  6a20              LDR      r0,[r4,#0x20]
0000fc  2200              MOVS     r2,#0
0000fe  2103              MOVS     r1,#3
000100  6803              LDR      r3,[r0,#0]
000102  4630              MOV      r0,r6
000104  4798              BLX      r3
;;;134        ROM_GPIOPinWrite(GPIO_PORTH_BASE, GPIO_PIN_0 | GPIO_PIN_1, 0);
000106  6a20              LDR      r0,[r4,#0x20]
000108  2200              MOVS     r2,#0
00010a  2103              MOVS     r1,#3
00010c  6803              LDR      r3,[r0,#0]
00010e  4628              MOV      r0,r5
000110  4798              BLX      r3
;;;135    
;;;136        //
;;;137        // Enable the 12V boost
;;;138        //
;;;139        ROM_GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_5);
000112  6a20              LDR      r0,[r4,#0x20]
000114  2120              MOVS     r1,#0x20
000116  6bc2              LDR      r2,[r0,#0x3c]
000118  4630              MOV      r0,r6
00011a  4790              BLX      r2
;;;140        ROM_GPIOPinWrite(GPIO_PORTD_BASE, GPIO_PIN_5, GPIO_PIN_5);
00011c  6a20              LDR      r0,[r4,#0x20]
00011e  2220              MOVS     r2,#0x20
000120  4611              MOV      r1,r2
000122  6803              LDR      r3,[r0,#0]
000124  4630              MOV      r0,r6
000126  e8bd4070          POP      {r4-r6,lr}
00012a  4718              BX       r3
;;;141    }
;;;142    
                          ENDP

                  |L5.300|
                          DCD      0x20000008
                  |L5.304|
                          DCD      0x00030001
                  |L5.308|
                          DCD      0x00070002
                  |L5.312|
                          DCD      0x40028000
                  |L5.316|
                          DCD      0x40007000
                  |L5.320|
                          DCD      0x40027000
