; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\sound.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\sound.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\sound.crf ..\drivers\sound.c]
                          THUMB

                          AREA ||i.SoundBufferPlay||, CODE, READONLY, ALIGN=2

                  SoundBufferPlay PROC
;;;617    void
;;;618    SoundBufferPlay(const void *pvData, unsigned long ulLength,
000000  b5f8              PUSH     {r3-r7,lr}
;;;619                    void (*pfnCallback)(void *pvBuffer, unsigned long ulEvent))
;;;620    {
;;;621        unsigned long ulChannel;
;;;622    
;;;623        //
;;;624        // Must disable I2S interrupts during this time to prevent state problems.
;;;625        //
;;;626        ROM_IntDisable(INT_I2S0);
000002  f04f7480          MOV      r4,#0x1000000
000006  4606              MOV      r6,r0                 ;620
000008  6ca0              LDR      r0,[r4,#0x48]
00000a  460d              MOV      r5,r1                 ;620
00000c  4617              MOV      r7,r2                 ;620
00000e  68c1              LDR      r1,[r0,#0xc]
000010  2044              MOVS     r0,#0x44
000012  4788              BLX      r1
;;;627    
;;;628        //
;;;629        // Save the buffer information.
;;;630        //
;;;631        g_sOutBuffers[g_ulPlaying].pulData = (unsigned long *)pvData;
000014  4632              MOV      r2,r6
000016  4e22              LDR      r6,|L1.160|
000018  f8dfc088          LDR      r12,|L1.164|
00001c  68b3              LDR      r3,[r6,#8]  ; g_ulPlaying
00001e  eb030143          ADD      r1,r3,r3,LSL #1
000022  f84c2021          STR      r2,[r12,r1,LSL #2]
;;;632        g_sOutBuffers[g_ulPlaying].ulSize = ulLength;
000026  eb0c0181          ADD      r1,r12,r1,LSL #2
00002a  e9c15701          STRD     r5,r7,[r1,#4]
;;;633        g_sOutBuffers[g_ulPlaying].pfnBufferCallback = pfnCallback;
;;;634    
;;;635        //
;;;636        // Handle which half of the ping-pong DMA is in use.
;;;637        //
;;;638        if(g_ulPlaying)
00002e  b10b              CBZ      r3,|L1.52|
;;;639        {
;;;640            ulChannel = UDMA_CHANNEL_I2S0TX | UDMA_ALT_SELECT;
000030  203d              MOVS     r0,#0x3d
000032  e000              B        |L1.54|
                  |L1.52|
;;;641        }
;;;642        else
;;;643        {
;;;644            ulChannel = UDMA_CHANNEL_I2S0TX | UDMA_PRI_SELECT;
000034  201d              MOVS     r0,#0x1d
                  |L1.54|
;;;645        }
;;;646    
;;;647        //
;;;648        // Set the DMA channel configuration.
;;;649        //
;;;650        if(g_usChannels == 1)
000036  8873              LDRH     r3,[r6,#2]  ; g_usChannels
;;;651        {
;;;652            //
;;;653            // Handle Mono formats.
;;;654            //
;;;655            if(g_usBitsPerSample == 16)
;;;656            {
;;;657                //
;;;658                // The transfer size is 16 bits from the TX buffer to the TX FIFO.
;;;659                // Modify the DMA transfer size at it is units not bytes.
;;;660                //
;;;661                g_sOutBuffers[g_ulPlaying].ulSize >>= 1;
000038  086f              LSRS     r7,r5,#1
00003a  2b01              CMP      r3,#1                 ;650
00003c  6933              LDR      r3,[r6,#0x10]         ;650  ; g_usBitsPerSample
00003e  d02b              BEQ      |L1.152|
;;;662            }
;;;663        }
;;;664        else
;;;665        {
;;;666            //
;;;667            // Handle Stereo formats.
;;;668            //
;;;669            if(g_usBitsPerSample == 8)
000040  2b08              CMP      r3,#8
000042  d02b              BEQ      |L1.156|
;;;670            {
;;;671                //
;;;672                // The transfer size is 16 bits(stereo 8 bits) from the TX buffer
;;;673                // to the TX FIFO.  Modify the DMA transfer size at it is units
;;;674                // not bytes.
;;;675                //
;;;676                g_sOutBuffers[g_ulPlaying].ulSize >>= 1;
;;;677            }
;;;678            else
;;;679            {
;;;680                //
;;;681                // The transfer size is 32 bits(stereo 16 bits) from the TX buffer
;;;682                // to the TX FIFO. Modify the DMA transfer size at it is units not
;;;683                // bytes.
;;;684                //
;;;685                g_sOutBuffers[g_ulPlaying].ulSize >>= 2;
000044  08ab              LSRS     r3,r5,#2
000046  604b              STR      r3,[r1,#4]
                  |L1.72|
;;;686            }
;;;687        }
;;;688    
;;;689        //
;;;690        // Set up the uDMA transfer addresses, using ping-pong mode.
;;;691        //
;;;692        ROM_uDMAChannelTransferSet(ulChannel,
000048  6849              LDR      r1,[r1,#4]
00004a  9100              STR      r1,[sp,#0]
00004c  6d61              LDR      r1,[r4,#0x54]
00004e  4f16              LDR      r7,|L1.168|
000050  680d              LDR      r5,[r1,#0]
000052  463b              MOV      r3,r7
000054  2103              MOVS     r1,#3
000056  47a8              BLX      r5
;;;693                               UDMA_MODE_PINGPONG,
;;;694                               (unsigned long *)g_sOutBuffers[g_ulPlaying].pulData,
;;;695                               (void *)(I2S0_BASE + I2S_O_TXFIFO),
;;;696                               g_sOutBuffers[g_ulPlaying].ulSize);
;;;697    
;;;698        //
;;;699        // Enable the TX channel.  At this point the uDMA controller will
;;;700        // start servicing the request from the I2S, and the transmit side
;;;701        // should start running.
;;;702        //
;;;703        ROM_uDMAChannelEnable(UDMA_CHANNEL_I2S0TX);
000058  6d60              LDR      r0,[r4,#0x54]
00005a  6941              LDR      r1,[r0,#0x14]
00005c  201d              MOVS     r0,#0x1d
00005e  4788              BLX      r1
;;;704    
;;;705        //
;;;706        // Indicate that there is still a pending transfer.
;;;707        //
;;;708        HWREGBITW(&g_ulDMAFlags, FLAG_TX_PENDING) = 1;
000060  480f              LDR      r0,|L1.160|
000062  4a0f              LDR      r2,|L1.160|
000064  1d00              ADDS     r0,r0,#4
000066  1d12              ADDS     r2,r2,#4
000068  f0004070          AND      r0,r0,#0xf0000000
00006c  f3c20213          UBFX     r2,r2,#0,#20
000070  ea401042          ORR      r0,r0,r2,LSL #5
000074  4a0d              LDR      r2,|L1.172|
000076  2101              MOVS     r1,#1
000078  4310              ORRS     r0,r0,r2
00007a  6001              STR      r1,[r0,#0]
;;;709    
;;;710        //
;;;711        // Toggle which ping-pong DMA setting is in use.
;;;712        //
;;;713        g_ulPlaying ^= 1;
00007c  68b0              LDR      r0,[r6,#8]  ; g_ulPlaying
00007e  f0800001          EOR      r0,r0,#1
;;;714    
;;;715        //
;;;716        // Enable the I2S controller to start transmitting.
;;;717        //
;;;718        I2STxEnable(I2S0_BASE);
000082  60b0              STR      r0,[r6,#8]  ; g_ulPlaying
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       I2STxEnable
;;;719    
;;;720        //
;;;721        // Re-enable I2S interrupts.
;;;722        //
;;;723        ROM_IntEnable(INT_I2S0);
00008a  6ca0              LDR      r0,[r4,#0x48]
00008c  6801              LDR      r1,[r0,#0]
00008e  b001              ADD      sp,sp,#4
000090  2044              MOVS     r0,#0x44
000092  e8bd40f0          POP      {r4-r7,lr}
000096  4708              BX       r1
                  |L1.152|
000098  2b10              CMP      r3,#0x10              ;655
00009a  d1d5              BNE      |L1.72|
                  |L1.156|
00009c  604f              STR      r7,[r1,#4]            ;676
00009e  e7d3              B        |L1.72|
;;;724    }
;;;725    
                          ENDP

                  |L1.160|
                          DCD      ||.data||
                  |L1.164|
                          DCD      ||.bss||
                  |L1.168|
                          DCD      0x40054000
                  |L1.172|
                          DCD      0x02000004

                          AREA ||i.SoundClassDDis||, CODE, READONLY, ALIGN=1

                  SoundClassDDis PROC
;;;878    void
;;;879    SoundClassDDis(void)
000000  f7ffbffe          B.W      DACClassDDis
;;;880    {
;;;881        DACClassDDis();
;;;882    }
;;;883    
                          ENDP


                          AREA ||i.SoundClassDEn||, CODE, READONLY, ALIGN=1

                  SoundClassDEn PROC
;;;862    void
;;;863    SoundClassDEn(void)
000000  f7ffbffe          B.W      DACClassDEn
;;;864    {
;;;865        DACClassDEn();
;;;866    }
;;;867    
                          ENDP


                          AREA ||i.SoundInit||, CODE, READONLY, ALIGN=2

                  SoundInit PROC
;;;150    void
;;;151    SoundInit(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;152    {
;;;153        //
;;;154        // Set the current active buffer to zero.
;;;155        //
;;;156        g_ulPlaying = 0;
000004  4933              LDR      r1,|L4.212|
000006  2000              MOVS     r0,#0
;;;157    
;;;158        //
;;;159        // Enable and reset the peripheral.
;;;160        //
;;;161        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_I2S0);
000008  f04f7480          MOV      r4,#0x1000000
00000c  6088              STR      r0,[r1,#8]  ; g_ulPlaying
00000e  6c60              LDR      r0,[r4,#0x44]
000010  6981              LDR      r1,[r0,#0x18]
000012  4831              LDR      r0,|L4.216|
000014  4788              BLX      r1
;;;162        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UDMA);
000016  6c60              LDR      r0,[r4,#0x44]
000018  6981              LDR      r1,[r0,#0x18]
00001a  f04f2020          MOV      r0,#0x20002000
00001e  4788              BLX      r1
;;;163        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
000020  6c60              LDR      r0,[r4,#0x44]
000022  4d2e              LDR      r5,|L4.220|
000024  6981              LDR      r1,[r0,#0x18]
000026  4628              MOV      r0,r5
000028  4788              BLX      r1
;;;164        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
00002a  6c60              LDR      r0,[r4,#0x44]
00002c  4e2b              LDR      r6,|L4.220|
00002e  360e              ADDS     r6,r6,#0xe
000030  6981              LDR      r1,[r0,#0x18]
000032  4630              MOV      r0,r6
000034  4788              BLX      r1
;;;165        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
000036  6c60              LDR      r0,[r4,#0x44]
000038  4f28              LDR      r7,|L4.220|
00003a  371e              ADDS     r7,r7,#0x1e
00003c  6981              LDR      r1,[r0,#0x18]
00003e  4638              MOV      r0,r7
000040  4788              BLX      r1
;;;166    
;;;167        //
;;;168        // Set up the pin mux.
;;;169        //
;;;170        GPIOPinConfigure(GPIO_PB6_I2S0TXSCK);
000042  4827              LDR      r0,|L4.224|
000044  f7fffffe          BL       GPIOPinConfigure
;;;171        GPIOPinConfigure(GPIO_PE4_I2S0TXWS);
000048  4826              LDR      r0,|L4.228|
00004a  f7fffffe          BL       GPIOPinConfigure
;;;172        GPIOPinConfigure(GPIO_PE5_I2S0TXSD);
00004e  4826              LDR      r0,|L4.232|
000050  f7fffffe          BL       GPIOPinConfigure
;;;173        GPIOPinConfigure(GPIO_PF1_I2S0TXMCLK);
000054  4825              LDR      r0,|L4.236|
000056  f7fffffe          BL       GPIOPinConfigure
;;;174    
;;;175        //
;;;176        // Select alternate functions for all of the I2S pins.
;;;177        //
;;;178        ROM_SysCtlPeripheralEnable(I2S0_SCLKTX_PERIPH);
00005a  6c60              LDR      r0,[r4,#0x44]
00005c  6981              LDR      r1,[r0,#0x18]
00005e  4628              MOV      r0,r5
000060  4788              BLX      r1
;;;179        GPIOPinTypeI2S(I2S0_SCLKTX_PORT, I2S0_SCLKTX_PIN);
000062  2140              MOVS     r1,#0x40
000064  4822              LDR      r0,|L4.240|
000066  f7fffffe          BL       GPIOPinTypeI2S
;;;180    
;;;181        ROM_SysCtlPeripheralEnable(I2S0_MCLKTX_PERIPH);
00006a  6c60              LDR      r0,[r4,#0x44]
00006c  6981              LDR      r1,[r0,#0x18]
00006e  4638              MOV      r0,r7
000070  4788              BLX      r1
;;;182        GPIOPinTypeI2S(I2S0_MCLKTX_PORT, I2S0_MCLKTX_PIN);
000072  2102              MOVS     r1,#2
000074  481f              LDR      r0,|L4.244|
000076  f7fffffe          BL       GPIOPinTypeI2S
;;;183    
;;;184        ROM_SysCtlPeripheralEnable(I2S0_LRCTX_PERIPH);
00007a  6c60              LDR      r0,[r4,#0x44]
00007c  6981              LDR      r1,[r0,#0x18]
00007e  4630              MOV      r0,r6
000080  4788              BLX      r1
;;;185        GPIOPinTypeI2S(I2S0_LRCTX_PORT, I2S0_LRCTX_PIN);
000082  4d1d              LDR      r5,|L4.248|
000084  2110              MOVS     r1,#0x10
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       GPIOPinTypeI2S
;;;186    
;;;187        ROM_SysCtlPeripheralEnable(I2S0_SDATX_PERIPH);
00008c  6c60              LDR      r0,[r4,#0x44]
00008e  6981              LDR      r1,[r0,#0x18]
000090  4630              MOV      r0,r6
000092  4788              BLX      r1
;;;188        GPIOPinTypeI2S(I2S0_SDATX_PORT, I2S0_SDATX_PIN);
000094  2120              MOVS     r1,#0x20
000096  4628              MOV      r0,r5
000098  f7fffffe          BL       GPIOPinTypeI2S
;;;189    
;;;190        //
;;;191        // Set up the DMA.
;;;192        //
;;;193        ROM_uDMAControlBaseSet(&sDMAControlTable[0]);
00009c  6d60              LDR      r0,[r4,#0x54]
00009e  6a01              LDR      r1,[r0,#0x20]
0000a0  4816              LDR      r0,|L4.252|
0000a2  4788              BLX      r1
;;;194        ROM_uDMAEnable();
0000a4  6d60              LDR      r0,[r4,#0x54]
0000a6  6840              LDR      r0,[r0,#4]
0000a8  4780              BLX      r0
;;;195    
;;;196        //
;;;197        // Initialize the DAC.
;;;198        //
;;;199        DACInit();
0000aa  f7fffffe          BL       DACInit
;;;200    
;;;201        //
;;;202        // Set the FIFO trigger limit
;;;203        //
;;;204        I2STxFIFOLimitSet(I2S0_BASE, 4);
0000ae  4d14              LDR      r5,|L4.256|
0000b0  2104              MOVS     r1,#4
0000b2  4628              MOV      r0,r5
0000b4  f7fffffe          BL       I2STxFIFOLimitSet
;;;205    
;;;206        //
;;;207        // Clear out all pending interrupts.
;;;208        //
;;;209        I2SIntClear(I2S0_BASE, I2S_INT_TXERR | I2S_INT_TXREQ );
0000b8  2103              MOVS     r1,#3
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       I2SIntClear
;;;210    
;;;211        //
;;;212        // Disable all uDMA attributes.
;;;213        //
;;;214        ROM_uDMAChannelAttributeDisable(UDMA_CHANNEL_I2S0TX, UDMA_ATTR_ALL);
0000c0  6d60              LDR      r0,[r4,#0x54]
0000c2  210f              MOVS     r1,#0xf
0000c4  6b02              LDR      r2,[r0,#0x30]
0000c6  201d              MOVS     r0,#0x1d
0000c8  4790              BLX      r2
;;;215    
;;;216        //
;;;217        // Enable the I2S Tx controller.
;;;218        //
;;;219        I2STxEnable(I2S0_BASE);
0000ca  4628              MOV      r0,r5
0000cc  e8bd41f0          POP      {r4-r8,lr}
0000d0  f7ffbffe          B.W      I2STxEnable
;;;220    }
;;;221    
                          ENDP

                  |L4.212|
                          DCD      ||.data||
                  |L4.216|
                          DCD      0x10101000
                  |L4.220|
                          DCD      0x20000002
                  |L4.224|
                          DCD      0x00011809
                  |L4.228|
                          DCD      0x00041009
                  |L4.232|
                          DCD      0x00041409
                  |L4.236|
                          DCD      0x00050408
                  |L4.240|
                          DCD      0x40005000
                  |L4.244|
                          DCD      0x40025000
                  |L4.248|
                          DCD      0x40024000
                  |L4.252|
                          DCD      sDMAControlTable
                  |L4.256|
                          DCD      0x40054000

                          AREA ||i.SoundIntHandler||, CODE, READONLY, ALIGN=2

                  SoundIntHandler PROC
;;;242    void
;;;243    SoundIntHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;244    {
;;;245        unsigned long ulStatus;
;;;246        unsigned long *pulTemp;
;;;247    
;;;248        //
;;;249        // Get the interrupt status and clear any pending interrupts.
;;;250        //
;;;251        ulStatus = I2SIntStatus(I2S0_BASE, 1);
000004  4c1d              LDR      r4,|L5.124|
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       I2SIntStatus
00000e  4601              MOV      r1,r0
;;;252    
;;;253        //
;;;254        // Clear out any interrupts.
;;;255        //
;;;256        I2SIntClear(I2S0_BASE, ulStatus);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       I2SIntClear
;;;257    
;;;258        //
;;;259        // Handle the TX channel interrupt
;;;260        //
;;;261        if(HWREGBITW(&g_ulDMAFlags, FLAG_TX_PENDING))
000016  481a              LDR      r0,|L5.128|
000018  4919              LDR      r1,|L5.128|
00001a  f0004070          AND      r0,r0,#0xf0000000
00001e  f3c10113          UBFX     r1,r1,#0,#20
000022  ea401641          ORR      r6,r0,r1,LSL #5
000026  4817              LDR      r0,|L5.132|
000028  4306              ORRS     r6,r6,r0
00002a  6830              LDR      r0,[r6,#0]
00002c  2800              CMP      r0,#0
00002e  d022              BEQ      |L5.118|
;;;262        {
;;;263            //
;;;264            // If the TX DMA is done, then call the callback if present.
;;;265            //
;;;266            if(ROM_uDMAChannelModeGet(UDMA_CHANNEL_I2S0TX | UDMA_PRI_SELECT) ==
000030  f04f7780          MOV      r7,#0x1000000
000034  6d78              LDR      r0,[r7,#0x54]
000036  6c01              LDR      r1,[r0,#0x40]
000038  201d              MOVS     r0,#0x1d
00003a  4788              BLX      r1
;;;267               UDMA_MODE_STOP)
;;;268            {
;;;269                //
;;;270                // Save a temp pointer so that the current pointer can be set to
;;;271                // zero before calling the callback.
;;;272                //
;;;273                pulTemp = g_sOutBuffers[0].pulData;
00003c  4c12              LDR      r4,|L5.136|
;;;274    
;;;275                //
;;;276                // If at the mid point then refill the first half of the buffer.
;;;277                //
;;;278                if((g_sOutBuffers[0].pfnBufferCallback) &&
00003e  2500              MOVS     r5,#0
000040  b930              CBNZ     r0,|L5.80|
000042  68a2              LDR      r2,[r4,#8]  ; g_sOutBuffers
000044  6820              LDR      r0,[r4,#0]  ; g_sOutBuffers
000046  b11a              CBZ      r2,|L5.80|
;;;279                   (g_sOutBuffers[0].pulData != 0))
000048  b110              CBZ      r0,|L5.80|
;;;280                {
;;;281                    g_sOutBuffers[0].pulData = 0;
;;;282                    g_sOutBuffers[0].pfnBufferCallback(pulTemp, BUFFER_EVENT_FREE);
00004a  2101              MOVS     r1,#1
00004c  6025              STR      r5,[r4,#0]  ; g_sOutBuffers
00004e  4790              BLX      r2
                  |L5.80|
;;;283                }
;;;284            }
;;;285    
;;;286            //
;;;287            // If the TX DMA is done, then call the callback if present.
;;;288            //
;;;289            if(ROM_uDMAChannelModeGet(UDMA_CHANNEL_I2S0TX | UDMA_ALT_SELECT) ==
000050  6d78              LDR      r0,[r7,#0x54]
000052  6c01              LDR      r1,[r0,#0x40]
000054  203d              MOVS     r0,#0x3d
000056  4788              BLX      r1
000058  b930              CBNZ     r0,|L5.104|
;;;290               UDMA_MODE_STOP)
;;;291            {
;;;292                //
;;;293                // Save a temporary pointer so that the current pointer can be set
;;;294                // to zero before calling the callback.
;;;295                //
;;;296                pulTemp = g_sOutBuffers[1].pulData;
;;;297    
;;;298                //
;;;299                // If at the mid point then refill the first half of the buffer.
;;;300                //
;;;301                if((g_sOutBuffers[1].pfnBufferCallback) &&
00005a  6962              LDR      r2,[r4,#0x14]  ; g_sOutBuffers
00005c  68e0              LDR      r0,[r4,#0xc]  ; g_sOutBuffers
00005e  b11a              CBZ      r2,|L5.104|
;;;302                   (g_sOutBuffers[1].pulData != 0))
000060  b110              CBZ      r0,|L5.104|
;;;303                {
;;;304                    g_sOutBuffers[1].pulData = 0;
;;;305                    g_sOutBuffers[1].pfnBufferCallback(pulTemp, BUFFER_EVENT_FREE);
000062  2101              MOVS     r1,#1
000064  60e5              STR      r5,[r4,#0xc]  ; g_sOutBuffers
000066  4790              BLX      r2
                  |L5.104|
;;;306                }
;;;307            }
;;;308    
;;;309            //
;;;310            // If no more buffers are pending then clear the flag.
;;;311            //
;;;312            if((g_sOutBuffers[0].pulData == 0) && (g_sOutBuffers[1].pulData == 0))
000068  6820              LDR      r0,[r4,#0]  ; g_sOutBuffers
00006a  2800              CMP      r0,#0
00006c  d103              BNE      |L5.118|
00006e  68e0              LDR      r0,[r4,#0xc]  ; g_sOutBuffers
000070  2800              CMP      r0,#0
000072  d100              BNE      |L5.118|
;;;313            {
;;;314                HWREGBITW(&g_ulDMAFlags, FLAG_TX_PENDING) = 0;
000074  6035              STR      r5,[r6,#0]
                  |L5.118|
;;;315            }
;;;316        }
;;;317    }
000076  e8bd81f0          POP      {r4-r8,pc}
;;;318    
                          ENDP

00007a  0000              DCW      0x0000
                  |L5.124|
                          DCD      0x40054000
                  |L5.128|
                          DCD      ||.data||+0x4
                  |L5.132|
                          DCD      0x02000004
                  |L5.136|
                          DCD      ||.bss||

                          AREA ||i.SoundSampleRateGet||, CODE, READONLY, ALIGN=2

                  SoundSampleRateGet PROC
;;;596    unsigned long
;;;597    SoundSampleRateGet(void)
000000  4801              LDR      r0,|L6.8|
;;;598    {
;;;599        return(g_ulSampleRate);
000002  68c0              LDR      r0,[r0,#0xc]  ; g_ulSampleRate
;;;600    }
000004  4770              BX       lr
;;;601    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.data||

                          AREA ||i.SoundSetFormat||, CODE, READONLY, ALIGN=2

                  SoundSetFormat PROC
;;;334    void
;;;335    SoundSetFormat(unsigned long ulSampleRate, unsigned short usBitsPerSample,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;336                   unsigned short usChannels)
;;;337    {
;;;338        unsigned long ulFormat;
;;;339        unsigned long ulDMASetting;
;;;340        unsigned long ulI2SErrata;
;;;341    
;;;342        //
;;;343        // Save these values for use when configuring I2S.
;;;344        //
;;;345        g_usChannels = usChannels;
000004  4e3e              LDR      r6,|L7.256|
;;;346        g_usBitsPerSample = usBitsPerSample;
;;;347    
;;;348        //
;;;349        // Configure the I2S master clock for internal.
;;;350        //
;;;351        I2SMasterClockSelect(I2S0_BASE, I2S_TX_MCLK_INT);
000006  4f3f              LDR      r7,|L7.260|
000008  4605              MOV      r5,r0                 ;337
00000a  8072              STRH     r2,[r6,#2]            ;345
00000c  460c              MOV      r4,r1                 ;337
00000e  6131              STR      r1,[r6,#0x10]  ; g_usBitsPerSample
000010  2100              MOVS     r1,#0
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       I2SMasterClockSelect
;;;352    
;;;353        //
;;;354        // Configure the I2S to be a master.
;;;355        //
;;;356        ulFormat = I2S_CONFIG_FORMAT_I2S | I2S_CONFIG_CLK_MASTER;
;;;357    
;;;358        //
;;;359        // Check if the missing divisor bits need to be taken into account.
;;;360        //
;;;361        if(CLASS_IS_TEMPEST && REVISION_IS_B1)
000018  483b              LDR      r0,|L7.264|
00001a  6801              LDR      r1,[r0,#0]
00001c  4a3b              LDR      r2,|L7.268|
00001e  4011              ANDS     r1,r1,r2
000020  4a3b              LDR      r2,|L7.272|
000022  4291              CMP      r1,r2
000024  d107              BNE      |L7.54|
000026  6800              LDR      r0,[r0,#0]
000028  b280              UXTH     r0,r0
00002a  f5a07180          SUB      r1,r0,#0x100
00002e  3901              SUBS     r1,#1
000030  d101              BNE      |L7.54|
;;;362        {
;;;363            ulI2SErrata = 1;
000032  2001              MOVS     r0,#1
000034  e000              B        |L7.56|
                  |L7.54|
;;;364        }
;;;365        else
;;;366        {
;;;367            ulI2SErrata = 0;
000036  2000              MOVS     r0,#0
                  |L7.56|
;;;368        }
;;;369    
;;;370        //
;;;371        // Mono or Stereo formats.
;;;372        //
;;;373        if(g_usChannels == 1)
000038  8871              LDRH     r1,[r6,#2]  ; g_usChannels
;;;374        {
;;;375            //
;;;376            // 8 bit formats.
;;;377            //
;;;378            if(g_usBitsPerSample == 8)
;;;379            {
;;;380                //
;;;381                // On Tempest class devices rev B parts the divisor is
;;;382                // limited for lower samples rates (see erratum).
;;;383                //
;;;384                if((ulI2SErrata != 0) && (ulSampleRate < 24400))
;;;385                {
;;;386                    ulFormat |= I2S_CONFIG_WIRE_SIZE_32 | I2S_CONFIG_MODE_MONO |
;;;387                                I2S_CONFIG_SAMPLE_SIZE_8;
;;;388                    usBitsPerSample = 32;
;;;389                }
;;;390                else
;;;391                {
;;;392                    ulFormat |= I2S_CONFIG_WIRE_SIZE_8 | I2S_CONFIG_MODE_MONO |
;;;393                                I2S_CONFIG_SAMPLE_SIZE_8;
;;;394                }
;;;395            }
;;;396    
;;;397            //
;;;398            // 16-bit format
;;;399            //
;;;400            else if(g_usBitsPerSample == 16)
;;;401            {
;;;402                //
;;;403                // On Tempest class devices rev B parts the divisor is
;;;404                // limited for lower samples rates (see errata).
;;;405                //
;;;406                if((ulI2SErrata != 0) && (ulSampleRate < 12200))
00003a  f64272a8          MOV      r2,#0x2fa8
00003e  2901              CMP      r1,#1                 ;373
000040  6931              LDR      r1,[r6,#0x10]         ;373  ; g_usBitsPerSample
000042  d02d              BEQ      |L7.160|
;;;407                {
;;;408                    ulFormat |= I2S_CONFIG_WIRE_SIZE_32 | I2S_CONFIG_MODE_MONO |
;;;409                                I2S_CONFIG_SAMPLE_SIZE_16;
;;;410                    usBitsPerSample = 32;
;;;411                }
;;;412                else
;;;413                {
;;;414                    ulFormat |= I2S_CONFIG_WIRE_SIZE_16 | I2S_CONFIG_MODE_MONO |
;;;415                                I2S_CONFIG_SAMPLE_SIZE_16;
;;;416                }
;;;417            }
;;;418    
;;;419            //
;;;420            // 24-bit format
;;;421            //
;;;422            else if(g_usBitsPerSample == 24)
;;;423            {
;;;424                ulFormat |= I2S_CONFIG_WIRE_SIZE_24 | I2S_CONFIG_MODE_MONO |
;;;425                            I2S_CONFIG_SAMPLE_SIZE_24;
;;;426            }
;;;427            else
;;;428            {
;;;429                ulFormat |= I2S_CONFIG_WIRE_SIZE_32 | I2S_CONFIG_MODE_MONO |
;;;430                            I2S_CONFIG_SAMPLE_SIZE_32;
;;;431            }
;;;432        }
;;;433    
;;;434        //
;;;435        // Stereo formats
;;;436        //
;;;437        else
;;;438        {
;;;439            //
;;;440            // 8-bit format
;;;441            //
;;;442            if(g_usBitsPerSample == 8)
000044  2908              CMP      r1,#8
000046  d045              BEQ      |L7.212|
;;;443            {
;;;444                //
;;;445                // On Tempest class devices rev B parts the divisor is
;;;446                // limited for lower samples rates (see errata).
;;;447                //
;;;448                 if((ulI2SErrata != 0) && (ulSampleRate < 12200))
;;;449                {
;;;450                    ulFormat |= I2S_CONFIG_WIRE_SIZE_32 |
;;;451                                I2S_CONFIG_MODE_COMPACT_8 |
;;;452                                I2S_CONFIG_SAMPLE_SIZE_8;
;;;453                    usBitsPerSample = 32;
;;;454                }
;;;455                else
;;;456                {
;;;457                    ulFormat |= I2S_CONFIG_WIRE_SIZE_8 |
;;;458                                I2S_CONFIG_MODE_COMPACT_8 |
;;;459                                I2S_CONFIG_SAMPLE_SIZE_8;
;;;460                }
;;;461    
;;;462            }
;;;463    
;;;464            //
;;;465            // 16-bit format
;;;466            //
;;;467            else if(g_usBitsPerSample == 16)
000048  2910              CMP      r1,#0x10
00004a  d04a              BEQ      |L7.226|
;;;468            {
;;;469                if((ulI2SErrata != 0) && (ulSampleRate < 12200))
;;;470                {
;;;471                    ulFormat |= I2S_CONFIG_WIRE_SIZE_32 |
;;;472                                I2S_CONFIG_MODE_COMPACT_16 |
;;;473                                I2S_CONFIG_SAMPLE_SIZE_16;
;;;474                    usBitsPerSample = 32;
;;;475                }
;;;476                else
;;;477                {
;;;478                    ulFormat |= I2S_CONFIG_WIRE_SIZE_16 |
;;;479                                I2S_CONFIG_MODE_COMPACT_16 |
;;;480                                I2S_CONFIG_SAMPLE_SIZE_16;
;;;481                }
;;;482            }
;;;483    
;;;484            //
;;;485            // 24-bit format
;;;486            //
;;;487            else if(g_usBitsPerSample == 24)
00004c  2918              CMP      r1,#0x18
00004e  d050              BEQ      |L7.242|
;;;488            {
;;;489                ulFormat |= I2S_CONFIG_WIRE_SIZE_24 | I2S_CONFIG_MODE_DUAL |
;;;490                            I2S_CONFIG_SAMPLE_SIZE_24;
;;;491            }
;;;492            else
;;;493            {
;;;494                ulFormat |= I2S_CONFIG_WIRE_SIZE_32 | I2S_CONFIG_MODE_DUAL |
000050  4930              LDR      r1,|L7.276|
                  |L7.82|
;;;495                            I2S_CONFIG_SAMPLE_SIZE_32;
;;;496            }
;;;497        }
;;;498    
;;;499        //
;;;500        // Configure the I2S TX format.
;;;501        //
;;;502        I2STxConfigSet(I2S0_BASE, ulFormat);
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       I2STxConfigSet
;;;503    
;;;504        //
;;;505        // Set the MCLK rate and save it for conversion back to sample rate.
;;;506        // The multiply by 8 is due to a 4X oversample rate plus a factor of two
;;;507        // since the data is always stereo on the I2S interface.
;;;508        //
;;;509        g_ulSampleRate = SysCtlI2SMClkSet(0, (ulSampleRate *
000058  4365              MULS     r5,r4,r5
00005a  00e9              LSLS     r1,r5,#3
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       SysCtlI2SMClkSet
;;;510                                          usBitsPerSample * 8));
;;;511    
;;;512        //
;;;513        // Convert the MCLK rate to sample rate.
;;;514        //
;;;515        g_ulSampleRate = g_ulSampleRate / (usBitsPerSample * 8);
000062  00e1              LSLS     r1,r4,#3
000064  fbb0f0f1          UDIV     r0,r0,r1
;;;516    
;;;517        //
;;;518        // Configure the I2S TX DMA channel to use high priority burst transfer.
;;;519        //
;;;520        ROM_uDMAChannelAttributeEnable(UDMA_CHANNEL_I2S0TX,
000068  f04f7580          MOV      r5,#0x1000000
00006c  60f0              STR      r0,[r6,#0xc]  ; g_ulSampleRate
00006e  6d68              LDR      r0,[r5,#0x54]
000070  2105              MOVS     r1,#5
000072  6ac2              LDR      r2,[r0,#0x2c]
000074  201d              MOVS     r0,#0x1d
000076  4790              BLX      r2
;;;521                                       (UDMA_ATTR_USEBURST |
;;;522                                        UDMA_ATTR_HIGH_PRIORITY));
;;;523    
;;;524        //
;;;525        // Set the DMA channel configuration.
;;;526        //
;;;527        if(g_usChannels == 1)
000078  8870              LDRH     r0,[r6,#2]  ; g_usChannels
;;;528        {
;;;529            //
;;;530            // Handle Mono formats.
;;;531            //
;;;532            if(g_usBitsPerSample == 8)
;;;533            {
;;;534                //
;;;535                // The transfer size is 8 bits from the TX buffer to the TX FIFO.
;;;536                //
;;;537                ulDMASetting = UDMA_SIZE_8 | UDMA_SRC_INC_8 |
;;;538                               UDMA_DST_INC_NONE | UDMA_ARB_2;
;;;539            }
;;;540            else
;;;541            {
;;;542                //
;;;543                // The transfer size is 16 bits from the TX buffer to the TX FIFO.
;;;544                //
;;;545                ulDMASetting = UDMA_SIZE_16 | UDMA_SRC_INC_16 |
00007a  4c27              LDR      r4,|L7.280|
00007c  2801              CMP      r0,#1                 ;527
00007e  6930              LDR      r0,[r6,#0x10]         ;527  ; g_usBitsPerSample
000080  d039              BEQ      |L7.246|
;;;546                               UDMA_DST_INC_NONE | UDMA_ARB_2;
;;;547            }
;;;548        }
;;;549        else
;;;550        {
;;;551            //
;;;552            // Handle Stereo formats.
;;;553            //
;;;554            if(g_usBitsPerSample == 8)
000082  2808              CMP      r0,#8
000084  d000              BEQ      |L7.136|
;;;555            {
;;;556                //
;;;557                // The transfer size is 16 bits(stereo 8 bits) from the TX buffer
;;;558                // to the TX FIFO.
;;;559                //
;;;560                ulDMASetting = UDMA_SIZE_16 | UDMA_SRC_INC_16 |
;;;561                               UDMA_DST_INC_NONE | UDMA_ARB_2;
;;;562            }
;;;563            else
;;;564            {
;;;565                //
;;;566                // The transfer size is 32 bits(stereo 16 bits) from the TX buffer
;;;567                // to the TX FIFO.
;;;568                //
;;;569                ulDMASetting = UDMA_SIZE_32 | UDMA_SRC_INC_32 |
000086  4c25              LDR      r4,|L7.284|
                  |L7.136|
;;;570                               UDMA_DST_INC_NONE | UDMA_ARB_2;
;;;571            }
;;;572        }
;;;573    
;;;574        //
;;;575        // Configure the DMA settings for this channel.
;;;576        //
;;;577        ROM_uDMAChannelControlSet(UDMA_CHANNEL_I2S0TX | UDMA_PRI_SELECT,
000088  6d68              LDR      r0,[r5,#0x54]
00008a  4621              MOV      r1,r4
00008c  6b82              LDR      r2,[r0,#0x38]
00008e  201d              MOVS     r0,#0x1d
000090  4790              BLX      r2
;;;578                                  ulDMASetting);
;;;579        ROM_uDMAChannelControlSet(UDMA_CHANNEL_I2S0TX | UDMA_ALT_SELECT,
000092  6d68              LDR      r0,[r5,#0x54]
000094  4621              MOV      r1,r4
000096  6b82              LDR      r2,[r0,#0x38]
000098  e8bd41f0          POP      {r4-r8,lr}
00009c  203d              MOVS     r0,#0x3d
00009e  4710              BX       r2
                  |L7.160|
0000a0  2908              CMP      r1,#8                 ;378
0000a2  d005              BEQ      |L7.176|
0000a4  2910              CMP      r1,#0x10              ;400
0000a6  d00c              BEQ      |L7.194|
0000a8  2918              CMP      r1,#0x18              ;422
0000aa  d011              BEQ      |L7.208|
0000ac  491c              LDR      r1,|L7.288|
0000ae  e7d0              B        |L7.82|
                  |L7.176|
0000b0  b128              CBZ      r0,|L7.190|
0000b2  f6457050          MOV      r0,#0x5f50            ;384
0000b6  4285              CMP      r5,r0                 ;384
0000b8  d201              BCS      |L7.190|
0000ba  491a              LDR      r1,|L7.292|
0000bc  e015              B        |L7.234|
                  |L7.190|
0000be  491a              LDR      r1,|L7.296|
0000c0  e7c7              B        |L7.82|
                  |L7.194|
0000c2  b118              CBZ      r0,|L7.204|
0000c4  4295              CMP      r5,r2                 ;406
0000c6  d201              BCS      |L7.204|
0000c8  4918              LDR      r1,|L7.300|
0000ca  e00e              B        |L7.234|
                  |L7.204|
0000cc  4918              LDR      r1,|L7.304|
0000ce  e7c0              B        |L7.82|
                  |L7.208|
0000d0  4918              LDR      r1,|L7.308|
0000d2  e7be              B        |L7.82|
                  |L7.212|
0000d4  b118              CBZ      r0,|L7.222|
0000d6  4295              CMP      r5,r2                 ;448
0000d8  d201              BCS      |L7.222|
0000da  4917              LDR      r1,|L7.312|
0000dc  e005              B        |L7.234|
                  |L7.222|
0000de  4917              LDR      r1,|L7.316|
0000e0  e7b7              B        |L7.82|
                  |L7.226|
0000e2  b120              CBZ      r0,|L7.238|
0000e4  4295              CMP      r5,r2                 ;469
0000e6  d202              BCS      |L7.238|
0000e8  4915              LDR      r1,|L7.320|
                  |L7.234|
0000ea  2420              MOVS     r4,#0x20              ;474
0000ec  e7b1              B        |L7.82|
                  |L7.238|
0000ee  4915              LDR      r1,|L7.324|
0000f0  e7af              B        |L7.82|
                  |L7.242|
0000f2  4915              LDR      r1,|L7.328|
0000f4  e7ad              B        |L7.82|
                  |L7.246|
0000f6  2808              CMP      r0,#8                 ;532
0000f8  d1c6              BNE      |L7.136|
0000fa  4c14              LDR      r4,|L7.332|
0000fc  e7c4              B        |L7.136|
;;;580                                  ulDMASetting);
;;;581    }
;;;582    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L7.256|
                          DCD      ||.data||
                  |L7.260|
                          DCD      0x40054000
                  |L7.264|
                          DCD      0x400fe000
                  |L7.268|
                          DCD      0x70ff0000
                  |L7.272|
                          DCD      0x10040000
                  |L7.276|
                          DCD      0x14407df0
                  |L7.280|
                          DCD      0xd5004000
                  |L7.284|
                          DCD      0xea004000
                  |L7.288|
                          DCD      0x16407df0
                  |L7.292|
                          DCD      0x16401df0
                  |L7.296|
                          DCD      0x16401c70
                  |L7.300|
                          DCD      0x16403df0
                  |L7.304|
                          DCD      0x16403cf0
                  |L7.308|
                          DCD      0x16405d70
                  |L7.312|
                          DCD      0x17401df0
                  |L7.316|
                          DCD      0x17401c70
                  |L7.320|
                          DCD      0x15403df0
                  |L7.324|
                          DCD      0x15403cf0
                  |L7.328|
                          DCD      0x14405d70
                  |L7.332|
                          DCD      0xc0004000

                          AREA ||i.SoundVolumeDown||, CODE, READONLY, ALIGN=2

                  SoundVolumeDown PROC
;;;786    void
;;;787    SoundVolumeDown(unsigned long ulPercent)
000000  4a05              LDR      r2,|L8.24|
;;;788    {
;;;789        //
;;;790        // Do not let the volume go below 0%.
;;;791        //
;;;792        if(g_ucVolume < ulPercent)
000002  7811              LDRB     r1,[r2,#0]  ; g_ucVolume
000004  4281              CMP      r1,r0
000006  d201              BCS      |L8.12|
;;;793        {
;;;794            //
;;;795            // Set the volume to the minimum.
;;;796            //
;;;797            g_ucVolume = 0;
000008  2000              MOVS     r0,#0
00000a  e000              B        |L8.14|
                  |L8.12|
;;;798        }
;;;799        else
;;;800        {
;;;801            //
;;;802            // Decrease the volume by the specified amount.
;;;803            //
;;;804            g_ucVolume -= ulPercent;
00000c  1a08              SUBS     r0,r1,r0
                  |L8.14|
00000e  7010              STRB     r0,[r2,#0]
;;;805        }
;;;806    
;;;807        //
;;;808        // Set the new volume.
;;;809        //
;;;810        SoundVolumeSet(g_ucVolume);
000010  b2c0              UXTB     r0,r0
000012  f7ffbffe          B.W      DACVolumeSet
;;;811    }
;;;812    
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      ||.data||

                          AREA ||i.SoundVolumeGet||, CODE, READONLY, ALIGN=2

                  SoundVolumeGet PROC
;;;764    unsigned char
;;;765    SoundVolumeGet(void)
000000  4801              LDR      r0,|L9.8|
;;;766    {
;;;767        //
;;;768        // Return the current Audio Volume.
;;;769        //
;;;770        return(g_ucVolume);
000002  7800              LDRB     r0,[r0,#0]  ; g_ucVolume
;;;771    }
000004  4770              BX       lr
;;;772    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      ||.data||

                          AREA ||i.SoundVolumeSet||, CODE, READONLY, ALIGN=1

                  SoundVolumeSet PROC
;;;740    void
;;;741    SoundVolumeSet(unsigned long ulPercent)
000000  f7ffbffe          B.W      DACVolumeSet
;;;742    {
;;;743        //
;;;744        // Make sure we were passed a valid volume setting.
;;;745        //
;;;746        ASSERT(ulPercent <= 100);
;;;747    
;;;748        //
;;;749        // Set the volume to the desired level.
;;;750        //
;;;751        DACVolumeSet(ulPercent);
;;;752    }
;;;753    
                          ENDP


                          AREA ||i.SoundVolumeUp||, CODE, READONLY, ALIGN=2

                  SoundVolumeUp PROC
;;;826    void
;;;827    SoundVolumeUp(unsigned long ulPercent)
000000  4905              LDR      r1,|L11.24|
;;;828    {
;;;829        //
;;;830        // Increase the volume by the specified amount.
;;;831        //
;;;832        g_ucVolume += ulPercent;
000002  780a              LDRB     r2,[r1,#0]  ; g_ucVolume
000004  4410              ADD      r0,r0,r2
000006  b2c0              UXTB     r0,r0
000008  7008              STRB     r0,[r1,#0]
;;;833    
;;;834        //
;;;835        // Do not let the volume go above 100%.
;;;836        //
;;;837        if(g_ucVolume > 100)
00000a  2864              CMP      r0,#0x64
00000c  d901              BLS      |L11.18|
;;;838        {
;;;839            //
;;;840            // Set the volume to the maximum.
;;;841            //
;;;842            g_ucVolume = 100;
00000e  2064              MOVS     r0,#0x64
000010  7008              STRB     r0,[r1,#0]
                  |L11.18|
;;;843        }
;;;844    
;;;845        //
;;;846        // Set the new volume.
;;;847        //
;;;848        SoundVolumeSet(g_ucVolume);
000012  b2c0              UXTB     r0,r0
000014  f7ffbffe          B.W      DACVolumeSet
;;;849    }
;;;850    
                          ENDP

                  |L11.24|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_sOutBuffers
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  g_ucVolume
000000  6400              DCB      0x64,0x00
                  g_usChannels
000002  0000              DCB      0x00,0x00
                  g_ulDMAFlags
                          DCD      0x00000000
                  g_ulPlaying
                          DCD      0x00000000
                  g_ulSampleRate
                          DCD      0x00000000
                  g_usBitsPerSample
                          DCD      0x00000000
