; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\auto_task.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\auto_task.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 -DUART_BUFFERED --omf_browse=.\rvmdk\auto_task.crf auto_task.c]
                          THUMB

                          AREA ||i.AutoTask||, CODE, READONLY, ALIGN=2

                  AutoTask PROC
;;;81     void
;;;82     AutoTask(void *pvParam)
000000  b570              PUSH     {r4-r6,lr}
;;;83     {
;;;84         static tEvalbotState sState = EVALBOT_STATE_IDLE;
;;;85         static unsigned long ulLastTicks = 0;
;;;86         static unsigned long ulDurationTicks = 0;
;;;87     
;;;88         //
;;;89         // Process according to the current state
;;;90         //
;;;91         switch(sState)
000002  4c60              LDR      r4,|L1.388|
000004  2501              MOVS     r5,#1
;;;92         {
;;;93             //
;;;94             // IDLE - in this state, the EVALBOT is waiting for a press of
;;;95             // button 1, which will start the motion.
;;;96             //
;;;97             case EVALBOT_STATE_IDLE:
;;;98             {
;;;99                 //
;;;100                // Check for press of button 1
;;;101                //
;;;102                if(!PushButtonGetStatus(BUTTON_1))
;;;103                {
;;;104                    //
;;;105                    // Whenever there is an external event, add to the entropy
;;;106                    // of the random number generator.
;;;107                    //
;;;108                    RandomAddEntropy(SchedulerTickCountGet());
;;;109                    RandomSeed();
;;;110    
;;;111                    //
;;;112                    // Get the current tick, which will be used for measuring
;;;113                    // the duration of time in a state.
;;;114                    //
;;;115                    ulLastTicks = SchedulerTickCountGet();
;;;116    
;;;117                    //
;;;118                    // Generate a random duration in timer ticks.
;;;119                    //
;;;120                    ulDurationTicks = (RandomNumber() % DRIVE_DURATION_VAR) +
000006  f2405614          MOV      r6,#0x514
00000a  7820              LDRB     r0,[r4,#0]            ;91  ; sState
00000c  b300              CBZ      r0,|L1.80|
00000e  2801              CMP      r0,#1                 ;91
000010  d03d              BEQ      |L1.142|
000012  2802              CMP      r0,#2                 ;91
000014  d17e              BNE      |L1.276|
;;;121                                      DRIVE_DURATION_MIN;
;;;122    
;;;123                    //
;;;124                    // Command the drive to start running forward, update the
;;;125                    // state machine, and notify action via serial port
;;;126                    //
;;;127                    DriveRun(MOTOR_DRIVE_FORWARD, AUTO_FORWARD_SPEED);
;;;128                    sState = EVALBOT_STATE_DRIVING;
;;;129                    UARTprintf("button 1 - driving for %u\n", ulDurationTicks);
;;;130                }
;;;131                break;
;;;132            }
;;;133    
;;;134            //
;;;135            // DRIVING - in this state the EVALBOT is driving forward.  It is
;;;136            // waiting for one of the bump sensors, which will initiate a turn, or
;;;137            // the user to press button 2 (to stop), or for the driving duration
;;;138            // to time out, initiating a random turn.
;;;139            //
;;;140            case EVALBOT_STATE_DRIVING:
;;;141            {
;;;142                //
;;;143                // Check for left bumper sensor
;;;144                //
;;;145                if(!BumpSensorGetStatus(LEFT_SIDE))
;;;146                {
;;;147                    //
;;;148                    // Play bumper sound
;;;149                    //
;;;150                    SoundTaskPlay(g_pcBumpSound);
;;;151    
;;;152                    //
;;;153                    // Update random entropy
;;;154                    //
;;;155                    RandomAddEntropy(SchedulerTickCountGet());
;;;156                    RandomSeed();
;;;157    
;;;158                    //
;;;159                    // Save current tick, and compute random turn duration
;;;160                    //
;;;161                    ulLastTicks = SchedulerTickCountGet();
;;;162                    ulDurationTicks = (RandomNumber() % TURN_DURATION_VAR) +
;;;163                                      TURN_DURATION_MIN;
;;;164    
;;;165                    //
;;;166                    // Command the drive to start turning, update the
;;;167                    // state machine, and notify action via serial port
;;;168                    //
;;;169                    DriveRun(MOTOR_DRIVE_TURN_RIGHT, AUTO_TURN_SPEED);
;;;170                    sState = EVALBOT_STATE_TURNING;
;;;171                    UARTprintf("left sensor - turn right for %u\n", ulDurationTicks);
;;;172                }
;;;173    
;;;174                //
;;;175                // Else, check for right bumper sensor
;;;176                //
;;;177                else if(!BumpSensorGetStatus(RIGHT_SIDE))
;;;178                {
;;;179                    //
;;;180                    // Play bumper sound
;;;181                    //
;;;182                    SoundTaskPlay(g_pcBumpSound);
;;;183    
;;;184                    //
;;;185                    // Update random entropy
;;;186                    //
;;;187                    RandomAddEntropy(SchedulerTickCountGet());
;;;188                    RandomSeed();
;;;189    
;;;190                    //
;;;191                    // Save current tick, and compute random turn duration
;;;192                    //
;;;193                    ulLastTicks = SchedulerTickCountGet();
;;;194                    ulDurationTicks = (RandomNumber() % TURN_DURATION_VAR) +
;;;195                                      TURN_DURATION_MIN;
;;;196    
;;;197                    //
;;;198                    // Command the drive to start turning, update the
;;;199                    // state machine, and notify action via serial port
;;;200                    //
;;;201                    DriveRun(MOTOR_DRIVE_TURN_LEFT, AUTO_TURN_SPEED);
;;;202                    sState = EVALBOT_STATE_TURNING;
;;;203                    UARTprintf("right sensor - turn left for %u\n", ulDurationTicks);
;;;204                }
;;;205    
;;;206                //
;;;207                // Else, check for user press of button 2
;;;208                //
;;;209                else if(!PushButtonGetStatus(BUTTON_2))
;;;210                {
;;;211                    //
;;;212                    // Update random entropy
;;;213                    //
;;;214                    RandomAddEntropy(SchedulerTickCountGet());
;;;215                    RandomSeed();
;;;216    
;;;217                    //
;;;218                    // Command the drive to stop the motion
;;;219                    //
;;;220                    DriveRun(MOTOR_DRIVE_FORWARD, 0);
;;;221                    DriveStop();
;;;222    
;;;223                    //
;;;224                    // Update the state machine and notify action via serial port
;;;225                    //
;;;226                    sState = EVALBOT_STATE_IDLE;
;;;227                    UARTprintf("button 2 - stopping\n");
;;;228                }
;;;229    
;;;230                //
;;;231                // Else, check to see if the (random) drive duration has timed
;;;232                // out
;;;233                //
;;;234                else if(SchedulerElapsedTicksGet(ulLastTicks) > ulDurationTicks)
;;;235                {
;;;236                    //
;;;237                    // Save current tick, and compute random turn duration
;;;238                    //
;;;239                    ulLastTicks = SchedulerTickCountGet();
;;;240                    ulDurationTicks = (RandomNumber() % TURN_DURATION_VAR) +
;;;241                                      TURN_DURATION_MIN;
;;;242    
;;;243                    //
;;;244                    // Command the drive to turn, randomly selecting left or
;;;245                    // right turn
;;;246                    //
;;;247                    DriveRun((RandomNumber() & 1) ?
;;;248                                  MOTOR_DRIVE_TURN_LEFT : MOTOR_DRIVE_TURN_RIGHT,
;;;249                                  AUTO_TURN_SPEED);
;;;250    
;;;251                    //
;;;252                    // Update the state and notify the user via serial port
;;;253                    //
;;;254                    sState = EVALBOT_STATE_TURNING;
;;;255                    UARTprintf("random turn - turn for %u\n", ulDurationTicks);
;;;256                }
;;;257    
;;;258                //
;;;259                // Done with this state
;;;260                //
;;;261                break;
;;;262            }
;;;263    
;;;264            //
;;;265            // In this state, EVALBOT is turning.  It will continue to turn
;;;266            // until the randomly chosen turn duration has elapsed, at which time
;;;267            // it will then resume driving forward
;;;268            //
;;;269            case EVALBOT_STATE_TURNING:
;;;270            {
;;;271                if(SchedulerElapsedTicksGet(ulLastTicks) > ulDurationTicks)
000016  6860              LDR      r0,[r4,#4]  ; ulLastTicks
000018  f7fffffe          BL       SchedulerElapsedTicksGet
00001c  68a1              LDR      r1,[r4,#8]  ; ulDurationTicks
00001e  4288              CMP      r0,r1
000020  d978              BLS      |L1.276|
;;;272                {
;;;273                    //
;;;274                    // Get the current tick, and determine a random drive duration
;;;275                    //
;;;276                    ulLastTicks = SchedulerTickCountGet();
000022  f7fffffe          BL       SchedulerTickCountGet
;;;277                    ulDurationTicks = (RandomNumber() % DRIVE_DURATION_VAR) +
000026  6060              STR      r0,[r4,#4]  ; ulLastTicks
000028  f7fffffe          BL       RandomNumber
00002c  fbb0f1f6          UDIV     r1,r0,r6
000030  fb060011          MLS      r0,r6,r1,r0
000034  f500702f          ADD      r0,r0,#0x2bc
;;;278                                      DRIVE_DURATION_MIN;
;;;279    
;;;280                    //
;;;281                    // Command the drive to go forward, update the state machine
;;;282                    // and notify action via serial port
;;;283                    //
;;;284                    DriveRun(MOTOR_DRIVE_FORWARD, AUTO_FORWARD_SPEED);
000038  60a0              STR      r0,[r4,#8]  ; ulDurationTicks
00003a  2128              MOVS     r1,#0x28
00003c  2003              MOVS     r0,#3
00003e  f7fffffe          BL       DriveRun
;;;285                    sState = EVALBOT_STATE_DRIVING;
000042  7025              STRB     r5,[r4,#0]
;;;286                    UARTprintf("done turning, forward for %u\n", ulDurationTicks);
000044  68a1              LDR      r1,[r4,#8]  ; ulDurationTicks
000046  a050              ADR      r0,|L1.392|
                  |L1.72|
000048  e8bd4070          POP      {r4-r6,lr}
00004c  f7ffbffe          B.W      UARTprintf
                  |L1.80|
000050  2000              MOVS     r0,#0                 ;102
000052  f7fffffe          BL       PushButtonGetStatus
000056  2800              CMP      r0,#0                 ;102
000058  d15c              BNE      |L1.276|
00005a  f7fffffe          BL       SchedulerTickCountGet
00005e  f7fffffe          BL       RandomAddEntropy
000062  f7fffffe          BL       RandomSeed
000066  f7fffffe          BL       SchedulerTickCountGet
00006a  6060              STR      r0,[r4,#4]            ;120  ; ulLastTicks
00006c  f7fffffe          BL       RandomNumber
000070  fbb0f1f6          UDIV     r1,r0,r6              ;120
000074  fb060011          MLS      r0,r6,r1,r0           ;120
000078  f500702f          ADD      r0,r0,#0x2bc          ;120
00007c  60a0              STR      r0,[r4,#8]            ;127  ; ulDurationTicks
00007e  2128              MOVS     r1,#0x28              ;127
000080  2003              MOVS     r0,#3                 ;127
000082  f7fffffe          BL       DriveRun
000086  7025              STRB     r5,[r4,#0]            ;128
000088  a047              ADR      r0,|L1.424|
00008a  68a1              LDR      r1,[r4,#8]            ;129  ; ulDurationTicks
00008c  e7dc              B        |L1.72|
                  |L1.142|
00008e  2000              MOVS     r0,#0                 ;145
000090  f7fffffe          BL       BumpSensorGetStatus
000094  2502              MOVS     r5,#2                 ;91
000096  26c8              MOVS     r6,#0xc8              ;162
000098  b330              CBZ      r0,|L1.232|
00009a  2001              MOVS     r0,#1                 ;177
00009c  f7fffffe          BL       BumpSensorGetStatus
0000a0  2800              CMP      r0,#0                 ;177
0000a2  d03f              BEQ      |L1.292|
0000a4  2001              MOVS     r0,#1                 ;209
0000a6  f7fffffe          BL       PushButtonGetStatus
0000aa  2800              CMP      r0,#0                 ;209
0000ac  d056              BEQ      |L1.348|
0000ae  6860              LDR      r0,[r4,#4]            ;234  ; ulLastTicks
0000b0  f7fffffe          BL       SchedulerElapsedTicksGet
0000b4  68a1              LDR      r1,[r4,#8]            ;234  ; ulDurationTicks
0000b6  4288              CMP      r0,r1                 ;234
0000b8  d963              BLS      |L1.386|
0000ba  f7fffffe          BL       SchedulerTickCountGet
0000be  6060              STR      r0,[r4,#4]            ;240  ; ulLastTicks
0000c0  f7fffffe          BL       RandomNumber
0000c4  fbb0f1f6          UDIV     r1,r0,r6              ;240
0000c8  fb060011          MLS      r0,r6,r1,r0           ;240
0000cc  30c8              ADDS     r0,r0,#0xc8           ;240
0000ce  60a0              STR      r0,[r4,#8]            ;247  ; ulDurationTicks
0000d0  f7fffffe          BL       RandomNumber
0000d4  f3400000          SBFX     r0,r0,#0,#1           ;247
0000d8  1c40              ADDS     r0,r0,#1              ;247
0000da  2119              MOVS     r1,#0x19              ;247
0000dc  f7fffffe          BL       DriveRun
0000e0  7025              STRB     r5,[r4,#0]            ;254
0000e2  a038              ADR      r0,|L1.452|
0000e4  68a1              LDR      r1,[r4,#8]            ;255  ; ulDurationTicks
0000e6  e7af              B        |L1.72|
                  |L1.232|
0000e8  483d              LDR      r0,|L1.480|
0000ea  f7fffffe          BL       SoundTaskPlay
0000ee  f7fffffe          BL       SchedulerTickCountGet
0000f2  f7fffffe          BL       RandomAddEntropy
0000f6  f7fffffe          BL       RandomSeed
0000fa  f7fffffe          BL       SchedulerTickCountGet
0000fe  6060              STR      r0,[r4,#4]            ;162  ; ulLastTicks
000100  f7fffffe          BL       RandomNumber
000104  fbb0f1f6          UDIV     r1,r0,r6              ;162
000108  fb060011          MLS      r0,r6,r1,r0           ;162
00010c  30c8              ADDS     r0,r0,#0xc8           ;162
00010e  2119              MOVS     r1,#0x19              ;169
000110  60a0              STR      r0,[r4,#8]            ;169  ; ulDurationTicks
000112  e000              B        |L1.278|
                  |L1.276|
000114  e035              B        |L1.386|
                  |L1.278|
000116  2001              MOVS     r0,#1                 ;169
000118  f7fffffe          BL       DriveRun
00011c  7025              STRB     r5,[r4,#0]            ;170
00011e  a031              ADR      r0,|L1.484|
000120  68a1              LDR      r1,[r4,#8]            ;171  ; ulDurationTicks
000122  e791              B        |L1.72|
                  |L1.292|
000124  482e              LDR      r0,|L1.480|
000126  f7fffffe          BL       SoundTaskPlay
00012a  f7fffffe          BL       SchedulerTickCountGet
00012e  f7fffffe          BL       RandomAddEntropy
000132  f7fffffe          BL       RandomSeed
000136  f7fffffe          BL       SchedulerTickCountGet
00013a  6060              STR      r0,[r4,#4]            ;194  ; ulLastTicks
00013c  f7fffffe          BL       RandomNumber
000140  fbb0f1f6          UDIV     r1,r0,r6              ;194
000144  fb060011          MLS      r0,r6,r1,r0           ;194
000148  30c8              ADDS     r0,r0,#0xc8           ;194
00014a  60a0              STR      r0,[r4,#8]            ;201  ; ulDurationTicks
00014c  2119              MOVS     r1,#0x19              ;201
00014e  2000              MOVS     r0,#0                 ;201
000150  f7fffffe          BL       DriveRun
000154  7025              STRB     r5,[r4,#0]            ;202
000156  a02c              ADR      r0,|L1.520|
000158  68a1              LDR      r1,[r4,#8]            ;203  ; ulDurationTicks
00015a  e775              B        |L1.72|
                  |L1.348|
00015c  f7fffffe          BL       SchedulerTickCountGet
000160  f7fffffe          BL       RandomAddEntropy
000164  f7fffffe          BL       RandomSeed
000168  2100              MOVS     r1,#0                 ;220
00016a  2003              MOVS     r0,#3                 ;220
00016c  f7fffffe          BL       DriveRun
000170  f7fffffe          BL       DriveStop
000174  2000              MOVS     r0,#0                 ;226
000176  7020              STRB     r0,[r4,#0]            ;226
000178  e8bd4070          POP      {r4-r6,lr}            ;227
00017c  a02b              ADR      r0,|L1.556|
00017e  f7ffbffe          B.W      UARTprintf
                  |L1.386|
;;;287                }
;;;288    
;;;289                //
;;;290                // Done with this state
;;;291                //
;;;292                break;
;;;293            }
;;;294        }
;;;295    }
000182  bd70              POP      {r4-r6,pc}
;;;296    
                          ENDP

                  |L1.388|
                          DCD      ||.data||
                  |L1.392|
000188  646f6e65          DCB      "done turning, forward for %u\n",0
00018c  20747572
000190  6e696e67
000194  2c20666f
000198  72776172
00019c  6420666f
0001a0  72202575
0001a4  0a00    
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L1.424|
0001a8  62757474          DCB      "button 1 - driving for %u\n",0
0001ac  6f6e2031
0001b0  202d2064
0001b4  72697669
0001b8  6e672066
0001bc  6f722025
0001c0  750a00  
0001c3  00                DCB      0
                  |L1.452|
0001c4  72616e64          DCB      "random turn - turn for %u\n",0
0001c8  6f6d2074
0001cc  75726e20
0001d0  2d207475
0001d4  726e2066
0001d8  6f722025
0001dc  750a00  
0001df  00                DCB      0
                  |L1.480|
                          DCD      g_pcBumpSound
                  |L1.484|
0001e4  6c656674          DCB      "left sensor - turn right for %u\n",0
0001e8  2073656e
0001ec  736f7220
0001f0  2d207475
0001f4  726e2072
0001f8  69676874
0001fc  20666f72
000200  2025750a
000204  00      
000205  00                DCB      0
000206  00                DCB      0
000207  00                DCB      0
                  |L1.520|
000208  72696768          DCB      "right sensor - turn left for %u\n",0
00020c  74207365
000210  6e736f72
000214  202d2074
000218  75726e20
00021c  6c656674
000220  20666f72
000224  2025750a
000228  00      
000229  00                DCB      0
00022a  00                DCB      0
00022b  00                DCB      0
                  |L1.556|
00022c  62757474          DCB      "button 2 - stopping\n",0
000230  6f6e2032
000234  202d2073
000238  746f7070
00023c  696e670a
000240  00      
000241  00                DCB      0
000242  00                DCB      0
000243  00                DCB      0

                          AREA ||i.AutoTaskInit||, CODE, READONLY, ALIGN=1

                  AutoTaskInit PROC
;;;303    void
;;;304    AutoTaskInit(void *pvParam)
000000  b510              PUSH     {r4,lr}
;;;305    {
;;;306        PushButtonsInit();
000002  f7fffffe          BL       PushButtonsInit
;;;307        BumpSensorsInit();
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      BumpSensorsInit
;;;308    }
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  sState
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  ulLastTicks
                          DCD      0x00000000
                  ulDurationTicks
                          DCD      0x00000000
