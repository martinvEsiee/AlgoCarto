; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\sensors.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\sensors.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 --omf_browse=.\rvmdk\sensors.crf ..\drivers\sensors.c]
                          THUMB

                          AREA ||i.BumpSensorDebouncer||, CODE, READONLY, ALIGN=2

                  BumpSensorDebouncer PROC
;;;176    void
;;;177    BumpSensorDebouncer(void)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {
;;;179        static unsigned char ucBumperClockA = 0;
;;;180        static unsigned char ucBumperClockB = 0;
;;;181        unsigned char ucData;
;;;182        unsigned char ucDelta;
;;;183    
;;;184        //
;;;185        // Read the current state of the hardware bump sensors
;;;186        //
;;;187        ucData = ROM_GPIOPinRead(GPIO_PORTE_BASE, GPIO_PIN_0 | GPIO_PIN_1);
000002  f04f7080          MOV      r0,#0x1000000
000006  2103              MOVS     r1,#3
000008  6a00              LDR      r0,[r0,#0x20]
00000a  6ac2              LDR      r2,[r0,#0x2c]
00000c  480a              LDR      r0,|L1.56|
00000e  4790              BLX      r2
;;;188    
;;;189        //
;;;190        // Determine bumpers that are in a different state from the debounced state
;;;191        //
;;;192        ucDelta = ucData ^ g_ucDebouncedBumpers;
000010  490a              LDR      r1,|L1.60|
000012  780d              LDRB     r5,[r1,#0]  ; g_ucDebouncedBumpers
;;;193    
;;;194        //
;;;195        // Increment the debounce counter by one
;;;196        //
;;;197        ucBumperClockA ^= ucBumperClockB;
000014  784b              LDRB     r3,[r1,#1]  ; ucBumperClockA
000016  788c              LDRB     r4,[r1,#2]  ; ucBumperClockB
000018  ea800205          EOR      r2,r0,r5              ;192
00001c  4063              EORS     r3,r3,r4
;;;198        ucBumperClockB = ~ucBumperClockB;
;;;199    
;;;200        //
;;;201        // Reset the debounce counter for any bumper that is unchanged
;;;202        //
;;;203        ucBumperClockA &= ucDelta;
00001e  4013              ANDS     r3,r3,r2
000020  704b              STRB     r3,[r1,#1]
;;;204        ucBumperClockB &= ucDelta;
000022  ea220404          BIC      r4,r2,r4
;;;205    
;;;206        //
;;;207        // Determine the new debounced bumper state based on the debounce
;;;208        // counter.
;;;209        //
;;;210        g_ucDebouncedBumpers &= ucBumperClockA | ucBumperClockB;
000026  4323              ORRS     r3,r3,r4
000028  708c              STRB     r4,[r1,#2]            ;204
00002a  ea030405          AND      r4,r3,r5
;;;211        g_ucDebouncedBumpers |= (~(ucBumperClockA | ucBumperClockB)) & ucData;
00002e  4398              BICS     r0,r0,r3
000030  4320              ORRS     r0,r0,r4
000032  7008              STRB     r0,[r1,#0]
;;;212    }
000034  bd70              POP      {r4-r6,pc}
;;;213    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x40024000
                  |L1.60|
                          DCD      ||.data||

                          AREA ||i.BumpSensorGetDebounced||, CODE, READONLY, ALIGN=2

                  BumpSensorGetDebounced PROC
;;;227    //*****************************************************************************
;;;228    tBoolean BumpSensorGetDebounced(tBumper eBumper)
000000  4906              LDR      r1,|L2.28|
;;;229    {
;;;230        tBoolean  status;
;;;231    
;;;232        //
;;;233        // Which sensor are we being asked to read?
;;;234        //
;;;235        switch (eBumper)
;;;236        {
;;;237            //
;;;238            // Return the state of the right sensor.
;;;239            //
;;;240            case BUMP_RIGHT:
;;;241            {
;;;242                status = g_ucDebouncedBumpers & GPIO_PIN_0 ? true : false;
000002  7809              LDRB     r1,[r1,#0]
000004  b130              CBZ      r0,|L2.20|
000006  2801              CMP      r0,#1                 ;235
000008  d001              BEQ      |L2.14|
;;;243                break;
;;;244            }
;;;245    
;;;246            //
;;;247            // Return the state of the left sensor.
;;;248            //
;;;249            case BUMP_LEFT:
;;;250            {
;;;251                status = g_ucDebouncedBumpers & GPIO_PIN_1 ? true : false;
;;;252                break;
;;;253            }
;;;254    
;;;255            //
;;;256            // This case should never be seen since tSide only contains two
;;;257            // possible values.  Some people have been known to cast integers
;;;258            // into enums, though, so....
;;;259            //
;;;260            default:
;;;261            {
;;;262                status = false;
00000a  2000              MOVS     r0,#0
;;;263                break;
;;;264            }
;;;265        }
;;;266    
;;;267        return (status);
;;;268    }
00000c  4770              BX       lr
                  |L2.14|
00000e  f0010001          AND      r0,r1,#1              ;242
000012  4770              BX       lr
                  |L2.20|
000014  f3c10040          UBFX     r0,r1,#1,#1           ;251
000018  4770              BX       lr
;;;269    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      ||.data||

                          AREA ||i.BumpSensorGetStatus||, CODE, READONLY, ALIGN=2

                  BumpSensorGetStatus PROC
;;;119    //*****************************************************************************
;;;120    tBoolean BumpSensorGetStatus (tBumper eBumper)
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122        tBoolean  status;
;;;123    
;;;124        //
;;;125        // Which sensor are we being asked to read?
;;;126        //
;;;127        switch (eBumper)
;;;128        {
;;;129            //
;;;130            // Return the state of the right sensor.
;;;131            //
;;;132            case BUMP_RIGHT:
;;;133            {
;;;134                status = ROM_GPIOPinRead(GPIO_PORTE_BASE, GPIO_PIN_0) ?
000002  4b0b              LDR      r3,|L3.48|
000004  f04f7180          MOV      r1,#0x1000000
000008  b148              CBZ      r0,|L3.30|
00000a  2801              CMP      r0,#1                 ;127
00000c  d001              BEQ      |L3.18|
;;;135                                         true : false;
;;;136                break;
;;;137            }
;;;138    
;;;139            //
;;;140            // Return the state of the left sensor.
;;;141            //
;;;142            case BUMP_LEFT:
;;;143            {
;;;144                status = ROM_GPIOPinRead(GPIO_PORTE_BASE, GPIO_PIN_1) ?
;;;145                                         true : false;
;;;146                break;
;;;147            }
;;;148    
;;;149            //
;;;150            // This case should never be seen since tSide only contains two
;;;151            // possible values.  Some people have been known to cast integers
;;;152            // into enums, though, so....
;;;153            //
;;;154            default:
;;;155            {
;;;156                status = false;
00000e  2000              MOVS     r0,#0
;;;157                break;
;;;158            }
;;;159        }
;;;160    
;;;161        return (status);
;;;162    }
000010  bd10              POP      {r4,pc}
                  |L3.18|
000012  6a08              LDR      r0,[r1,#0x20]         ;134
000014  2101              MOVS     r1,#1                 ;134
000016  6ac2              LDR      r2,[r0,#0x2c]         ;134
000018  e004              B        |L3.36|
                  |L3.26|
00001a  2001              MOVS     r0,#1                 ;135
00001c  bd10              POP      {r4,pc}
                  |L3.30|
00001e  6a08              LDR      r0,[r1,#0x20]         ;144
000020  2102              MOVS     r1,#2                 ;144
000022  6ac2              LDR      r2,[r0,#0x2c]         ;144
                  |L3.36|
000024  4618              MOV      r0,r3                 ;134
000026  4790              BLX      r2                    ;134
000028  2800              CMP      r0,#0                 ;134
00002a  d1f6              BNE      |L3.26|
00002c  bd10              POP      {r4,pc}
;;;163    
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      0x40024000

                          AREA ||i.BumpSensorsInit||, CODE, READONLY, ALIGN=2

                  BumpSensorsInit PROC
;;;91     void
;;;92     BumpSensorsInit (void)
000000  b570              PUSH     {r4-r6,lr}
;;;93     {
;;;94         //
;;;95         // Enable the GPIO ports used for the bump sensors.
;;;96         //
;;;97         ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
000002  f04f7480          MOV      r4,#0x1000000
000006  6c60              LDR      r0,[r4,#0x44]
000008  6981              LDR      r1,[r0,#0x18]
00000a  4809              LDR      r0,|L4.48|
00000c  4788              BLX      r1
;;;98     
;;;99         //
;;;100        // Configure the sensor GPIOs as pulled-up inputs.
;;;101        //
;;;102        ROM_GPIOPinTypeGPIOInput(GPIO_PORTE_BASE, GPIO_PIN_0 | GPIO_PIN_1);
00000e  6a20              LDR      r0,[r4,#0x20]
000010  4d08              LDR      r5,|L4.52|
000012  2103              MOVS     r1,#3
000014  6b82              LDR      r2,[r0,#0x38]
000016  4628              MOV      r0,r5
000018  4790              BLX      r2
;;;103        ROM_GPIOPadConfigSet(GPIO_PORTE_BASE, GPIO_PIN_0 | GPIO_PIN_1,
00001a  6a20              LDR      r0,[r4,#0x20]
00001c  230a              MOVS     r3,#0xa
00001e  2201              MOVS     r2,#1
000020  6944              LDR      r4,[r0,#0x14]
000022  4628              MOV      r0,r5
000024  46a4              MOV      r12,r4
000026  e8bd4070          POP      {r4-r6,lr}
00002a  2103              MOVS     r1,#3
00002c  4760              BX       r12
;;;104                             GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
;;;105    }
;;;106    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      0x20000010
                  |L4.52|
                          DCD      0x40024000

                          AREA ||i.WheelSensorDisable||, CODE, READONLY, ALIGN=2

                  WheelSensorDisable PROC
;;;372    void
;;;373    WheelSensorDisable(void)
000000  f04f7080          MOV      r0,#0x1000000
;;;374    {
;;;375        //
;;;376        // Turn off the LEDs by setting the pin low.
;;;377        //
;;;378        ROM_GPIOPinWrite(LEFT_RIGHT_IR_LED_PORT, LEFT_RIGHT_IR_LED_PIN, 0);
000004  2200              MOVS     r2,#0
000006  6a00              LDR      r0,[r0,#0x20]
000008  2140              MOVS     r1,#0x40
00000a  6803              LDR      r3,[r0,#0]
00000c  4800              LDR      r0,|L5.16|
00000e  4718              BX       r3
;;;379    }
;;;380    
                          ENDP

                  |L5.16|
                          DCD      0x40024000

                          AREA ||i.WheelSensorEnable||, CODE, READONLY, ALIGN=2

                  WheelSensorEnable PROC
;;;350    void
;;;351    WheelSensorEnable(void)
000000  f04f7080          MOV      r0,#0x1000000
;;;352    {
;;;353        //
;;;354        // Turn on the LEDs by setting the pin high.
;;;355        //
;;;356        ROM_GPIOPinWrite(LEFT_RIGHT_IR_LED_PORT, LEFT_RIGHT_IR_LED_PIN,
000004  2240              MOVS     r2,#0x40
000006  6a00              LDR      r0,[r0,#0x20]
000008  4611              MOV      r1,r2
00000a  6803              LDR      r3,[r0,#0]
00000c  4800              LDR      r0,|L6.16|
00000e  4718              BX       r3
;;;357                         LEFT_RIGHT_IR_LED_PIN);
;;;358    }
;;;359    
                          ENDP

                  |L6.16|
                          DCD      0x40024000

                          AREA ||i.WheelSensorIntDisable||, CODE, READONLY, ALIGN=2

                  WheelSensorIntDisable PROC
;;;434    void
;;;435    WheelSensorIntDisable(tWheel eWheel)
000000  f04f7180          MOV      r1,#0x1000000
;;;436    {
;;;437        //
;;;438        // Check for a valid parameter value.
;;;439        //
;;;440        ASSERT((eWheel == WHEEL_LEFT) || (eWheel == WHEEL_RIGHT));
;;;441    
;;;442        //
;;;443        // Disable the interrupt for the specified wheel.
;;;444        //
;;;445        if(eWheel == WHEEL_LEFT)
;;;446        {
;;;447            ROM_GPIOPinIntDisable(LEFT_IR_SENSOR_PORT, LEFT_IR_SENSOR_PIN);
000004  4b04              LDR      r3,|L7.24|
000006  6a09              LDR      r1,[r1,#0x20]
000008  6a0a              LDR      r2,[r1,#0x20]         ;445
00000a  b110              CBZ      r0,|L7.18|
;;;448        }
;;;449        else
;;;450        {
;;;451            ROM_GPIOPinIntDisable(RIGHT_IR_SENSOR_PORT, RIGHT_IR_SENSOR_PIN);
00000c  2104              MOVS     r1,#4
                  |L7.14|
00000e  4618              MOV      r0,r3
000010  4710              BX       r2
                  |L7.18|
000012  2108              MOVS     r1,#8                 ;447
000014  e7fb              B        |L7.14|
;;;452        }
;;;453    }
;;;454    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x40024000

                          AREA ||i.WheelSensorIntEnable||, CODE, READONLY, ALIGN=2

                  WheelSensorIntEnable PROC
;;;396    void
;;;397    WheelSensorIntEnable(tWheel eWheel)
000000  b570              PUSH     {r4-r6,lr}
;;;398    {
;;;399        //
;;;400        // Check for a valid parameter value.
;;;401        //
;;;402        ASSERT((eWheel == WHEEL_LEFT) || (eWheel == WHEEL_RIGHT));
;;;403    
;;;404        //
;;;405        // Enable the interrupt for the specified wheel.
;;;406        //
;;;407        if(eWheel == WHEEL_LEFT)
;;;408        {
;;;409            ROM_GPIOPinIntClear(LEFT_IR_SENSOR_PORT, LEFT_IR_SENSOR_PIN);
000002  f04f7480          MOV      r4,#0x1000000
000006  4d0a              LDR      r5,|L8.48|
000008  6a21              LDR      r1,[r4,#0x20]
00000a  6a8a              LDR      r2,[r1,#0x28]         ;407
00000c  b148              CBZ      r0,|L8.34|
;;;410            ROM_GPIOPinIntEnable(LEFT_IR_SENSOR_PORT, LEFT_IR_SENSOR_PIN);
;;;411        }
;;;412        else
;;;413        {
;;;414            ROM_GPIOPinIntClear(RIGHT_IR_SENSOR_PORT, RIGHT_IR_SENSOR_PIN);
00000e  2104              MOVS     r1,#4
000010  4628              MOV      r0,r5
000012  4790              BLX      r2
;;;415            ROM_GPIOPinIntEnable(RIGHT_IR_SENSOR_PORT, RIGHT_IR_SENSOR_PIN);
000014  6a20              LDR      r0,[r4,#0x20]
000016  2104              MOVS     r1,#4
000018  69c2              LDR      r2,[r0,#0x1c]
                  |L8.26|
00001a  4628              MOV      r0,r5
00001c  e8bd4070          POP      {r4-r6,lr}
000020  4710              BX       r2
                  |L8.34|
000022  2108              MOVS     r1,#8                 ;409
000024  4628              MOV      r0,r5                 ;409
000026  4790              BLX      r2                    ;409
000028  6a20              LDR      r0,[r4,#0x20]         ;410
00002a  2108              MOVS     r1,#8                 ;410
00002c  69c2              LDR      r2,[r0,#0x1c]         ;410
00002e  e7f4              B        |L8.26|
;;;416        }
;;;417    }
;;;418    
                          ENDP

                  |L8.48|
                          DCD      0x40024000

                          AREA ||i.WheelSensorIntHandler||, CODE, READONLY, ALIGN=2

                  WheelSensorIntHandler PROC
;;;475    void
;;;476    WheelSensorIntHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;477    {
;;;478        unsigned long ulStatus, ulLoop;
;;;479    
;;;480        //
;;;481        // Was this interrupt from the left wheel sensor?
;;;482        //
;;;483        ulStatus = ROM_GPIOPinIntStatus(LEFT_IR_SENSOR_PORT, true);
000004  f04f7580          MOV      r5,#0x1000000
000008  4e1e              LDR      r6,|L9.132|
00000a  6a28              LDR      r0,[r5,#0x20]
00000c  2101              MOVS     r1,#1
00000e  6a42              LDR      r2,[r0,#0x24]
000010  4630              MOV      r0,r6
000012  4790              BLX      r2
;;;484        if (ulStatus & LEFT_IR_SENSOR_PIN)
;;;485        {
;;;486            //
;;;487            // Clear the interrupt.
;;;488            //
;;;489            ROM_GPIOPinIntClear(LEFT_IR_SENSOR_PORT,
;;;490                                LEFT_IR_SENSOR_PIN);
;;;491    
;;;492            //
;;;493            // Add a short polling loop to reject noise.  If the sensor input goes
;;;494            // low inside this loop, we assume we've read a noise spike and ignore
;;;495            // it.
;;;496            //
;;;497            for (ulLoop = 0; ulLoop < 100; ulLoop++)
;;;498            {
;;;499                if (!ROM_GPIOPinRead(LEFT_IR_SENSOR_PORT, LEFT_IR_SENSOR_PIN))
;;;500                {
;;;501                    return;
;;;502                }
;;;503            }
;;;504    
;;;505            //
;;;506            // Tell the app that we got a click from the left wheel sensor.
;;;507            //
;;;508            if(g_pfnWheelCallback)
000014  4f1c              LDR      r7,|L9.136|
000016  0700              LSLS     r0,r0,#28             ;484
000018  d513              BPL      |L9.66|
00001a  6a28              LDR      r0,[r5,#0x20]         ;489
00001c  2108              MOVS     r1,#8                 ;489
00001e  6a82              LDR      r2,[r0,#0x28]         ;489
000020  4630              MOV      r0,r6                 ;489
000022  4790              BLX      r2                    ;489
000024  2400              MOVS     r4,#0                 ;497
                  |L9.38|
000026  6a28              LDR      r0,[r5,#0x20]         ;499
000028  2108              MOVS     r1,#8                 ;499
00002a  6ac2              LDR      r2,[r0,#0x2c]         ;499
00002c  4630              MOV      r0,r6                 ;499
00002e  4790              BLX      r2                    ;499
000030  2800              CMP      r0,#0                 ;499
000032  d024              BEQ      |L9.126|
000034  1c64              ADDS     r4,r4,#1              ;497
000036  2c64              CMP      r4,#0x64              ;497
000038  d3f5              BCC      |L9.38|
00003a  6879              LDR      r1,[r7,#4]  ; g_pfnWheelCallback
00003c  b109              CBZ      r1,|L9.66|
;;;509            {
;;;510                g_pfnWheelCallback(WHEEL_LEFT);
00003e  2000              MOVS     r0,#0
000040  4788              BLX      r1
                  |L9.66|
;;;511            }
;;;512        }
;;;513    
;;;514        //
;;;515        // Was this from the right side sensor?
;;;516        //
;;;517        ulStatus = ROM_GPIOPinIntStatus(RIGHT_IR_SENSOR_PORT, true);
000042  6a28              LDR      r0,[r5,#0x20]
000044  2101              MOVS     r1,#1
000046  6a42              LDR      r2,[r0,#0x24]
000048  4630              MOV      r0,r6
00004a  4790              BLX      r2
;;;518        if (ulStatus & RIGHT_IR_SENSOR_PIN)
00004c  0740              LSLS     r0,r0,#29
00004e  d516              BPL      |L9.126|
;;;519        {
;;;520            //
;;;521            // Clear the interrupt.
;;;522            //
;;;523            ROM_GPIOPinIntClear(RIGHT_IR_SENSOR_PORT,
000050  6a28              LDR      r0,[r5,#0x20]
000052  2104              MOVS     r1,#4
000054  6a82              LDR      r2,[r0,#0x28]
000056  4630              MOV      r0,r6
000058  4790              BLX      r2
;;;524                                RIGHT_IR_SENSOR_PIN);
;;;525    
;;;526            //
;;;527            // Add a short polling loop to reject noise.  If the sensor input goes
;;;528            // low inside this loop, we assume we've read a noise spike and ignore
;;;529            // it.
;;;530            //
;;;531            for (ulLoop = 0; ulLoop < 100; ulLoop++)
00005a  2400              MOVS     r4,#0
                  |L9.92|
;;;532            {
;;;533                if (!ROM_GPIOPinRead(RIGHT_IR_SENSOR_PORT, RIGHT_IR_SENSOR_PIN))
00005c  6a28              LDR      r0,[r5,#0x20]
00005e  2104              MOVS     r1,#4
000060  6ac2              LDR      r2,[r0,#0x2c]
000062  4630              MOV      r0,r6
000064  4790              BLX      r2
000066  2800              CMP      r0,#0
000068  d009              BEQ      |L9.126|
00006a  1c64              ADDS     r4,r4,#1              ;531
00006c  2c64              CMP      r4,#0x64              ;531
00006e  d3f5              BCC      |L9.92|
;;;534                {
;;;535                    return;
;;;536                }
;;;537            }
;;;538    
;;;539            //
;;;540            // Tell the app that we got a click from the right wheel sensor.
;;;541            //
;;;542            if(g_pfnWheelCallback)
000070  6879              LDR      r1,[r7,#4]  ; g_pfnWheelCallback
000072  2900              CMP      r1,#0
000074  d003              BEQ      |L9.126|
;;;543            {
;;;544                g_pfnWheelCallback(WHEEL_RIGHT);
000076  e8bd41f0          POP      {r4-r8,lr}
00007a  2001              MOVS     r0,#1
00007c  4708              BX       r1
                  |L9.126|
;;;545            }
;;;546        }
;;;547    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;548    
                          ENDP

000082  0000              DCW      0x0000
                  |L9.132|
                          DCD      0x40024000
                  |L9.136|
                          DCD      ||.data||

                          AREA ||i.WheelSensorsInit||, CODE, READONLY, ALIGN=2

                  WheelSensorsInit PROC
;;;286    void
;;;287    WheelSensorsInit(void (*pfnCallback)(tWheel eWheel))
000000  b570              PUSH     {r4-r6,lr}
;;;288    {
;;;289        //
;;;290        // Remember the application's callback function pointer.
;;;291        //
;;;292        g_pfnWheelCallback = pfnCallback;
000002  4927              LDR      r1,|L10.160|
;;;293    
;;;294        //
;;;295        // Enable the GPIO ports used for the wheel encoders.
;;;296        //
;;;297        ROM_SysCtlPeripheralEnable(LEFT_RIGHT_IR_LED_PERIPH);
000004  f04f7480          MOV      r4,#0x1000000
000008  4d26              LDR      r5,|L10.164|
00000a  6048              STR      r0,[r1,#4]  ; g_pfnWheelCallback
00000c  6c60              LDR      r0,[r4,#0x44]
00000e  6981              LDR      r1,[r0,#0x18]
000010  4628              MOV      r0,r5
000012  4788              BLX      r1
;;;298        ROM_SysCtlPeripheralEnable(LEFT_IR_SENSOR_PERIPH);
000014  6c60              LDR      r0,[r4,#0x44]
000016  6981              LDR      r1,[r0,#0x18]
000018  4628              MOV      r0,r5
00001a  4788              BLX      r1
;;;299        ROM_SysCtlPeripheralEnable(RIGHT_IR_SENSOR_PERIPH);
00001c  6c60              LDR      r0,[r4,#0x44]
00001e  6981              LDR      r1,[r0,#0x18]
000020  4628              MOV      r0,r5
000022  4788              BLX      r1
;;;300    
;;;301        //
;;;302        // Configure the sensor inputs.
;;;303        //
;;;304        ROM_GPIOPinTypeGPIOInput(LEFT_IR_SENSOR_PORT, LEFT_IR_SENSOR_PIN);
000024  6a20              LDR      r0,[r4,#0x20]
000026  4e20              LDR      r6,|L10.168|
000028  2108              MOVS     r1,#8
00002a  6b82              LDR      r2,[r0,#0x38]
00002c  4630              MOV      r0,r6
00002e  4790              BLX      r2
;;;305        ROM_GPIOPinTypeGPIOInput(RIGHT_IR_SENSOR_PORT, RIGHT_IR_SENSOR_PIN);
000030  6a20              LDR      r0,[r4,#0x20]
000032  2104              MOVS     r1,#4
000034  6b82              LDR      r2,[r0,#0x38]
000036  4630              MOV      r0,r6
000038  4790              BLX      r2
;;;306    
;;;307        //
;;;308        // Configure the LED outputs.  Initially turn the LEDs off by setting the
;;;309        // pins high.
;;;310        //
;;;311        ROM_GPIOPinTypeGPIOOutput(LEFT_RIGHT_IR_LED_PORT, LEFT_RIGHT_IR_LED_PIN);
00003a  6a20              LDR      r0,[r4,#0x20]
00003c  2140              MOVS     r1,#0x40
00003e  6bc2              LDR      r2,[r0,#0x3c]
000040  4630              MOV      r0,r6
000042  4790              BLX      r2
;;;312        ROM_GPIOPadConfigSet(LEFT_RIGHT_IR_LED_PORT, LEFT_RIGHT_IR_LED_PIN,
000044  6a20              LDR      r0,[r4,#0x20]
000046  2308              MOVS     r3,#8
000048  2204              MOVS     r2,#4
00004a  6945              LDR      r5,[r0,#0x14]
00004c  2140              MOVS     r1,#0x40
00004e  4630              MOV      r0,r6
000050  47a8              BLX      r5
;;;313                             GPIO_STRENGTH_8MA, GPIO_PIN_TYPE_STD);
;;;314        ROM_GPIOPinWrite(LEFT_RIGHT_IR_LED_PORT, LEFT_RIGHT_IR_LED_PIN,
000052  6a20              LDR      r0,[r4,#0x20]
000054  2240              MOVS     r2,#0x40
000056  4611              MOV      r1,r2
000058  6803              LDR      r3,[r0,#0]
00005a  4630              MOV      r0,r6
00005c  4798              BLX      r3
;;;315                         LEFT_RIGHT_IR_LED_PIN);
;;;316    
;;;317        //
;;;318        // Disable all of the pin interrupts
;;;319        //
;;;320        ROM_GPIOPinIntDisable(LEFT_IR_SENSOR_PORT, LEFT_IR_SENSOR_PIN);
00005e  6a20              LDR      r0,[r4,#0x20]
000060  2108              MOVS     r1,#8
000062  6a02              LDR      r2,[r0,#0x20]
000064  4630              MOV      r0,r6
000066  4790              BLX      r2
;;;321        ROM_GPIOPinIntDisable(RIGHT_IR_SENSOR_PORT, RIGHT_IR_SENSOR_PIN);
000068  6a20              LDR      r0,[r4,#0x20]
00006a  2104              MOVS     r1,#4
00006c  6a02              LDR      r2,[r0,#0x20]
00006e  4630              MOV      r0,r6
000070  4790              BLX      r2
;;;322    
;;;323        ROM_GPIOIntTypeSet(LEFT_IR_SENSOR_PORT, LEFT_IR_SENSOR_PIN,
000072  6a20              LDR      r0,[r4,#0x20]
000074  2204              MOVS     r2,#4
000076  2108              MOVS     r1,#8
000078  68c3              LDR      r3,[r0,#0xc]
00007a  4630              MOV      r0,r6
00007c  4798              BLX      r3
;;;324                           GPIO_RISING_EDGE);
;;;325        ROM_GPIOIntTypeSet(RIGHT_IR_SENSOR_PORT, RIGHT_IR_SENSOR_PIN,
00007e  6a20              LDR      r0,[r4,#0x20]
000080  2204              MOVS     r2,#4
000082  4611              MOV      r1,r2
000084  68c3              LDR      r3,[r0,#0xc]
000086  4630              MOV      r0,r6
000088  4798              BLX      r3
;;;326                           GPIO_RISING_EDGE);
;;;327    
;;;328        //
;;;329        // Enable the GPIO port interrupts for the inputs.  The interrupts for the
;;;330        // individual pins still need to be enabled by WheelSensorIntEnable().
;;;331        //
;;;332        ROM_IntEnable(LEFT_IR_SENSOR_INT);
00008a  6ca0              LDR      r0,[r4,#0x48]
00008c  6801              LDR      r1,[r0,#0]
00008e  2014              MOVS     r0,#0x14
000090  4788              BLX      r1
;;;333        ROM_IntEnable(RIGHT_IR_SENSOR_INT);
000092  6ca0              LDR      r0,[r4,#0x48]
000094  6801              LDR      r1,[r0,#0]
000096  e8bd4070          POP      {r4-r6,lr}
00009a  2014              MOVS     r0,#0x14
00009c  4708              BX       r1
;;;334    }
;;;335    
                          ENDP

00009e  0000              DCW      0x0000
                  |L10.160|
                          DCD      ||.data||
                  |L10.164|
                          DCD      0x20000010
                  |L10.168|
                          DCD      0x40024000

                          AREA ||.data||, DATA, ALIGN=2

                  g_ucDebouncedBumpers
000000  03                DCB      0x03
                  ucBumperClockA
000001  00                DCB      0x00
                  ucBumperClockB
000002  0000              DCB      0x00,0x00
                  g_pfnWheelCallback
                          DCD      0x00000000
