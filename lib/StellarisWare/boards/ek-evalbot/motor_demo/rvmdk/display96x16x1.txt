; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\display96x16x1.o --asm_dir=.\rvmdk\ --list_dir=.\rvmdk\ --depend=.\rvmdk\display96x16x1.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 --omf_browse=.\rvmdk\display96x16x1.crf ..\drivers\display96x16x1.c]
                          THUMB

                          AREA ||i.Display96x16x1Clear||, CODE, READONLY, ALIGN=1

                  Display96x16x1Clear PROC
;;;473    void
;;;474    Display96x16x1Clear(void)
000000  b510              PUSH     {r4,lr}
;;;475    {
;;;476        //
;;;477        // Clear both lines of the display
;;;478        //
;;;479        Display96x16x1ClearLine(0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       Display96x16x1ClearLine
;;;480        Display96x16x1ClearLine(1);
000008  e8bd4010          POP      {r4,lr}
00000c  2001              MOVS     r0,#1
00000e  f7ffbffe          B.W      Display96x16x1ClearLine
;;;481    }
;;;482    
                          ENDP


                          AREA ||i.Display96x16x1ClearLine||, CODE, READONLY, ALIGN=2

                  Display96x16x1ClearLine PROC
;;;442    void
;;;443    Display96x16x1ClearLine(unsigned long ulY)
000000  b510              PUSH     {r4,lr}
;;;444    {
000002  4604              MOV      r4,r0
;;;445        unsigned long ulIdx;
;;;446    
;;;447        //
;;;448        // Move the display cursor to the first column of the specified row.
;;;449        //
;;;450        Display96x16x1WriteFirst(0x80);
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       Display96x16x1WriteFirst
;;;451        Display96x16x1WriteArray(ulY ? g_pucRITRow2 : g_pucRITRow1,
00000a  b10c              CBZ      r4,|L2.16|
00000c  4809              LDR      r0,|L2.52|
00000e  e001              B        |L2.20|
                  |L2.16|
000010  4808              LDR      r0,|L2.52|
000012  1f80              SUBS     r0,r0,#6
                  |L2.20|
000014  2106              MOVS     r1,#6
000016  f7fffffe          BL       Display96x16x1WriteArray
;;;452                                 sizeof(g_pucRITRow1));
;;;453    
;;;454        //
;;;455        // Fill this row with zeros.
;;;456        //
;;;457        for(ulIdx = 0; ulIdx < 95; ulIdx++)
00001a  2400              MOVS     r4,#0
                  |L2.28|
;;;458        {
;;;459            Display96x16x1WriteByte(0x00);
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       Display96x16x1WriteByte
000022  1c64              ADDS     r4,r4,#1              ;457
000024  2c5f              CMP      r4,#0x5f              ;457
000026  d3f9              BCC      |L2.28|
;;;460        }
;;;461        Display96x16x1WriteFinal(0x00);
000028  e8bd4010          POP      {r4,lr}
00002c  2000              MOVS     r0,#0
00002e  f7ffbffe          B.W      Display96x16x1WriteFinal
;;;462    }
;;;463    
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      ||.constdata||+0x6

                          AREA ||i.Display96x16x1DisplayOff||, CODE, READONLY, ALIGN=1

                  Display96x16x1DisplayOff PROC
;;;963    void
;;;964    Display96x16x1DisplayOff(void)
000000  b510              PUSH     {r4,lr}
;;;965    {
;;;966        //
;;;967        // Turn off the DC-DC converter and the display.
;;;968        //
;;;969        Display96x16x1WriteFirst(0x80);
000002  2080              MOVS     r0,#0x80
000004  f7fffffe          BL       Display96x16x1WriteFirst
;;;970        Display96x16x1WriteByte(0xae);
000008  20ae              MOVS     r0,#0xae
00000a  f7fffffe          BL       Display96x16x1WriteByte
;;;971        Display96x16x1WriteByte(0x80);
00000e  2080              MOVS     r0,#0x80
000010  f7fffffe          BL       Display96x16x1WriteByte
;;;972        Display96x16x1WriteByte(0xad);
000014  20ad              MOVS     r0,#0xad
000016  f7fffffe          BL       Display96x16x1WriteByte
;;;973        Display96x16x1WriteByte(0x80);
00001a  2080              MOVS     r0,#0x80
00001c  f7fffffe          BL       Display96x16x1WriteByte
;;;974        Display96x16x1WriteFinal(0x8a);
000020  e8bd4010          POP      {r4,lr}
000024  208a              MOVS     r0,#0x8a
000026  f7ffbffe          B.W      Display96x16x1WriteFinal
;;;975    }
;;;976    
                          ENDP


                          AREA ||i.Display96x16x1DisplayOn||, CODE, READONLY, ALIGN=2

                  Display96x16x1DisplayOn PROC
;;;929    void
;;;930    Display96x16x1DisplayOn(void)
000000  b570              PUSH     {r4-r6,lr}
;;;931    {
;;;932        unsigned long ulIdx;
;;;933    
;;;934        //
;;;935        // Re-initialize the display controller.  Loop through the initialization
;;;936        // sequence doing a single I2C transfer for each command.
;;;937        //
;;;938        for(ulIdx = 0; ulIdx < sizeof(g_pucRITInit);
;;;939            ulIdx += g_pucRITInit[ulIdx] + 1)
;;;940        {
;;;941            //
;;;942            // Send this command.
;;;943            //
;;;944            Display96x16x1WriteFirst(g_pucRITInit[ulIdx + 1]);
000002  4e0a              LDR      r6,|L4.44|
000004  2400              MOVS     r4,#0                 ;938
                  |L4.6|
000006  1935              ADDS     r5,r6,r4
000008  7868              LDRB     r0,[r5,#1]
00000a  f7fffffe          BL       Display96x16x1WriteFirst
;;;945            Display96x16x1WriteArray(g_pucRITInit + ulIdx + 2,
00000e  5d31              LDRB     r1,[r6,r4]
000010  1ca8              ADDS     r0,r5,#2
000012  1e89              SUBS     r1,r1,#2
000014  f7fffffe          BL       Display96x16x1WriteArray
;;;946                                     g_pucRITInit[ulIdx] - 2);
;;;947            Display96x16x1WriteFinal(g_pucRITInit[ulIdx + g_pucRITInit[ulIdx]]);
000018  5d30              LDRB     r0,[r6,r4]
00001a  5d40              LDRB     r0,[r0,r5]
00001c  f7fffffe          BL       Display96x16x1WriteFinal
000020  5d30              LDRB     r0,[r6,r4]            ;939
000022  1c64              ADDS     r4,r4,#1              ;939
000024  4404              ADD      r4,r4,r0              ;939
000026  2c2f              CMP      r4,#0x2f              ;938
000028  d3ed              BCC      |L4.6|
;;;948        }
;;;949    }
00002a  bd70              POP      {r4-r6,pc}
;;;950    
                          ENDP

                  |L4.44|
                          DCD      ||.constdata||+0x1e7

                          AREA ||i.Display96x16x1ImageDraw||, CODE, READONLY, ALIGN=1

                  Display96x16x1ImageDraw PROC
;;;770    void
;;;771    Display96x16x1ImageDraw(const unsigned char *pucImage, unsigned long ulX,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;772                          unsigned long ulY, unsigned long ulWidth,
;;;773                          unsigned long ulHeight)
;;;774    {
000004  4605              MOV      r5,r0
000006  4614              MOV      r4,r2
000008  461f              MOV      r7,r3
;;;775        //
;;;776        // Check the arguments.
;;;777        //
;;;778        ASSERT(ulX < 96);
;;;779        ASSERT(ulY < 2);
;;;780        ASSERT((ulX + ulWidth) <= 96);
;;;781        ASSERT((ulY + ulHeight) <= 2);
;;;782    
;;;783        //
;;;784        // The first few columns of the LCD buffer are not displayed, so increment
;;;785        // the X coorddinate by this amount to account for the non-displayed frame
;;;786        // buffer memory.
;;;787        //
;;;788        ulX += 4;
00000a  1d0e              ADDS     r6,r1,#4
;;;789    
;;;790        //
;;;791        // Loop while there are more rows to display.
;;;792        //
;;;793        while(ulHeight--)
00000c  f8dd8018          LDR      r8,[sp,#0x18]
000010  e023              B        |L5.90|
                  |L5.18|
;;;794        {
;;;795            //
;;;796            // Write the starting address within this row.
;;;797            //
;;;798            Display96x16x1WriteFirst(0x80);
000012  2080              MOVS     r0,#0x80
000014  f7fffffe          BL       Display96x16x1WriteFirst
;;;799            Display96x16x1WriteByte((ulY == 0) ? 0xb0 : 0xb1);
000018  b324              CBZ      r4,|L5.100|
00001a  20b1              MOVS     r0,#0xb1
                  |L5.28|
00001c  f7fffffe          BL       Display96x16x1WriteByte
;;;800            Display96x16x1WriteByte(0x80);
000020  2080              MOVS     r0,#0x80
000022  f7fffffe          BL       Display96x16x1WriteByte
;;;801            Display96x16x1WriteByte(ulX & 0x0f);
000026  f006000f          AND      r0,r6,#0xf
00002a  f7fffffe          BL       Display96x16x1WriteByte
;;;802            Display96x16x1WriteByte(0x80);
00002e  2080              MOVS     r0,#0x80
000030  f7fffffe          BL       Display96x16x1WriteByte
;;;803            Display96x16x1WriteByte(0x10 | ((ulX >> 4) & 0x0f));
000034  f3c61003          UBFX     r0,r6,#4,#4
000038  f0400010          ORR      r0,r0,#0x10
00003c  f7fffffe          BL       Display96x16x1WriteByte
;;;804            Display96x16x1WriteByte(0x40);
000040  2040              MOVS     r0,#0x40
000042  f7fffffe          BL       Display96x16x1WriteByte
;;;805    
;;;806            //
;;;807            // Write this row of image data.
;;;808            //
;;;809            Display96x16x1WriteArray(pucImage, ulWidth - 1);
000046  1e79              SUBS     r1,r7,#1
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       Display96x16x1WriteArray
;;;810            Display96x16x1WriteFinal(pucImage[ulWidth - 1]);
00004e  443d              ADD      r5,r5,r7
000050  f8150c01          LDRB     r0,[r5,#-1]
000054  f7fffffe          BL       Display96x16x1WriteFinal
;;;811    
;;;812            //
;;;813            // Advance to the next row of the image.
;;;814            //
;;;815            pucImage += ulWidth;
;;;816            ulY++;
000058  1c64              ADDS     r4,r4,#1
                  |L5.90|
00005a  f1b80801          SUBS     r8,r8,#1              ;793
00005e  d2d8              BCS      |L5.18|
;;;817        }
;;;818    }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L5.100|
000064  20b0              MOVS     r0,#0xb0              ;799
000066  e7d9              B        |L5.28|
;;;819    
                          ENDP


                          AREA ||i.Display96x16x1Init||, CODE, READONLY, ALIGN=2

                  Display96x16x1Init PROC
;;;833    void
;;;834    Display96x16x1Init(tBoolean bFast)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;835    {
;;;836        unsigned long ulIdx;
;;;837    
;;;838        //
;;;839        // The power supply for the OLED display comes from the motor power
;;;840        // supply, which must be turned on.  If the application is using the
;;;841        // motor then this is taken care of when the motor driver is initialized.
;;;842        // But if the motor driver is not used, then the motor power supply needs
;;;843        // to be turned on here so the OLED works properly.
;;;844        //
;;;845        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
000004  f04f7480          MOV      r4,#0x1000000
000008  4606              MOV      r6,r0                 ;835
00000a  6c60              LDR      r0,[r4,#0x44]
00000c  6981              LDR      r1,[r0,#0x18]
00000e  4836              LDR      r0,|L6.232|
000010  4788              BLX      r1
;;;846        ROM_GPIOPinTypeGPIOOutput(GPIO_PORTD_BASE, GPIO_PIN_5);
000012  6a20              LDR      r0,[r4,#0x20]
000014  4d35              LDR      r5,|L6.236|
000016  2120              MOVS     r1,#0x20
000018  6bc2              LDR      r2,[r0,#0x3c]
00001a  4628              MOV      r0,r5
00001c  4790              BLX      r2
;;;847        ROM_GPIOPinWrite(GPIO_PORTD_BASE, GPIO_PIN_5, GPIO_PIN_5);
00001e  6a20              LDR      r0,[r4,#0x20]
000020  2220              MOVS     r2,#0x20
000022  4611              MOV      r1,r2
000024  6803              LDR      r3,[r0,#0]
000026  4628              MOV      r0,r5
000028  4798              BLX      r3
;;;848    
;;;849        //
;;;850        // Enable the I2C and GPIO peripherals needed for the display.
;;;851        //
;;;852        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C1);
00002a  6c60              LDR      r0,[r4,#0x44]
00002c  4d30              LDR      r5,|L6.240|
00002e  6981              LDR      r1,[r0,#0x18]
000030  4628              MOV      r0,r5
000032  4788              BLX      r1
;;;853        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
000034  6c60              LDR      r0,[r4,#0x44]
000036  6981              LDR      r1,[r0,#0x18]
000038  482b              LDR      r0,|L6.232|
00003a  3018              ADDS     r0,r0,#0x18
00003c  4788              BLX      r1
;;;854        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOG);
00003e  6c60              LDR      r0,[r4,#0x44]
000040  6981              LDR      r1,[r0,#0x18]
000042  4829              LDR      r0,|L6.232|
000044  3038              ADDS     r0,r0,#0x38
000046  4788              BLX      r1
;;;855    
;;;856        //
;;;857        // Deassert the display controller reset signal (active low)
;;;858        //
;;;859        ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_0);
000048  6a20              LDR      r0,[r4,#0x20]
00004a  4f2a              LDR      r7,|L6.244|
00004c  2101              MOVS     r1,#1
00004e  6bc2              LDR      r2,[r0,#0x3c]
000050  4638              MOV      r0,r7
000052  4790              BLX      r2
;;;860        ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, GPIO_PIN_0);
000054  6a20              LDR      r0,[r4,#0x20]
000056  2201              MOVS     r2,#1
000058  4611              MOV      r1,r2
00005a  6803              LDR      r3,[r0,#0]
00005c  4638              MOV      r0,r7
00005e  4798              BLX      r3
;;;861    
;;;862        //
;;;863        // Wait a short delay, then drive the pin low to reset the controller
;;;864        //
;;;865        SysCtlDelay(32);
000060  2020              MOVS     r0,#0x20
000062  f7fffffe          BL       SysCtlDelay
;;;866        ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, 0);
000066  6a20              LDR      r0,[r4,#0x20]
000068  2200              MOVS     r2,#0
00006a  2101              MOVS     r1,#1
00006c  6803              LDR      r3,[r0,#0]
00006e  4638              MOV      r0,r7
000070  4798              BLX      r3
;;;867    
;;;868        //
;;;869        // Leave it is reset for a short delay, then drive it high to deassert
;;;870        // reset.  Then the controller should be out of reset.
;;;871        //
;;;872        SysCtlDelay(32);
000072  2020              MOVS     r0,#0x20
000074  f7fffffe          BL       SysCtlDelay
;;;873        ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_0, GPIO_PIN_0);
000078  6a20              LDR      r0,[r4,#0x20]
00007a  2201              MOVS     r2,#1
00007c  4611              MOV      r1,r2
00007e  6803              LDR      r3,[r0,#0]
000080  4638              MOV      r0,r7
000082  4798              BLX      r3
;;;874    
;;;875        //
;;;876        // Configure the GPIO pins needed for the display as I2C
;;;877        //
;;;878        GPIOPinConfigure(GPIO_PG0_I2C1SCL);
000084  481c              LDR      r0,|L6.248|
000086  f7fffffe          BL       GPIOPinConfigure
;;;879        GPIOPinConfigure(GPIO_PG1_I2C1SDA);
00008a  481c              LDR      r0,|L6.252|
00008c  f7fffffe          BL       GPIOPinConfigure
;;;880        ROM_GPIOPinTypeI2C(GPIO_PORTG_BASE, GPIO_PIN_0 | GPIO_PIN_1);
000090  6a20              LDR      r0,[r4,#0x20]
000092  2103              MOVS     r1,#3
000094  6c02              LDR      r2,[r0,#0x40]
000096  481a              LDR      r0,|L6.256|
000098  4790              BLX      r2
;;;881    
;;;882        //
;;;883        // Reset the I2C1 peripheral.
;;;884        //
;;;885        ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_I2C1);
00009a  6c60              LDR      r0,[r4,#0x44]
00009c  6941              LDR      r1,[r0,#0x14]
00009e  4628              MOV      r0,r5
0000a0  4788              BLX      r1
;;;886    
;;;887        //
;;;888        // Initialize the I2C master.
;;;889        //
;;;890        ROM_I2CMasterInitExpClk(I2C1_MASTER_BASE, ROM_SysCtlClockGet(), bFast);
0000a2  6c60              LDR      r0,[r4,#0x44]
0000a4  6e00              LDR      r0,[r0,#0x60]
0000a6  4780              BLX      r0
0000a8  4601              MOV      r1,r0
0000aa  69e0              LDR      r0,[r4,#0x1c]
0000ac  4632              MOV      r2,r6
0000ae  6843              LDR      r3,[r0,#4]
0000b0  4814              LDR      r0,|L6.260|
0000b2  4798              BLX      r3
;;;891    
;;;892        //
;;;893        // Initialize the display controller.  Loop through the initialization
;;;894        // sequence doing a single I2C transfer for each command.
;;;895        //
;;;896        for(ulIdx = 0; ulIdx < sizeof(g_pucRITInit);
;;;897            ulIdx += g_pucRITInit[ulIdx] + 1)
;;;898        {
;;;899            //
;;;900            // Send this command.
;;;901            //
;;;902            Display96x16x1WriteFirst(g_pucRITInit[ulIdx + 1]);
0000b4  4e14              LDR      r6,|L6.264|
0000b6  2400              MOVS     r4,#0                 ;896
                  |L6.184|
0000b8  1935              ADDS     r5,r6,r4
0000ba  7868              LDRB     r0,[r5,#1]
0000bc  f7fffffe          BL       Display96x16x1WriteFirst
;;;903            Display96x16x1WriteArray(g_pucRITInit + ulIdx + 2,
0000c0  5d31              LDRB     r1,[r6,r4]
0000c2  1ca8              ADDS     r0,r5,#2
0000c4  1e89              SUBS     r1,r1,#2
0000c6  f7fffffe          BL       Display96x16x1WriteArray
;;;904                                     g_pucRITInit[ulIdx] - 2);
;;;905            Display96x16x1WriteFinal(g_pucRITInit[ulIdx + g_pucRITInit[ulIdx]]);
0000ca  5d30              LDRB     r0,[r6,r4]
0000cc  5d40              LDRB     r0,[r0,r5]
0000ce  f7fffffe          BL       Display96x16x1WriteFinal
0000d2  5d30              LDRB     r0,[r6,r4]            ;897
0000d4  1c64              ADDS     r4,r4,#1              ;897
0000d6  4404              ADD      r4,r4,r0              ;897
0000d8  2c2f              CMP      r4,#0x2f              ;896
0000da  d3ed              BCC      |L6.184|
;;;906        }
;;;907    
;;;908        //
;;;909        // Clear the frame buffer.
;;;910        //
;;;911        Display96x16x1Clear();
0000dc  f7fffffe          BL       Display96x16x1Clear
;;;912    
;;;913        //
;;;914        // Turn the display on.
;;;915        //
;;;916        Display96x16x1DisplayOn();
0000e0  e8bd41f0          POP      {r4-r8,lr}
0000e4  f7ffbffe          B.W      Display96x16x1DisplayOn
;;;917    }
;;;918    
                          ENDP

                  |L6.232|
                          DCD      0x20000008
                  |L6.236|
                          DCD      0x40007000
                  |L6.240|
                          DCD      0x10004000
                  |L6.244|
                          DCD      0x40025000
                  |L6.248|
                          DCD      0x00060003
                  |L6.252|
                          DCD      0x00060403
                  |L6.256|
                          DCD      0x40026000
                  |L6.260|
                          DCD      0x40021000
                  |L6.264|
                          DCD      ||.constdata||+0x1e7

                          AREA ||i.Display96x16x1StringDraw||, CODE, READONLY, ALIGN=1

                  Display96x16x1StringDraw PROC
;;;632    void
;;;633    Display96x16x1StringDraw(const char *pcStr, unsigned long ulX,
000000  4613              MOV      r3,r2
;;;634                             unsigned long ulY)
;;;635    {
;;;636        //
;;;637        // Check the arguments.
;;;638        //
;;;639        ASSERT(pcStr);
;;;640        ASSERT(ulX < 96);
;;;641        ASSERT(ulY < 2);
;;;642    
;;;643        //
;;;644        // Call the length restricted variant of this function, using a large
;;;645        // number for the length.
;;;646        //
;;;647        Display96x16x1StringDrawLen(pcStr, 32, ulX, ulY);
000002  460a              MOV      r2,r1
000004  2120              MOVS     r1,#0x20
000006  f7ffbffe          B.W      Display96x16x1StringDrawLen
;;;648    }
;;;649    
                          ENDP


                          AREA ||i.Display96x16x1StringDrawCentered||, CODE, READONLY, ALIGN=1

                  Display96x16x1StringDrawCentered PROC
;;;667    void
;;;668    Display96x16x1StringDrawCentered(const char *pcStr, unsigned long ulY,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;669                                     tBoolean bClear)
;;;670    {
000004  4688              MOV      r8,r1
000006  4617              MOV      r7,r2
000008  4606              MOV      r6,r0
;;;671        unsigned long ulLen, ulClip;
;;;672    
;;;673        //
;;;674        // Check the arguments.
;;;675        //
;;;676        ASSERT(pcStr);
;;;677        ASSERT(ulY < 2);
;;;678    
;;;679        //
;;;680        // How long is the supplied string?
;;;681        //
;;;682        ulLen = strlen(pcStr);
00000a  f7fffffe          BL       strlen
00000e  4604              MOV      r4,r0
;;;683    
;;;684        //
;;;685        // Is the string too wide to fit on the display?  If so, clip it left and
;;;686        // right to fit.
;;;687        //
;;;688        if(ulLen > 16)
000010  2810              CMP      r0,#0x10
000012  d903              BLS      |L8.28|
;;;689        {
;;;690            ulClip = (ulLen - 16) / 2;
000014  3c10              SUBS     r4,r4,#0x10
000016  0865              LSRS     r5,r4,#1
;;;691            ulLen = 16;
000018  2410              MOVS     r4,#0x10
00001a  e000              B        |L8.30|
                  |L8.28|
;;;692        }
;;;693        else
;;;694        {
;;;695            ulClip = 0;
00001c  2500              MOVS     r5,#0
                  |L8.30|
;;;696        }
;;;697    
;;;698        //
;;;699        // If we've been asked to clear the background, clear it now.
;;;700        //
;;;701        if(bClear)
00001e  b117              CBZ      r7,|L8.38|
;;;702        {
;;;703            Display96x16x1ClearLine(ulY);
000020  4640              MOV      r0,r8
000022  f7fffffe          BL       Display96x16x1ClearLine
                  |L8.38|
;;;704        }
;;;705    
;;;706        //
;;;707        // Now draw the string at the desired position.
;;;708        //
;;;709        Display96x16x1StringDrawLen(pcStr + ulClip, ulLen,
000026  eba40084          SUB      r0,r4,r4,LSL #2
00002a  2160              MOVS     r1,#0x60
00002c  eb010040          ADD      r0,r1,r0,LSL #1
000030  0842              LSRS     r2,r0,#1
000032  1970              ADDS     r0,r6,r5
000034  4643              MOV      r3,r8
000036  4621              MOV      r1,r4
000038  e8bd41f0          POP      {r4-r8,lr}
00003c  f7ffbffe          B.W      Display96x16x1StringDrawLen
;;;710                                    ((96 - (ulLen * 6)) / 2), ulY);
;;;711    }
;;;712    
                          ENDP


                          AREA ||i.Display96x16x1StringDrawLen||, CODE, READONLY, ALIGN=2

                  Display96x16x1StringDrawLen PROC
;;;512    void
;;;513    Display96x16x1StringDrawLen(const char *pcStr, unsigned long ulLen,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;514                                unsigned long ulX, unsigned long ulY)
;;;515    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;516        //
;;;517        // Check the arguments.
;;;518        //
;;;519        ASSERT(pcStr);
;;;520        ASSERT(ulX < 96);
;;;521        ASSERT(ulY < 2);
;;;522    
;;;523        //
;;;524        // Move the display cursor to the requested position on the display.
;;;525        //
;;;526        Display96x16x1WriteFirst(0x80);
00000c  2080              MOVS     r0,#0x80
00000e  f7fffffe          BL       Display96x16x1WriteFirst
;;;527        Display96x16x1WriteByte((ulY == 0) ? 0xb0 : 0xb1);
000012  b1c7              CBZ      r7,|L9.70|
000014  20b1              MOVS     r0,#0xb1
                  |L9.22|
000016  f7fffffe          BL       Display96x16x1WriteByte
;;;528        Display96x16x1WriteByte(0x80);
00001a  2080              MOVS     r0,#0x80
00001c  f7fffffe          BL       Display96x16x1WriteByte
;;;529        Display96x16x1WriteByte((ulX + 4) & 0x0f);
000020  1d27              ADDS     r7,r4,#4
000022  f007000f          AND      r0,r7,#0xf
000026  f7fffffe          BL       Display96x16x1WriteByte
;;;530        Display96x16x1WriteByte(0x80);
00002a  2080              MOVS     r0,#0x80
00002c  f7fffffe          BL       Display96x16x1WriteByte
;;;531        Display96x16x1WriteByte(0x10 | (((ulX + 4) >> 4) & 0x0f));
000030  f3c71003          UBFX     r0,r7,#4,#4
000034  f0400010          ORR      r0,r0,#0x10
000038  f7fffffe          BL       Display96x16x1WriteByte
;;;532        Display96x16x1WriteByte(0x40);
00003c  2040              MOVS     r0,#0x40
00003e  f7fffffe          BL       Display96x16x1WriteByte
;;;533    
;;;534        //
;;;535        // Loop while there are more characters in the string and the specified
;;;536        // length has not been exceeded.
;;;537        //
;;;538        while(ulLen && (*pcStr != 0))
;;;539        {
;;;540            //
;;;541            // See if there is enough space on the display for this entire
;;;542            // character.
;;;543            //
;;;544            if(ulX <= 90)
;;;545            {
;;;546                //
;;;547                // Write the contents of this character to the display.
;;;548                //
;;;549                Display96x16x1WriteArray(g_pucFont[*pcStr - ' '], 5);
000042  4f1a              LDR      r7,|L9.172|
;;;550    
;;;551                //
;;;552                // See if this is the last character to display (either because the
;;;553                // right edge has been reached or because there are no more
;;;554                // characters).
;;;555                //
;;;556                if((ulX == 90) || (pcStr[1] == 0))
;;;557                {
;;;558                    //
;;;559                    // Write the final column of the display.
;;;560                    //
;;;561                    Display96x16x1WriteFinal(0x00);
;;;562    
;;;563                    //
;;;564                    // The string has been displayed.
;;;565                    //
;;;566                    return;
;;;567                }
;;;568    
;;;569                //
;;;570                // Write the inter-character padding column.
;;;571                //
;;;572                Display96x16x1WriteByte(0x00);
;;;573            }
;;;574            else
;;;575            {
;;;576                //
;;;577                // Write the portion of the character that will fit onto the
;;;578                // display.
;;;579                //
;;;580                Display96x16x1WriteArray(g_pucFont[*pcStr - ' '], 95 - ulX);
;;;581                Display96x16x1WriteFinal(g_pucFont[*pcStr - ' '][95 - ulX]);
;;;582    
;;;583                //
;;;584                // The string has been displayed.
;;;585                //
;;;586                return;
;;;587            }
;;;588    
;;;589            //
;;;590            // Advance to the next character.
;;;591            //
;;;592            pcStr++;
;;;593    
;;;594            //
;;;595            // Decrement the character count
;;;596            //
;;;597            ulLen--;
;;;598    
;;;599            //
;;;600            // Increment the X coordinate by the six columns that were just
;;;601            // written.
;;;602            //
;;;603            ulX += 6;
000044  e014              B        |L9.112|
                  |L9.70|
000046  20b0              MOVS     r0,#0xb0              ;527
000048  e7e5              B        |L9.22|
                  |L9.74|
00004a  2c5a              CMP      r4,#0x5a              ;544
00004c  d81c              BHI      |L9.136|
00004e  eb000080          ADD      r0,r0,r0,LSL #2       ;549
000052  4438              ADD      r0,r0,r7              ;549
000054  38a0              SUBS     r0,r0,#0xa0           ;549
000056  2105              MOVS     r1,#5                 ;549
000058  f7fffffe          BL       Display96x16x1WriteArray
00005c  2c5a              CMP      r4,#0x5a              ;556
00005e  d00e              BEQ      |L9.126|
000060  7868              LDRB     r0,[r5,#1]            ;556
000062  b160              CBZ      r0,|L9.126|
000064  2000              MOVS     r0,#0                 ;572
000066  f7fffffe          BL       Display96x16x1WriteByte
00006a  1c6d              ADDS     r5,r5,#1              ;592
00006c  1e76              SUBS     r6,r6,#1              ;597
00006e  1da4              ADDS     r4,r4,#6
                  |L9.112|
000070  2e00              CMP      r6,#0                 ;538
000072  d002              BEQ      |L9.122|
000074  7828              LDRB     r0,[r5,#0]            ;538
000076  2800              CMP      r0,#0                 ;538
000078  d1e7              BNE      |L9.74|
                  |L9.122|
;;;604        }
;;;605    }
00007a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.126|
00007e  2000              MOVS     r0,#0                 ;561
                  |L9.128|
000080  e8bd41f0          POP      {r4-r8,lr}            ;581
000084  f7ffbffe          B.W      Display96x16x1WriteFinal
                  |L9.136|
000088  b2c0              UXTB     r0,r0                 ;580
00008a  eb000080          ADD      r0,r0,r0,LSL #2       ;580
00008e  f1c4045f          RSB      r4,r4,#0x5f           ;580
000092  4438              ADD      r0,r0,r7              ;580
000094  38a0              SUBS     r0,r0,#0xa0           ;580
000096  4621              MOV      r1,r4                 ;580
000098  f7fffffe          BL       Display96x16x1WriteArray
00009c  7828              LDRB     r0,[r5,#0]            ;581
00009e  eb000080          ADD      r0,r0,r0,LSL #2       ;581
0000a2  4438              ADD      r0,r0,r7              ;581
0000a4  4420              ADD      r0,r0,r4              ;581
0000a6  f8100ca0          LDRB     r0,[r0,#-0xa0]        ;581
0000aa  e7e9              B        |L9.128|
;;;606    
                          ENDP

                  |L9.172|
                          DCD      ||.constdata||+0xc

                          AREA ||i.Display96x16x1WriteArray||, CODE, READONLY, ALIGN=2

                  Display96x16x1WriteArray PROC
;;;343    static void
;;;344    Display96x16x1WriteArray(const unsigned char *pucBuffer, unsigned long ulCount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;345    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;346        //
;;;347        // Loop while there are more bytes left to be transferred.
;;;348        //
;;;349        while(ulCount != 0)
;;;350        {
;;;351            //
;;;352            // Wait until the current byte has been transferred.
;;;353            //
;;;354            while(ROM_I2CMasterIntStatus(I2C1_MASTER_BASE, false) == 0)
000008  f04f7680          MOV      r6,#0x1000000
00000c  4f0e              LDR      r7,|L10.72|
;;;355            {
;;;356            }
;;;357    
;;;358            //
;;;359            // Clear the I2C interrupt.
;;;360            //
;;;361            ROM_I2CMasterIntClear(I2C1_MASTER_BASE);
;;;362    
;;;363            //
;;;364            // Write the next byte to the controller.
;;;365            //
;;;366            ROM_I2CMasterDataPut(I2C1_MASTER_BASE, *pucBuffer++);
;;;367            ulCount--;
;;;368    
;;;369            //
;;;370            // Continue the transfer.
;;;371            //
;;;372            ROM_I2CMasterControl(I2C1_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_CONT);
00000e  e016              B        |L10.62|
                  |L10.16|
000010  69f0              LDR      r0,[r6,#0x1c]         ;354
000012  2100              MOVS     r1,#0                 ;354
000014  6ac2              LDR      r2,[r0,#0x2c]         ;354
000016  4638              MOV      r0,r7                 ;354
000018  4790              BLX      r2                    ;354
00001a  2800              CMP      r0,#0                 ;354
00001c  d0f8              BEQ      |L10.16|
00001e  69f0              LDR      r0,[r6,#0x1c]         ;361
000020  6b41              LDR      r1,[r0,#0x34]         ;361
000022  4638              MOV      r0,r7                 ;361
000024  4788              BLX      r1                    ;361
000026  69f0              LDR      r0,[r6,#0x1c]         ;366
000028  f8141b01          LDRB     r1,[r4],#1            ;366
00002c  6802              LDR      r2,[r0,#0]            ;366
00002e  4638              MOV      r0,r7                 ;366
000030  4790              BLX      r2                    ;366
000032  69f0              LDR      r0,[r6,#0x1c]
000034  1e6d              SUBS     r5,r5,#1              ;367
000036  2101              MOVS     r1,#1
000038  6c82              LDR      r2,[r0,#0x48]
00003a  4638              MOV      r0,r7
00003c  4790              BLX      r2
                  |L10.62|
00003e  2d00              CMP      r5,#0                 ;349
000040  d1e6              BNE      |L10.16|
;;;373        }
;;;374    }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;375    
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      0x40021000

                          AREA ||i.Display96x16x1WriteByte||, CODE, READONLY, ALIGN=2

                  Display96x16x1WriteByte PROC
;;;301    static void
;;;302    Display96x16x1WriteByte(unsigned char ucChar)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
;;;304        //
;;;305        // Wait until the current byte has been transferred.
;;;306        //
;;;307        while(ROM_I2CMasterIntStatus(I2C1_MASTER_BASE, false) == 0)
000002  4d0d              LDR      r5,|L11.56|
000004  4606              MOV      r6,r0                 ;303
000006  f04f7480          MOV      r4,#0x1000000
                  |L11.10|
00000a  2100              MOVS     r1,#0
00000c  69e0              LDR      r0,[r4,#0x1c]
00000e  6ac2              LDR      r2,[r0,#0x2c]
000010  4628              MOV      r0,r5
000012  4790              BLX      r2
000014  2800              CMP      r0,#0
000016  d0f8              BEQ      |L11.10|
;;;308        {
;;;309        }
;;;310    
;;;311        //
;;;312        // Clear the I2C interrupt.
;;;313        //
;;;314        ROM_I2CMasterIntClear(I2C1_MASTER_BASE);
000018  69e0              LDR      r0,[r4,#0x1c]
00001a  6b41              LDR      r1,[r0,#0x34]
00001c  4628              MOV      r0,r5
00001e  4788              BLX      r1
;;;315    
;;;316        //
;;;317        // Write the next byte to the controller.
;;;318        //
;;;319        ROM_I2CMasterDataPut(I2C1_MASTER_BASE, ucChar);
000020  69e0              LDR      r0,[r4,#0x1c]
000022  4631              MOV      r1,r6
000024  6802              LDR      r2,[r0,#0]
000026  4628              MOV      r0,r5
000028  4790              BLX      r2
;;;320    
;;;321        //
;;;322        // Continue the transfer.
;;;323        //
;;;324        ROM_I2CMasterControl(I2C1_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_CONT);
00002a  69e0              LDR      r0,[r4,#0x1c]
00002c  2101              MOVS     r1,#1
00002e  6c82              LDR      r2,[r0,#0x48]
000030  4628              MOV      r0,r5
000032  e8bd4070          POP      {r4-r6,lr}
000036  4710              BX       r2
;;;325    }
;;;326    
                          ENDP

                  |L11.56|
                          DCD      0x40021000

                          AREA ||i.Display96x16x1WriteFinal||, CODE, READONLY, ALIGN=2

                  Display96x16x1WriteFinal PROC
;;;393    static void
;;;394    Display96x16x1WriteFinal(unsigned char ucChar)
000000  b570              PUSH     {r4-r6,lr}
;;;395    {
;;;396        //
;;;397        // Wait until the current byte has been transferred.
;;;398        //
;;;399        while(ROM_I2CMasterIntStatus(I2C1_MASTER_BASE, false) == 0)
000002  4d13              LDR      r5,|L12.80|
000004  4606              MOV      r6,r0                 ;395
000006  f04f7480          MOV      r4,#0x1000000
                  |L12.10|
00000a  2100              MOVS     r1,#0
00000c  69e0              LDR      r0,[r4,#0x1c]
00000e  6ac2              LDR      r2,[r0,#0x2c]
000010  4628              MOV      r0,r5
000012  4790              BLX      r2
000014  2800              CMP      r0,#0
000016  d0f8              BEQ      |L12.10|
;;;400        {
;;;401        }
;;;402    
;;;403        //
;;;404        // Clear the I2C interrupt.
;;;405        //
;;;406        ROM_I2CMasterIntClear(I2C1_MASTER_BASE);
000018  69e0              LDR      r0,[r4,#0x1c]
00001a  6b41              LDR      r1,[r0,#0x34]
00001c  4628              MOV      r0,r5
00001e  4788              BLX      r1
;;;407    
;;;408        //
;;;409        // Write the final byte to the controller.
;;;410        //
;;;411        ROM_I2CMasterDataPut(I2C1_MASTER_BASE, ucChar);
000020  69e0              LDR      r0,[r4,#0x1c]
000022  4631              MOV      r1,r6
000024  6802              LDR      r2,[r0,#0]
000026  4628              MOV      r0,r5
000028  4790              BLX      r2
;;;412    
;;;413        //
;;;414        // Finish the transfer.
;;;415        //
;;;416        ROM_I2CMasterControl(I2C1_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_FINISH);
00002a  69e0              LDR      r0,[r4,#0x1c]
00002c  2105              MOVS     r1,#5
00002e  6c82              LDR      r2,[r0,#0x48]
000030  4628              MOV      r0,r5
000032  4790              BLX      r2
                  |L12.52|
;;;417    
;;;418        //
;;;419        // Wait until the final byte has been transferred.
;;;420        //
;;;421        while(ROM_I2CMasterIntStatus(I2C1_MASTER_BASE, false) == 0)
000034  69e0              LDR      r0,[r4,#0x1c]
000036  2100              MOVS     r1,#0
000038  6ac2              LDR      r2,[r0,#0x2c]
00003a  4628              MOV      r0,r5
00003c  4790              BLX      r2
00003e  2800              CMP      r0,#0
000040  d0f8              BEQ      |L12.52|
;;;422        {
;;;423        }
;;;424    
;;;425        //
;;;426        // Clear the I2C interrupt.
;;;427        //
;;;428        ROM_I2CMasterIntClear(I2C1_MASTER_BASE);
000042  69e0              LDR      r0,[r4,#0x1c]
000044  6b41              LDR      r1,[r0,#0x34]
000046  4628              MOV      r0,r5
000048  e8bd4070          POP      {r4-r6,lr}
00004c  4708              BX       r1
;;;429    }
;;;430    
                          ENDP

00004e  0000              DCW      0x0000
                  |L12.80|
                          DCD      0x40021000

                          AREA ||i.Display96x16x1WriteFirst||, CODE, READONLY, ALIGN=2

                  Display96x16x1WriteFirst PROC
;;;264    static void
;;;265    Display96x16x1WriteFirst(unsigned char ucChar)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
;;;267        //
;;;268        // Set the slave address.
;;;269        //
;;;270        ROM_I2CMasterSlaveAddrSet(I2C1_MASTER_BASE, SSD_ADDR, false);
000002  f04f7480          MOV      r4,#0x1000000
000006  4606              MOV      r6,r0                 ;266
000008  69e0              LDR      r0,[r4,#0x1c]
00000a  4d09              LDR      r5,|L13.48|
00000c  2200              MOVS     r2,#0
00000e  6bc3              LDR      r3,[r0,#0x3c]
000010  213c              MOVS     r1,#0x3c
000012  4628              MOV      r0,r5
000014  4798              BLX      r3
;;;271    
;;;272        //
;;;273        // Write the first byte to the controller.
;;;274        //
;;;275        ROM_I2CMasterDataPut(I2C1_MASTER_BASE, ucChar);
000016  69e0              LDR      r0,[r4,#0x1c]
000018  4631              MOV      r1,r6
00001a  6802              LDR      r2,[r0,#0]
00001c  4628              MOV      r0,r5
00001e  4790              BLX      r2
;;;276    
;;;277        //
;;;278        // Start the transfer.
;;;279        //
;;;280        ROM_I2CMasterControl(I2C1_MASTER_BASE, I2C_MASTER_CMD_BURST_SEND_START);
000020  69e0              LDR      r0,[r4,#0x1c]
000022  2103              MOVS     r1,#3
000024  6c82              LDR      r2,[r0,#0x48]
000026  4628              MOV      r0,r5
000028  e8bd4070          POP      {r4-r6,lr}
00002c  4710              BX       r2
;;;281    }
;;;282    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      0x40021000

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  g_pucRITRow1
000000  b0800480          DCB      0xb0,0x80,0x04,0x80
000004  1040              DCB      0x10,0x40
                  g_pucRITRow2
000006  b180              DCB      0xb1,0x80
000008  04801040          DCB      0x04,0x80,0x10,0x40
                  g_pucFont
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  0000004f          DCB      0x00,0x00,0x00,0x4f
000014  00000007          DCB      0x00,0x00,0x00,0x07
000018  00070014          DCB      0x00,0x07,0x00,0x14
00001c  7f147f14          DCB      0x7f,0x14,0x7f,0x14
000020  242a7f2a          DCB      0x24,0x2a,0x7f,0x2a
000024  12231308          DCB      0x12,0x23,0x13,0x08
000028  64623649          DCB      0x64,0x62,0x36,0x49
00002c  55225000          DCB      0x55,0x22,0x50,0x00
000030  05030000          DCB      0x05,0x03,0x00,0x00
000034  001c2241          DCB      0x00,0x1c,0x22,0x41
000038  00004122          DCB      0x00,0x00,0x41,0x22
00003c  1c001408          DCB      0x1c,0x00,0x14,0x08
000040  3e081408          DCB      0x3e,0x08,0x14,0x08
000044  083e0808          DCB      0x08,0x3e,0x08,0x08
000048  00503000          DCB      0x00,0x50,0x30,0x00
00004c  00080808          DCB      0x00,0x08,0x08,0x08
000050  08080060          DCB      0x08,0x08,0x00,0x60
000054  60000020          DCB      0x60,0x00,0x00,0x20
000058  10080402          DCB      0x10,0x08,0x04,0x02
00005c  3e514945          DCB      0x3e,0x51,0x49,0x45
000060  3e00427f          DCB      0x3e,0x00,0x42,0x7f
000064  40004261          DCB      0x40,0x00,0x42,0x61
000068  51494621          DCB      0x51,0x49,0x46,0x21
00006c  41454b31          DCB      0x41,0x45,0x4b,0x31
000070  1814127f          DCB      0x18,0x14,0x12,0x7f
000074  10274545          DCB      0x10,0x27,0x45,0x45
000078  45393c4a          DCB      0x45,0x39,0x3c,0x4a
00007c  49493001          DCB      0x49,0x49,0x30,0x01
000080  71090503          DCB      0x71,0x09,0x05,0x03
000084  36494949          DCB      0x36,0x49,0x49,0x49
000088  36064949          DCB      0x36,0x06,0x49,0x49
00008c  291e0036          DCB      0x29,0x1e,0x00,0x36
000090  36000000          DCB      0x36,0x00,0x00,0x00
000094  56360000          DCB      0x56,0x36,0x00,0x00
000098  08142241          DCB      0x08,0x14,0x22,0x41
00009c  00141414          DCB      0x00,0x14,0x14,0x14
0000a0  14140041          DCB      0x14,0x14,0x00,0x41
0000a4  22140802          DCB      0x22,0x14,0x08,0x02
0000a8  01510906          DCB      0x01,0x51,0x09,0x06
0000ac  32497941          DCB      0x32,0x49,0x79,0x41
0000b0  3e7e1111          DCB      0x3e,0x7e,0x11,0x11
0000b4  117e7f49          DCB      0x11,0x7e,0x7f,0x49
0000b8  4949363e          DCB      0x49,0x49,0x36,0x3e
0000bc  41414122          DCB      0x41,0x41,0x41,0x22
0000c0  7f414122          DCB      0x7f,0x41,0x41,0x22
0000c4  1c7f4949          DCB      0x1c,0x7f,0x49,0x49
0000c8  49417f09          DCB      0x49,0x41,0x7f,0x09
0000cc  0909013e          DCB      0x09,0x09,0x01,0x3e
0000d0  4149497a          DCB      0x41,0x49,0x49,0x7a
0000d4  7f080808          DCB      0x7f,0x08,0x08,0x08
0000d8  7f00417f          DCB      0x7f,0x00,0x41,0x7f
0000dc  41002040          DCB      0x41,0x00,0x20,0x40
0000e0  413f017f          DCB      0x41,0x3f,0x01,0x7f
0000e4  08142241          DCB      0x08,0x14,0x22,0x41
0000e8  7f404040          DCB      0x7f,0x40,0x40,0x40
0000ec  407f020c          DCB      0x40,0x7f,0x02,0x0c
0000f0  027f7f04          DCB      0x02,0x7f,0x7f,0x04
0000f4  08107f3e          DCB      0x08,0x10,0x7f,0x3e
0000f8  4141413e          DCB      0x41,0x41,0x41,0x3e
0000fc  7f090909          DCB      0x7f,0x09,0x09,0x09
000100  063e4151          DCB      0x06,0x3e,0x41,0x51
000104  215e7f09          DCB      0x21,0x5e,0x7f,0x09
000108  19294646          DCB      0x19,0x29,0x46,0x46
00010c  49494931          DCB      0x49,0x49,0x49,0x31
000110  01017f01          DCB      0x01,0x01,0x7f,0x01
000114  013f4040          DCB      0x01,0x3f,0x40,0x40
000118  403f1f20          DCB      0x40,0x3f,0x1f,0x20
00011c  40201f3f          DCB      0x40,0x20,0x1f,0x3f
000120  4038403f          DCB      0x40,0x38,0x40,0x3f
000124  63140814          DCB      0x63,0x14,0x08,0x14
000128  63070870          DCB      0x63,0x07,0x08,0x70
00012c  08076151          DCB      0x08,0x07,0x61,0x51
000130  49454300          DCB      0x49,0x45,0x43,0x00
000134  7f414100          DCB      0x7f,0x41,0x41,0x00
000138  02040810          DCB      0x02,0x04,0x08,0x10
00013c  20004141          DCB      0x20,0x00,0x41,0x41
000140  7f000402          DCB      0x7f,0x00,0x04,0x02
000144  01020440          DCB      0x01,0x02,0x04,0x40
000148  40404040          DCB      0x40,0x40,0x40,0x40
00014c  00010204          DCB      0x00,0x01,0x02,0x04
000150  00205454          DCB      0x00,0x20,0x54,0x54
000154  54787f48          DCB      0x54,0x78,0x7f,0x48
000158  44443838          DCB      0x44,0x44,0x38,0x38
00015c  44444420          DCB      0x44,0x44,0x44,0x20
000160  38444448          DCB      0x38,0x44,0x44,0x48
000164  7f385454          DCB      0x7f,0x38,0x54,0x54
000168  5418087e          DCB      0x54,0x18,0x08,0x7e
00016c  0901020c          DCB      0x09,0x01,0x02,0x0c
000170  5252523e          DCB      0x52,0x52,0x52,0x3e
000174  7f080404          DCB      0x7f,0x08,0x04,0x04
000178  7800447d          DCB      0x78,0x00,0x44,0x7d
00017c  40002040          DCB      0x40,0x00,0x20,0x40
000180  443d007f          DCB      0x44,0x3d,0x00,0x7f
000184  10284400          DCB      0x10,0x28,0x44,0x00
000188  00417f40          DCB      0x00,0x41,0x7f,0x40
00018c  007c0418          DCB      0x00,0x7c,0x04,0x18
000190  04787c08          DCB      0x04,0x78,0x7c,0x08
000194  04047838          DCB      0x04,0x04,0x78,0x38
000198  44444438          DCB      0x44,0x44,0x44,0x38
00019c  7c141414          DCB      0x7c,0x14,0x14,0x14
0001a0  08081414          DCB      0x08,0x08,0x14,0x14
0001a4  187c7c08          DCB      0x18,0x7c,0x7c,0x08
0001a8  04040848          DCB      0x04,0x04,0x08,0x48
0001ac  54545420          DCB      0x54,0x54,0x54,0x20
0001b0  043f4440          DCB      0x04,0x3f,0x44,0x40
0001b4  203c4040          DCB      0x20,0x3c,0x40,0x40
0001b8  207c1c20          DCB      0x20,0x7c,0x1c,0x20
0001bc  40201c3c          DCB      0x40,0x20,0x1c,0x3c
0001c0  4030403c          DCB      0x40,0x30,0x40,0x3c
0001c4  44281028          DCB      0x44,0x28,0x10,0x28
0001c8  440c5050          DCB      0x44,0x0c,0x50,0x50
0001cc  503c4464          DCB      0x50,0x3c,0x44,0x64
0001d0  544c4400          DCB      0x54,0x4c,0x44,0x00
0001d4  08364100          DCB      0x08,0x36,0x41,0x00
0001d8  00007f00          DCB      0x00,0x00,0x7f,0x00
0001dc  00004136          DCB      0x00,0x00,0x41,0x36
0001e0  08000201          DCB      0x08,0x00,0x02,0x01
0001e4  020402            DCB      0x02,0x04,0x02
                  g_pucRITInit
0001e7  08                DCB      0x08
0001e8  80ae80ad          DCB      0x80,0xae,0x80,0xad
0001ec  808a80e3          DCB      0x80,0x8a,0x80,0xe3
0001f0  0680a880          DCB      0x06,0x80,0xa8,0x80
0001f4  1f80e31e          DCB      0x1f,0x80,0xe3,0x1e
0001f8  80c880a0          DCB      0x80,0xc8,0x80,0xa0
0001fc  80d88005          DCB      0x80,0xd8,0x80,0x05
000200  80408081          DCB      0x80,0x40,0x80,0x81
000204  805d80d9          DCB      0x80,0x5d,0x80,0xd9
000208  801180d5          DCB      0x80,0x11,0x80,0xd5
00020c  800180d3          DCB      0x80,0x01,0x80,0xd3
000210  800080af          DCB      0x80,0x00,0x80,0xaf
000214  80e3              DCB      0x80,0xe3
