; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\io.o --asm_dir=.\rvmdk\listings\ --list_dir=.\rvmdk\listings\ --depend=.\rvmdk\io.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 --omf_browse=.\rvmdk\io.crf ..\drivers\io.c]
                          THUMB

                          AREA ||i.LED_Off||, CODE, READONLY, ALIGN=2

                  LED_Off PROC
;;;345    void
;;;346    LED_Off (tLED eLED)
000000  b430              PUSH     {r4,r5}
;;;347    {
;;;348        //
;;;349        // Check for invalid parameter values.
;;;350        //
;;;351        ASSERT((eLED == BOTH_LEDS) || (eLED == LED_1) || (eLED == LED_2));
;;;352    
;;;353        //
;;;354        // Which LED are we to turn off?
;;;355        //
;;;356        switch (eLED)
;;;357        {
;;;358            //
;;;359            // Turn both LEDs off.
;;;360            //
;;;361            case BOTH_LEDS:
;;;362            {
;;;363                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4 | GPIO_PIN_5, 0);
000002  4b0e              LDR      r3,|L1.60|
000004  f04f7180          MOV      r1,#0x1000000
000008  b158              CBZ      r0,|L1.34|
00000a  2801              CMP      r0,#1                 ;356
00000c  d00e              BEQ      |L1.44|
00000e  2802              CMP      r0,#2                 ;356
000010  d111              BNE      |L1.54|
;;;364                break;
;;;365            }
;;;366    
;;;367            //
;;;368            // Turn LED 1 off.
;;;369            //
;;;370            case LED_1:
;;;371            {
;;;372                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4, 0);
;;;373                break;
;;;374            }
;;;375    
;;;376            //
;;;377            // Turn LED 2 off.
;;;378            //
;;;379            case LED_2:
;;;380            {
;;;381                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_5, 0);
000012  6a08              LDR      r0,[r1,#0x20]
000014  2200              MOVS     r2,#0
000016  2120              MOVS     r1,#0x20
000018  6804              LDR      r4,[r0,#0]
                  |L1.26|
00001a  4618              MOV      r0,r3
00001c  46a4              MOV      r12,r4
00001e  bc30              POP      {r4,r5}
000020  4760              BX       r12
                  |L1.34|
000022  6a08              LDR      r0,[r1,#0x20]         ;363
000024  2200              MOVS     r2,#0                 ;363
000026  2130              MOVS     r1,#0x30              ;363
000028  6804              LDR      r4,[r0,#0]            ;364
00002a  e7f6              B        |L1.26|
                  |L1.44|
00002c  6a08              LDR      r0,[r1,#0x20]         ;372
00002e  2200              MOVS     r2,#0                 ;372
000030  2110              MOVS     r1,#0x10              ;372
000032  6804              LDR      r4,[r0,#0]            ;373
000034  e7f1              B        |L1.26|
                  |L1.54|
;;;382                break;
;;;383            }
;;;384    
;;;385            //
;;;386            // An invalid value was passed.
;;;387            //
;;;388            default:
;;;389                break;
;;;390        }
;;;391    }
000036  bc30              POP      {r4,r5}
000038  4770              BX       lr
;;;392    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      0x40025000

                          AREA ||i.LED_On||, CODE, READONLY, ALIGN=2

                  LED_On PROC
;;;283    void
;;;284    LED_On(tLED eLED)
000000  b430              PUSH     {r4,r5}
;;;285    {
;;;286        //
;;;287        // Check for invalid parameter values.
;;;288        //
;;;289        ASSERT((eLED == BOTH_LEDS) || (eLED == LED_1) || (eLED == LED_2));
;;;290    
;;;291        //
;;;292        // Which LED are we to turn on?
;;;293        //
;;;294        switch (eLED)
;;;295        {
;;;296            //
;;;297            // Turn both LEDs on.
;;;298            //
;;;299            case BOTH_LEDS:
;;;300            {
;;;301                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4 | GPIO_PIN_5,
000002  4b0e              LDR      r3,|L2.60|
000004  f04f7180          MOV      r1,#0x1000000
000008  b158              CBZ      r0,|L2.34|
00000a  2801              CMP      r0,#1                 ;294
00000c  d00e              BEQ      |L2.44|
00000e  2802              CMP      r0,#2                 ;294
000010  d111              BNE      |L2.54|
;;;302                                 GPIO_PIN_4 | GPIO_PIN_5);
;;;303                break;
;;;304            }
;;;305    
;;;306            //
;;;307            // Turn LED 1 on.
;;;308            //
;;;309            case LED_1:
;;;310            {
;;;311                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_PIN_4);
;;;312                break;
;;;313            }
;;;314    
;;;315            //
;;;316            // Turn LED 2 on.
;;;317            //
;;;318            case LED_2:
;;;319            {
;;;320                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_5, GPIO_PIN_5);
000012  6a08              LDR      r0,[r1,#0x20]
000014  2220              MOVS     r2,#0x20
000016  4611              MOV      r1,r2
000018  6804              LDR      r4,[r0,#0]
                  |L2.26|
00001a  4618              MOV      r0,r3
00001c  46a4              MOV      r12,r4
00001e  bc30              POP      {r4,r5}
000020  4760              BX       r12
                  |L2.34|
000022  6a08              LDR      r0,[r1,#0x20]         ;301
000024  2230              MOVS     r2,#0x30              ;301
000026  4611              MOV      r1,r2                 ;301
000028  6804              LDR      r4,[r0,#0]            ;303
00002a  e7f6              B        |L2.26|
                  |L2.44|
00002c  6a08              LDR      r0,[r1,#0x20]         ;311
00002e  2210              MOVS     r2,#0x10              ;311
000030  4611              MOV      r1,r2                 ;311
000032  6804              LDR      r4,[r0,#0]            ;312
000034  e7f1              B        |L2.26|
                  |L2.54|
;;;321                break;
;;;322            }
;;;323    
;;;324            //
;;;325            // An invalid LED value was passed.
;;;326            //
;;;327            default:
;;;328                break;
;;;329        }
;;;330    }
000036  bc30              POP      {r4,r5}
000038  4770              BX       lr
;;;331    
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      0x40025000

                          AREA ||i.LED_Toggle||, CODE, READONLY, ALIGN=2

                  LED_Toggle PROC
;;;407    void
;;;408    LED_Toggle (tLED eLED)
000000  b570              PUSH     {r4-r6,lr}
;;;409    {
;;;410        //
;;;411        // Check for invalid parameter values.
;;;412        //
;;;413        ASSERT((eLED == BOTH_LEDS) || (eLED == LED_1) || (eLED == LED_2));
;;;414    
;;;415        //
;;;416        // Which LED are we to toggle?
;;;417        //
;;;418        switch (eLED)
;;;419        {
;;;420            //
;;;421            // Toggle both LEDs.
;;;422            //
;;;423            case BOTH_LEDS:
;;;424            {
;;;425                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4 | GPIO_PIN_5,
000002  4d16              LDR      r5,|L3.92|
000004  f04f7480          MOV      r4,#0x1000000
000008  b188              CBZ      r0,|L3.46|
00000a  2801              CMP      r0,#1                 ;418
00000c  d01a              BEQ      |L3.68|
00000e  2802              CMP      r0,#2                 ;418
000010  d123              BNE      |L3.90|
;;;426                          ~ROM_GPIOPinRead(GPIO_PORTF_BASE,
;;;427                                           GPIO_PIN_4 | GPIO_PIN_5));
;;;428                 break;
;;;429            }
;;;430    
;;;431            //
;;;432            // Toggle LED 1.
;;;433            //
;;;434            case LED_1:
;;;435            {
;;;436                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_4,
;;;437                                 ~ROM_GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4));
;;;438                break;
;;;439            }
;;;440    
;;;441            //
;;;442            // Toggle LED 2.
;;;443            //
;;;444            case LED_2:
;;;445            {
;;;446                ROM_GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_5,
000012  6a20              LDR      r0,[r4,#0x20]
000014  2120              MOVS     r1,#0x20
000016  6ac2              LDR      r2,[r0,#0x2c]
000018  4628              MOV      r0,r5
00001a  4790              BLX      r2
00001c  43c0              MVNS     r0,r0
00001e  b2c2              UXTB     r2,r0
000020  6a20              LDR      r0,[r4,#0x20]
000022  2120              MOVS     r1,#0x20
000024  6803              LDR      r3,[r0,#0]
                  |L3.38|
000026  4628              MOV      r0,r5
000028  e8bd4070          POP      {r4-r6,lr}
00002c  4718              BX       r3
                  |L3.46|
00002e  6a20              LDR      r0,[r4,#0x20]         ;425
000030  2130              MOVS     r1,#0x30              ;425
000032  6ac2              LDR      r2,[r0,#0x2c]         ;425
000034  4628              MOV      r0,r5                 ;425
000036  4790              BLX      r2                    ;425
000038  43c0              MVNS     r0,r0                 ;425
00003a  b2c2              UXTB     r2,r0                 ;425
00003c  6a20              LDR      r0,[r4,#0x20]         ;425
00003e  2130              MOVS     r1,#0x30              ;425
000040  6803              LDR      r3,[r0,#0]            ;428
000042  e7f0              B        |L3.38|
                  |L3.68|
000044  6a20              LDR      r0,[r4,#0x20]         ;436
000046  2110              MOVS     r1,#0x10              ;436
000048  6ac2              LDR      r2,[r0,#0x2c]         ;436
00004a  4628              MOV      r0,r5                 ;436
00004c  4790              BLX      r2                    ;436
00004e  43c0              MVNS     r0,r0                 ;436
000050  b2c2              UXTB     r2,r0                 ;436
000052  6a20              LDR      r0,[r4,#0x20]         ;436
000054  2110              MOVS     r1,#0x10              ;436
000056  6803              LDR      r3,[r0,#0]            ;438
000058  e7e5              B        |L3.38|
                  |L3.90|
;;;447                                 ~ROM_GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_5));
;;;448                break;
;;;449            }
;;;450    
;;;451            //
;;;452            // An invalid value was passed.
;;;453            //
;;;454            default:
;;;455                break;
;;;456        }
;;;457    }
00005a  bd70              POP      {r4-r6,pc}
;;;458    
                          ENDP

                  |L3.92|
                          DCD      0x40025000

                          AREA ||i.LEDsInit||, CODE, READONLY, ALIGN=2

                  LEDsInit PROC
;;;251    void
;;;252    LEDsInit (void)
000000  b510              PUSH     {r4,lr}
;;;253    {
;;;254        //
;;;255        // Enable the GPIO port used to control the LEDs.
;;;256        //
;;;257        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
000002  f04f7480          MOV      r4,#0x1000000
000006  6c60              LDR      r0,[r4,#0x44]
000008  6981              LDR      r1,[r0,#0x18]
00000a  4806              LDR      r0,|L4.36|
00000c  4788              BLX      r1
;;;258    
;;;259        //
;;;260        // Set the LED GPIOs as output.
;;;261        //
;;;262        ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_4 | GPIO_PIN_5);
00000e  6a20              LDR      r0,[r4,#0x20]
000010  2130              MOVS     r1,#0x30
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  4804              LDR      r0,|L4.40|
000016  4790              BLX      r2
;;;263    
;;;264        //
;;;265        // Turn off both LEDs
;;;266        //
;;;267        LED_Off(BOTH_LEDS);
000018  e8bd4010          POP      {r4,lr}
00001c  2000              MOVS     r0,#0
00001e  f7ffbffe          B.W      LED_Off
;;;268    }
;;;269    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x20000020
                  |L4.40|
                          DCD      0x40025000

                          AREA ||i.PushButtonDebouncer||, CODE, READONLY, ALIGN=2

                  PushButtonDebouncer PROC
;;;83     void
;;;84     PushButtonDebouncer(void)
000000  b570              PUSH     {r4-r6,lr}
;;;85     {
;;;86         static unsigned char ucButtonsClockA = 0;
;;;87         static unsigned char ucButtonsClockB = 0;
;;;88         unsigned char ucData;
;;;89         unsigned char ucDelta;
;;;90     
;;;91         //
;;;92         // Read the current state of the hardware push buttons
;;;93         //
;;;94         ucData = ROM_GPIOPinRead(GPIO_PORTD_BASE, GPIO_PIN_6 | GPIO_PIN_7);
000002  f04f7080          MOV      r0,#0x1000000
000006  21c0              MOVS     r1,#0xc0
000008  6a00              LDR      r0,[r0,#0x20]
00000a  6ac2              LDR      r2,[r0,#0x2c]
00000c  480a              LDR      r0,|L5.56|
00000e  4790              BLX      r2
;;;95     
;;;96         //
;;;97         // Determine buttons that are in a different state from the debounced state
;;;98         //
;;;99         ucDelta = ucData ^ g_ucDebouncedButtons;
000010  490a              LDR      r1,|L5.60|
000012  780d              LDRB     r5,[r1,#0]  ; g_ucDebouncedButtons
;;;100    
;;;101        //
;;;102        // Increment the debounce counter by one
;;;103        //
;;;104        ucButtonsClockA ^= ucButtonsClockB;
000014  784b              LDRB     r3,[r1,#1]  ; ucButtonsClockA
000016  788c              LDRB     r4,[r1,#2]  ; ucButtonsClockB
000018  ea800205          EOR      r2,r0,r5              ;99
00001c  4063              EORS     r3,r3,r4
;;;105        ucButtonsClockB = ~ucButtonsClockB;
;;;106    
;;;107        //
;;;108        // Reset the debounce counter for any button that is unchanged
;;;109        //
;;;110        ucButtonsClockA &= ucDelta;
00001e  4013              ANDS     r3,r3,r2
000020  704b              STRB     r3,[r1,#1]
;;;111        ucButtonsClockB &= ucDelta;
000022  ea220404          BIC      r4,r2,r4
;;;112    
;;;113        //
;;;114        // Determine the new debounced button state based on the debounce
;;;115        // counter.
;;;116        //
;;;117        g_ucDebouncedButtons &= ucButtonsClockA | ucButtonsClockB;
000026  4323              ORRS     r3,r3,r4
000028  708c              STRB     r4,[r1,#2]            ;111
00002a  ea030405          AND      r4,r3,r5
;;;118        g_ucDebouncedButtons |= (~(ucButtonsClockA | ucButtonsClockB)) & ucData;
00002e  4398              BICS     r0,r0,r3
000030  4320              ORRS     r0,r0,r4
000032  7008              STRB     r0,[r1,#0]
;;;119    }
000034  bd70              POP      {r4-r6,pc}
;;;120    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40007000
                  |L5.60|
                          DCD      ||.data||

                          AREA ||i.PushButtonGetDebounced||, CODE, READONLY, ALIGN=2

                  PushButtonGetDebounced PROC
;;;197    //*****************************************************************************
;;;198    tBoolean  PushButtonGetDebounced(tButton eButton)
000000  4905              LDR      r1,|L6.24|
;;;199    {
;;;200        tBoolean  status;
;;;201    
;;;202        //
;;;203        // Check for invalid parameter values.
;;;204        //
;;;205        ASSERT((eButton == BUTTON_1) || (eButton == BUTTON_2));
;;;206    
;;;207        //
;;;208        // Which button are we to query?
;;;209        //
;;;210        switch (eButton)
;;;211        {
;;;212            //
;;;213            // Switch 1.
;;;214            //
;;;215            case BUTTON_1:
;;;216            {
;;;217                status = g_ucDebouncedButtons & GPIO_PIN_6 ? true : false;
000002  7809              LDRB     r1,[r1,#0]
000004  b118              CBZ      r0,|L6.14|
000006  2801              CMP      r0,#1                 ;210
000008  d004              BEQ      |L6.20|
;;;218                break;
;;;219            }
;;;220    
;;;221            //
;;;222            // Switch 2.
;;;223            //
;;;224            case BUTTON_2:
;;;225            {
;;;226                status = g_ucDebouncedButtons & GPIO_PIN_7 ? true : false;
;;;227                break;
;;;228            }
;;;229    
;;;230            //
;;;231            // An illegal button ID was passed.
;;;232            //
;;;233            default:
;;;234                status = true;
00000a  2001              MOVS     r0,#1
;;;235                break;
;;;236        }
;;;237    
;;;238        return (status);
;;;239    }
00000c  4770              BX       lr
                  |L6.14|
00000e  f3c11080          UBFX     r0,r1,#6,#1           ;217
000012  4770              BX       lr
                  |L6.20|
000014  09c8              LSRS     r0,r1,#7              ;226
000016  4770              BX       lr
;;;240    
                          ENDP

                  |L6.24|
                          DCD      ||.data||

                          AREA ||i.PushButtonGetStatus||, CODE, READONLY, ALIGN=2

                  PushButtonGetStatus PROC
;;;135    //*****************************************************************************
;;;136    tBoolean  PushButtonGetStatus (tButton eButton)
000000  b510              PUSH     {r4,lr}
;;;137    {
;;;138        tBoolean  status;
;;;139    
;;;140        //
;;;141        // Check for invalid parameter values.
;;;142        //
;;;143        ASSERT((eButton == BUTTON_1) || (eButton == BUTTON_2));
;;;144    
;;;145        //
;;;146        // Which button are we to query?
;;;147        //
;;;148        switch (eButton)
;;;149        {
;;;150            //
;;;151            // Switch 1.
;;;152            //
;;;153            case BUTTON_1:
;;;154            {
;;;155                status = ROM_GPIOPinRead(GPIO_PORTD_BASE, GPIO_PIN_6) ?
000002  4b0a              LDR      r3,|L7.44|
000004  f04f7180          MOV      r1,#0x1000000
000008  b110              CBZ      r0,|L7.16|
00000a  2801              CMP      r0,#1                 ;148
00000c  d10b              BNE      |L7.38|
00000e  e003              B        |L7.24|
                  |L7.16|
000010  6a08              LDR      r0,[r1,#0x20]
000012  2140              MOVS     r1,#0x40
000014  6ac2              LDR      r2,[r0,#0x2c]
000016  e002              B        |L7.30|
                  |L7.24|
;;;156                                         true : false;
;;;157                break;
;;;158            }
;;;159    
;;;160            //
;;;161            // Switch 2.
;;;162            //
;;;163            case BUTTON_2:
;;;164            {
;;;165                status = ROM_GPIOPinRead(GPIO_PORTD_BASE, GPIO_PIN_7) ?
000018  6a08              LDR      r0,[r1,#0x20]
00001a  2180              MOVS     r1,#0x80
00001c  6ac2              LDR      r2,[r0,#0x2c]
                  |L7.30|
00001e  4618              MOV      r0,r3                 ;155
000020  4790              BLX      r2                    ;155
000022  2800              CMP      r0,#0                 ;155
000024  d000              BEQ      |L7.40|
                  |L7.38|
;;;166                                         true : false;
;;;167                break;
;;;168            }
;;;169    
;;;170            //
;;;171            // An illegal button ID was passed.
;;;172            //
;;;173            default:
;;;174                status = true;
000026  2001              MOVS     r0,#1
                  |L7.40|
;;;175                break;
;;;176        }
;;;177    
;;;178        return (status);
;;;179    }
000028  bd10              POP      {r4,pc}
;;;180    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40007000

                          AREA ||i.PushButtonsInit||, CODE, READONLY, ALIGN=2

                  PushButtonsInit PROC
;;;56     void
;;;57     PushButtonsInit (void)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
;;;59         //
;;;60         // Enable the GPIO port used by the pushbuttons.
;;;61         //
;;;62         ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
000002  f04f7480          MOV      r4,#0x1000000
000006  6c60              LDR      r0,[r4,#0x44]
000008  6981              LDR      r1,[r0,#0x18]
00000a  4809              LDR      r0,|L8.48|
00000c  4788              BLX      r1
;;;63     
;;;64         //
;;;65         // Set the button GPIOs as inputs.
;;;66         //
;;;67         ROM_GPIOPinTypeGPIOInput(GPIO_PORTD_BASE, GPIO_PIN_6 | GPIO_PIN_7);
00000e  6a20              LDR      r0,[r4,#0x20]
000010  4d08              LDR      r5,|L8.52|
000012  21c0              MOVS     r1,#0xc0
000014  6b82              LDR      r2,[r0,#0x38]
000016  4628              MOV      r0,r5
000018  4790              BLX      r2
;;;68         ROM_GPIOPadConfigSet(GPIO_PORTD_BASE, GPIO_PIN_6 | GPIO_PIN_7,
00001a  6a20              LDR      r0,[r4,#0x20]
00001c  230a              MOVS     r3,#0xa
00001e  2201              MOVS     r2,#1
000020  6944              LDR      r4,[r0,#0x14]
000022  4628              MOV      r0,r5
000024  46a4              MOV      r12,r4
000026  e8bd4070          POP      {r4-r6,lr}
00002a  21c0              MOVS     r1,#0xc0
00002c  4760              BX       r12
;;;69                              GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
;;;70     }
;;;71     
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0x20000008
                  |L8.52|
                          DCD      0x40007000

                          AREA ||.data||, DATA, ALIGN=0

                  g_ucDebouncedButtons
000000  c0                DCB      0xc0
                  ucButtonsClockA
000001  00                DCB      0x00
                  ucButtonsClockB
000002  00                DCB      0x00
