; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\rvmdk\motor_demo.o --asm_dir=.\rvmdk\listings\ --list_dir=.\rvmdk\listings\ --depend=.\rvmdk\motor_demo.d --cpu=Cortex-M3 --apcs=interwork -I. -I.. -I..\..\.. -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Luminary -D__MICROLIB -Drvmdk -DPART_LM3S9B96 -DTARGET_IS_TEMPEST_RB1 --omf_browse=.\rvmdk\motor_demo.crf motor_demo.c]
                          THUMB

                          AREA ||i.SysTickHandler||, CODE, READONLY, ALIGN=2

                  SysTickHandler PROC
;;;104    void
;;;105    SysTickHandler(void)
000000  480a              LDR      r0,|L1.44|
;;;106    {
000002  b510              PUSH     {r4,lr}
;;;107        //
;;;108        // Increment the tick counter.
;;;109        //
;;;110        g_ulTickCount++;
000004  6801              LDR      r1,[r0,#0]  ; g_ulTickCount
000006  1c49              ADDS     r1,r1,#1
000008  6001              STR      r1,[r0,#0]  ; g_ulTickCount
;;;111    
;;;112        //
;;;113        // Every 100 ticks (1 second), toggle the LEDs
;;;114        //
;;;115        if((g_ulTickCount % 100) == 0)
00000a  6800              LDR      r0,[r0,#0]  ; g_ulTickCount
00000c  2164              MOVS     r1,#0x64
00000e  fbb0f2f1          UDIV     r2,r0,r1
000012  fb010012          MLS      r0,r1,r2,r0
000016  b910              CBNZ     r0,|L1.30|
;;;116        {
;;;117            LED_Toggle(BOTH_LEDS);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       LED_Toggle
                  |L1.30|
;;;118        }
;;;119    
;;;120        //
;;;121        // Call the user button and bump sensor debouncing functions, which must
;;;122        // be called periodically.
;;;123        //
;;;124        PushButtonDebouncer();
00001e  f7fffffe          BL       PushButtonDebouncer
;;;125        BumpSensorDebouncer();
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      BumpSensorDebouncer
;;;126    }
;;;127    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;134    int
;;;135    main(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;136    {
;;;137        unsigned long ulPHYMR0;
;;;138        tBoolean bButtonWasPressed[2] = { false, false };
000002  f04f0900          MOV      r9,#0
;;;139        tBoolean bReverse[2] = { true, true };
000006  a048              ADR      r0,|L2.296|
000008  f8cd9008          STR      r9,[sp,#8]
00000c  6800              LDR      r0,[r0,#0]
;;;140        tMotorState sMotorState[2] = { STATE_STOPPED, STATE_STOPPED };
;;;141    
;;;142        //
;;;143        // Set the clocking to directly from the crystal
;;;144        //
;;;145        ROM_SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN |
00000e  e9cd0900          STRD     r0,r9,[sp,#0]
000012  f04f7480          MOV      r4,#0x1000000
000016  6c60              LDR      r0,[r4,#0x44]
000018  6dc1              LDR      r1,[r0,#0x5c]
00001a  4844              LDR      r0,|L2.300|
00001c  4788              BLX      r1
;;;146                           SYSCTL_XTAL_16MHZ);
;;;147    
;;;148        //
;;;149        // Since the Ethernet is not used, power down the PHY to save battery.
;;;150        //
;;;151        ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_ETH);
00001e  6c60              LDR      r0,[r4,#0x44]
000020  6981              LDR      r1,[r0,#0x18]
000022  4843              LDR      r0,|L2.304|
000024  4788              BLX      r1
;;;152        ulPHYMR0 = ROM_EthernetPHYRead(ETH_BASE, PHY_MR0);
000026  6ce0              LDR      r0,[r4,#0x4c]
000028  4d42              LDR      r5,|L2.308|
00002a  2100              MOVS     r1,#0
00002c  6c82              LDR      r2,[r0,#0x48]
00002e  4628              MOV      r0,r5
000030  4790              BLX      r2
;;;153        ROM_EthernetPHYWrite(ETH_BASE, PHY_MR0, ulPHYMR0 | PHY_MR0_PWRDN);
000032  f4406200          ORR      r2,r0,#0x800
000036  6ce0              LDR      r0,[r4,#0x4c]
000038  2100              MOVS     r1,#0
00003a  6c43              LDR      r3,[r0,#0x44]
00003c  4628              MOV      r0,r5
00003e  4798              BLX      r3
;;;154    
;;;155        //
;;;156        // Initialize the board display
;;;157        //
;;;158        Display96x16x1Init(true);
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       Display96x16x1Init
;;;159    
;;;160        //
;;;161        // Print a simple message to the display
;;;162        //
;;;163        Display96x16x1StringDraw("MOTOR", 29, 0);
000046  2200              MOVS     r2,#0
000048  211d              MOVS     r1,#0x1d
00004a  a03b              ADR      r0,|L2.312|
00004c  f7fffffe          BL       Display96x16x1StringDraw
;;;164        Display96x16x1StringDraw("DEMO", 31, 1);
000050  2201              MOVS     r2,#1
000052  211f              MOVS     r1,#0x1f
000054  a03a              ADR      r0,|L2.320|
000056  f7fffffe          BL       Display96x16x1StringDraw
;;;165    
;;;166        //
;;;167        // Initialize the LED driver, then turn one LED on
;;;168        //
;;;169        LEDsInit();
00005a  f7fffffe          BL       LEDsInit
;;;170        LED_On(LED_1);
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       LED_On
;;;171    
;;;172        //
;;;173        // Initialize the buttons driver
;;;174        //
;;;175        PushButtonsInit();
000064  f7fffffe          BL       PushButtonsInit
;;;176    
;;;177        //
;;;178        // Initialize the bump sensor driver
;;;179        //
;;;180        BumpSensorsInit();
000068  f7fffffe          BL       BumpSensorsInit
;;;181    
;;;182        //
;;;183        // Initialize the motor driver
;;;184        //
;;;185        MotorsInit();
00006c  f7fffffe          BL       MotorsInit
;;;186    
;;;187        //
;;;188        // Set up and enable the SysTick timer to use as a time reference.
;;;189        // It will be set up for a 10 ms tick.
;;;190        //
;;;191        ROM_SysTickPeriodSet(ROM_SysCtlClockGet() / 100);
000070  6c60              LDR      r0,[r4,#0x44]
000072  6e00              LDR      r0,[r0,#0x60]
000074  4780              BLX      r0
000076  2164              MOVS     r1,#0x64
000078  fbb0f0f1          UDIV     r0,r0,r1
00007c  6ba1              LDR      r1,[r4,#0x38]
00007e  6949              LDR      r1,[r1,#0x14]
000080  4788              BLX      r1
;;;192        ROM_SysTickEnable();
000082  6ba0              LDR      r0,[r4,#0x38]
000084  6840              LDR      r0,[r0,#4]
000086  4780              BLX      r0
;;;193        ROM_SysTickIntEnable();
000088  6ba0              LDR      r0,[r4,#0x38]
00008a  68c0              LDR      r0,[r0,#0xc]
00008c  4780              BLX      r0
00008e  f04f0a01          MOV      r10,#1                ;158
000092  af01              ADD      r7,sp,#4              ;140
000094  f10d0808          ADD      r8,sp,#8              ;138
                  |L2.152|
;;;194    
;;;195        //
;;;196        // Enter loop to run forever, processing button presses to make the
;;;197        // motors run, pause, and stop.
;;;198        //
;;;199        for(;;)
;;;200        {
;;;201            unsigned long ulMotor;
;;;202    
;;;203            //
;;;204            // Process a state machine for each motor
;;;205            //
;;;206            for(ulMotor = 0; ulMotor < 2; ulMotor++)
000098  2400              MOVS     r4,#0
                  |L2.154|
;;;207            {
;;;208                tBoolean bButtonIsPressed;
;;;209                tBoolean bBumperIsPressed;
;;;210    
;;;211                //
;;;212                // Get the current button and bump sensor state for this motor
;;;213                //
;;;214                bButtonIsPressed = !PushButtonGetDebounced(ulMotor);
00009a  b2e0              UXTB     r0,r4
00009c  4605              MOV      r5,r0
00009e  f7fffffe          BL       PushButtonGetDebounced
0000a2  b160              CBZ      r0,|L2.190|
0000a4  2600              MOVS     r6,#0
                  |L2.166|
0000a6  4628              MOV      r0,r5
;;;215                bBumperIsPressed = !BumpSensorGetDebounced(ulMotor);
0000a8  f7fffffe          BL       BumpSensorGetDebounced
0000ac  b148              CBZ      r0,|L2.194|
0000ae  2100              MOVS     r1,#0
                  |L2.176|
;;;216    
;;;217                switch(sMotorState[ulMotor])
0000b0  5d38              LDRB     r0,[r7,r4]
0000b2  b140              CBZ      r0,|L2.198|
0000b4  2801              CMP      r0,#1
0000b6  d019              BEQ      |L2.236|
0000b8  2802              CMP      r0,#2
0000ba  d122              BNE      |L2.258|
0000bc  e027              B        |L2.270|
                  |L2.190|
0000be  2601              MOVS     r6,#1                 ;214
0000c0  e7f1              B        |L2.166|
                  |L2.194|
0000c2  2101              MOVS     r1,#1                 ;215
0000c4  e7f4              B        |L2.176|
                  |L2.198|
;;;218                {
;;;219                    //
;;;220                    // STOPPED state - the motor is not running, and is waiting for
;;;221                    // a button press to start running
;;;222                    //
;;;223                    case STATE_STOPPED:
;;;224                    {
;;;225                        //
;;;226                        // If the button for this motor is pressed (and it was
;;;227                        // not pressed before), then start the motor running.
;;;228                        //
;;;229                        if(bButtonIsPressed && !bButtonWasPressed[ulMotor])
0000c6  b30e              CBZ      r6,|L2.268|
0000c8  f8180004          LDRB     r0,[r8,r4]
0000cc  b9f0              CBNZ     r0,|L2.268|
;;;230                        {
;;;231                            //
;;;232                            // Change the direction from whatever it was before
;;;233                            //
;;;234                            bReverse[ulMotor] ^= 1;
0000ce  f81d1004          LDRB     r1,[sp,r4]
0000d2  4628              MOV      r0,r5
0000d4  f0810101          EOR      r1,r1,#1
0000d8  f80d1004          STRB     r1,[sp,r4]
;;;235                            MotorDir(ulMotor, bReverse[ulMotor]);
0000dc  f7fffffe          BL       MotorDir
;;;236    
;;;237                            //
;;;238                            // Set the motor duty cycle to 50%.
;;;239                            // Duty cycle is specified as 8.8 fixed point.
;;;240                            //
;;;241                            MotorSpeed(ulMotor, 50 << 8);
0000e0  f44f5148          MOV      r1,#0x3200
0000e4  4628              MOV      r0,r5
0000e6  f7fffffe          BL       MotorSpeed
;;;242    
;;;243                            //
;;;244                            // Start the motor running
;;;245                            //
;;;246                            MotorRun(ulMotor);
;;;247    
;;;248                            //
;;;249                            // Change to running state
;;;250                            //
;;;251                            sMotorState[ulMotor] = STATE_RUNNING;
0000ea  e011              B        |L2.272|
                  |L2.236|
;;;252                        }
;;;253                        break;
;;;254                    }
;;;255    
;;;256                    //
;;;257                    // RUNNING state - wait for button press to stop the
;;;258                    // motor, or bumper press to pause the motor
;;;259                    //
;;;260                    case STATE_RUNNING:
;;;261                    {
;;;262                        //
;;;263                        // If the button for this motor is pressed (and it was
;;;264                        // not pressed before), then stop the motor.
;;;265                        //
;;;266                        if(bButtonIsPressed && !bButtonWasPressed[ulMotor])
0000ec  b116              CBZ      r6,|L2.244|
0000ee  f8180004          LDRB     r0,[r8,r4]
0000f2  b130              CBZ      r0,|L2.258|
                  |L2.244|
;;;267                        {
;;;268                            MotorStop(ulMotor);
;;;269    
;;;270                            //
;;;271                            // Change to stopped state
;;;272                            //
;;;273                            sMotorState[ulMotor] = STATE_STOPPED;
;;;274                        }
;;;275    
;;;276                        //
;;;277                        // Check to see if the bump sensor is pressed
;;;278                        //
;;;279                        else if(bBumperIsPressed)
0000f4  b151              CBZ      r1,|L2.268|
0000f6  4628              MOV      r0,r5
;;;280                        {
;;;281                            //
;;;282                            // Stop the motor
;;;283                            //
;;;284                            MotorStop(ulMotor);
0000f8  f7fffffe          BL       MotorStop
;;;285    
;;;286                            //
;;;287                            // Change to the paused state
;;;288                            //
;;;289                            sMotorState[ulMotor] = STATE_PAUSED;
0000fc  2002              MOVS     r0,#2
0000fe  5538              STRB     r0,[r7,r4]
000100  e00b              B        |L2.282|
                  |L2.258|
000102  4628              MOV      r0,r5
000104  f7fffffe          BL       MotorStop
000108  f8079004          STRB     r9,[r7,r4]            ;273
                  |L2.268|
00010c  e005              B        |L2.282|
                  |L2.270|
;;;290                        }
;;;291                        break;
;;;292                    }
;;;293    
;;;294                    //
;;;295                    // PAUSED state - wait for bumper to be released
;;;296                    //
;;;297                    case STATE_PAUSED:
;;;298                    {
;;;299                        //
;;;300                        // Check to see if bump sensor is released
;;;301                        //
;;;302                        if(!bBumperIsPressed)
00010e  b921              CBNZ     r1,|L2.282|
                  |L2.272|
000110  4628              MOV      r0,r5
;;;303                        {
;;;304                            //
;;;305                            // Resume the motor running at the previous speed
;;;306                            // and direction
;;;307                            //
;;;308                            MotorRun(ulMotor);
000112  f7fffffe          BL       MotorRun
;;;309    
;;;310                            //
;;;311                            // Change state back to running
;;;312                            //
;;;313                            sMotorState[ulMotor] = STATE_RUNNING;
000116  f807a004          STRB     r10,[r7,r4]
                  |L2.282|
;;;314                        }
;;;315                        break;
;;;316                    }
;;;317    
;;;318                    //
;;;319                    // default is an error.  Stop the motors and go to
;;;320                    // stopped state
;;;321                    //
;;;322                    default:
;;;323                    {
;;;324                        MotorStop(ulMotor);
;;;325                        sMotorState[ulMotor] = STATE_STOPPED;
;;;326                        break;
;;;327                    }
;;;328                } // end switch
;;;329    
;;;330                //
;;;331                // Remember if the button was pressed for the next pass through
;;;332                // the state machine.
;;;333                ///
;;;334                bButtonWasPressed[ulMotor] = bButtonIsPressed;
00011a  f8086004          STRB     r6,[r8,r4]
00011e  1c64              ADDS     r4,r4,#1              ;206
000120  2c02              CMP      r4,#2                 ;206
000122  d3ba              BCC      |L2.154|
000124  e7b8              B        |L2.152|
;;;335    
;;;336            } // end for(ulMotor ...)
;;;337        } // end for(;;)
;;;338    }
;;;339    
                          ENDP

000126  0000              DCW      0x0000
                  |L2.296|
000128  010100            DCB      1,1,0
00012b  00                DCB      0
                  |L2.300|
                          DCD      0x07803d40
                  |L2.304|
                          DCD      0x20105000
                  |L2.308|
                          DCD      0x40048000
                  |L2.312|
000138  4d4f544f          DCB      "MOTOR",0
00013c  5200    
00013e  00                DCB      0
00013f  00                DCB      0
                  |L2.320|
000140  44454d4f          DCB      "DEMO",0
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=2

                  g_ulTickCount
                          DCD      0x00000000

                  __ARM_use_no_argv EQU 0
